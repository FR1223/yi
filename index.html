<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>33聊天模拟器</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Long+Cang&display=swap" rel="stylesheet">
    <!-- 引入新增的Google Fonts字体 -->
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+XiaoWei&family=ZCOOL+KuaiLe&family=ZCOOL+QingKe+HuangYou&family=Liu+Jian+Mao+Cao&family=Zhi+Mang+Xing&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" rel="stylesheet">

<style>
        /* 引入Zpix像素字体 */
        @font-face {
            font-family: 'Zpix';
            src: url('https://cdn.jsdelivr.net/gh/SolidZORO/zpix-pixel-font@master/dist/zpix.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        /* 定义随笔字体和心声字体变量，以便通过JavaScript动态更改 */
        :root {
            --essay-font-family: 'Ma Shan Zheng', cursive, sans-serif; /* 默认随笔字体 */
            --inner-voice-font-family: 'Ma Shan Zheng', cursive, sans-serif; /* 默认心声字体 */

            /* 定义主题颜色变量 - 默认主题 (粉绿米蓝) */
            --theme-color-1: #EDD4D8; /* 主题色1 */
            --theme-color-2: #CCD4CC; /* 主题色2 */
            --theme-color-3: #F4E8DD; /* 主题色3 */
            --theme-color-4: #B5BFCF; /* 主题色4 */

            /* RGB版本的主题色，用于rgba() */
            --theme-color-rgb-1: 237, 212, 216; /* EDD4D8 */
            --theme-color-rgb-2: 204, 212, 204; /* CCD4CC */
            --theme-color-rgb-3: 244, 232, 221; /* F4E8DD */
            --theme-color-rgb-4: 181, 191, 207; /* B5BFCF */

            /* 辅助颜色变量，可随主题调整 */
            --text-color-dark: #333;
            --text-color-medium: #555;
            --text-color-light: #666;
            --text-color-lighter: #999;
            --text-color-white: white; /* 确保白色文本 */

            --header-text-shadow-color: rgba(255, 255, 255, 0.7);
            --status-dot-online: #4CAF50;
            --status-dot-busy: #FFC107;
            --status-dot-offline: #9E9E9E;

            --btn-bg: rgba(255, 255, 255, 0.7);
            --btn-hover-bg: white;
            --btn-icon-color: #555;

            --message-received-bubble-bg: white;
            --message-sent-bubble-text-color: white; /* 修正：玩家气泡字体颜色 */

            --retracted-bubble-bg: #FFF0F0;
            --retracted-bubble-border: #FF6347;
            --auto-reply-bubble-bg: #E0F2F7;
            --auto-reply-bubble-border: #87CEEB;
            --auto-reply-label-bg: #D0EEF5;

            --input-area-bg: white;
            --toggle-input-btn-bg: rgba(255, 255, 255, 0.7);
            --toggle-input-btn-hover-bg: white;
            --toggle-input-btn-icon-color: #555;

            --modal-title-color: #333;
            --close-btn-color: #555;
            --form-label-color: #555;
            --upload-btn-color: white;
            --btn-primary-color: white;

            --inner-voice-color: #FF69B4;
            --inner-voice-bg: #FFF0F5;
            --inner-voice-shadow-rgb: 255, 105, 180;

            --essay-text-color: #444;
            --essay-bg: #FFFACD;
            --essay-border: #E0C068;
            --essay-pin-color: #FFD700;

            --toggle-switch-off-bg: #f0f0f0;
            --toggle-switch-border: #ccc;
            --toggle-switch-handle-bg: white;

            --event-message-bg: rgba(128, 128, 128, 0.1);
            --event-message-color: #555;

            --persona-card-bg-light: #f9f9f9;
            --persona-card-border-light: #eee;

            --moment-input-bg-light: #f0f0f0;
            --moment-input-border-light: #ddd;
            --moment-card-bg-light: #fff;
            --moment-card-border-light: #eee;
            --moment-image-preview-bg: #f9f9f9;
            --moment-name-color: #333;
            --moment-content-color: #444;
            --moment-comments-border: #f0f0f0;
            --moment-comments-title-color: #666;
            --comment-bg-light: #f5f5f5;
            --comment-text-color: #333;
            --comment-timestamp-color: #999;

            --regenerate-modal-title-color: #444;
            --regenerate-modal-body-color: #555;
            --regenerate-modal-body-small-color: #888;

            /* 通用阴影和边框颜色，保持中性 */
            --border-color-light: rgba(0, 0, 0, 0.1);
            --shadow-color-light: rgba(0, 0, 0, 0.1);
            --shadow-color-medium: rgba(0, 0, 0, 0.15);
            --shadow-color-dark: rgba(0, 0, 0, 0.2);

            /* 动态背景和渐变，使用主题色变量 */
            --body-bg-gradient: linear-gradient(135deg, var(--theme-color-1), var(--theme-color-2), var(--theme-color-3), var(--theme-color-4));
            --header-bg-gradient: linear-gradient(to right, var(--theme-color-1), var(--theme-color-4));
            --message-received-bubble-border-dynamic: var(--theme-color-1);
            --message-sent-bubble-bg-gradient: linear-gradient(to right, var(--theme-color-2), var(--theme-color-4));
            --message-input-border-dynamic: var(--theme-color-1);
            --message-input-bg-alpha: rgba(var(--theme-color-rgb-1), 0.1);
            --message-input-focus-border-dynamic: var(--theme-color-4);
            --message-input-focus-shadow-color: rgba(var(--theme-color-rgb-4), 0.3);
            --send-btn-bg-gradient: linear-gradient(to right, var(--theme-color-1), var(--theme-color-4));
            --modal-header-bg-gradient: linear-gradient(to right, var(--theme-color-1), var(--theme-color-4));
            --form-control-border-dynamic: var(--theme-color-1);
            --form-control-bg-alpha: rgba(var(--theme-color-rgb-1), 0.1);
            --form-control-focus-border-dynamic: var(--theme-color-4);
            --form-control-focus-shadow-color: rgba(var(--theme-color-rgb-4), 0.3);
            --avatar-preview-border-dynamic: white;
            --upload-btn-bg-gradient: linear-gradient(to right, var(--theme-color-1), var(--theme-color-4));
            --btn-primary-bg-gradient: linear-gradient(to right, var(--theme-color-1), var(--theme-color-4));
            --btn-secondary-border-dynamic: var(--theme-color-1);
            --toggle-switch-checked-bg-dynamic: var(--theme-color-4);
            --toggle-switch-checked-border-dynamic: var(--theme-color-4);
            --toggle-switch-inner-checked-bg-dynamic: var(--theme-color-4);
            --essay-notification-bg-gradient: linear-gradient(to right, var(--theme-color-4), var(--theme-color-1));
            --manage-modal-btn-bg-alpha: rgba(var(--theme-color-rgb-1), 0.5);
            --manage-modal-btn-hover-bg-alpha: rgba(var(--theme-color-rgb-1), 0.8);
            --persona-card-avatar-border-dynamic: var(--theme-color-4);
            --regenerate-modal-header-bg-gradient: linear-gradient(to right, var(--theme-color-3), var(--theme-color-1));
        
            /* 新增：聊天背景设置变量 */
            --chat-background-image: none; /* 默认：无背景图 */
            --chat-background-size: cover;
            --chat-background-position: center;
            --chat-background-repeat: no-repeat;
            --chat-background-attachment: fixed; /* 核心修改：背景图固定，不随内容滚动 */
            --chat-background-overlay-color: rgba(255, 255, 255, 0.85); /* 聊天区域背景叠加色，保持半透明效果 */

            /* 新增：输入栏上移高度变量 */
            --input-area-shift-height: 0px; /* 默认不偏移 */
        }

/*        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "SimSun", "宋体", serif;
        } */
        

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* font-family 由 body 控制，以便JS动态切换 */
        }
        
        body {
            background: var(--body-bg-gradient);
            height: 100vh;
            overflow: hidden;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-color-dark);
        }
        
        .container {
            width: 100%;
            max-width: 500px;
            height: 90vh;
            /* 将原有的半透明背景改为纯白，以便聊天区域的背景图能更好地显示 */
            background: white; 
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        
        /* 顶部标题栏 */
        .header {
            background: var(--header-bg-gradient);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color-light);
            z-index: 10;
        }
        
        .header h1 {
            font-size: 1.4rem;
            color: var(--text-color-dark);
            text-shadow: 1px 1px 2px var(--header-text-shadow-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        
        /* 新增：状态点样式 */
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            border: 1px solid var(--border-color-light);
            box-shadow: 0 1px 3px var(--shadow-color-light);
        }

        .status-dot.online {
            background-color: var(--status-dot-online);
        }

        .status-dot.busy {
            background-color: var(--status-dot-busy);
        }

        .status-dot.offline {
            background-color: var(--status-dot-offline);
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            background: var(--btn-bg);
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px var(--shadow-color-light);
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px var(--shadow-color-medium);
            background: var(--btn-hover-bg);
        }
        
        .btn i {
            font-size: 1rem;
            color: var(--btn-icon-color);
        }
        
        /* 聊天区域 */
        .chat-area {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
            /* 应用背景图片和叠加色 */
            background-image: var(--chat-background-image);
            background-size: var(--chat-background-size);
            background-position: var(--chat-background-position);
            background-repeat: var(--chat-background-repeat);
            background-attachment: var(--chat-background-attachment);
            background-color: var(--chat-background-overlay-color); /* 叠加在图片上，提供半透明效果 */
        }
        
        /* 消息样式 */
        .message {
            display: flex;
            max-width: 80%;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .message.received {
            align-self: flex-start;
        }
        
        .message.sent {
            align-self: flex-end;
        }
        
        .avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--text-color-white);
            box-shadow: 0 2px 5px var(--shadow-color-light);
            flex-shrink: 0;
        }
        
        .message.received .avatar {
            margin-right: 10px;
        }
        
        .message.sent .avatar {
            margin-left: 10px;
            order: 2;
        }
        
        .message-content {
            display: flex;
            flex-direction: column;
        }
        
        .message.received .message-content {
            align-items: flex-start;
        }
        
        .message.sent .message-content {
            align-items: flex-end;
        }
        
        .name {
            font-size: 0.8rem;
            color: var(--text-color-light);
            margin-bottom: 5px;
        }
        
        .bubble {
            padding: 12px 16px;
            border-radius: 18px;
            position: relative;
            word-break: break-word;
            line-height: 1.4;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            font-size: 0.9rem; /* 新增：缩小字号 */
            overflow: hidden; /* 新增：确保伪元素等内容被裁剪在圆角内 */
        }
        
        .message.received .bubble {
            background: var(--message-received-bubble-bg);
            border: 1px solid var(--message-received-bubble-border-dynamic);
            border-top-left-radius: 5px;
        }
        
        .message.sent .bubble {
            background: var(--message-sent-bubble-bg-gradient);
            color: var(--message-sent-bubble-text-color);
            border-top-right-radius: 5px;
        }
        
        /* 新增：撤回消息气泡样式 */
        .message.received .bubble.retracted-bubble {
            background: var(--retracted-bubble-bg);
            border: 1px dashed var(--retracted-bubble-border);
            color: var(--text-color-medium);
        }

        /* 新增：自动回复消息气泡样式 */
        .message.received .bubble.auto-reply-bubble {
            background: var(--auto-reply-bubble-bg);
            border: 1px dashed var(--auto-reply-bubble-border);
            color: var(--text-color-dark);
        }

        /* 新增：表情包气泡样式 */
        .bubble.emoji-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            display: flex;
            justify-content: center;
            align-items: center;
            max-width: 135px;
            height: auto;
        }

        .bubble.emoji-bubble img {
            max-width: 120px;
            max-height: 120px;
            object-fit: contain; 
            border-radius: 10px;
            box-shadow: 0 2px 5px var(--shadow-color-light);
        }

        .timestamp {
            font-size: 0.7rem;
            color: var(--text-color-lighter);
            margin-top: 5px;
            text-align: right;
            display: flex;
            align-items: center;
            gap: 5px;
            justify-content: flex-end;
        }

        /* 自动回复标签 */
        .auto-reply-label {
            font-size: 0.65rem;
            color: var(--text-color-light);
            background: var(--auto-reply-label-bg);
            padding: 2px 6px;
            border-radius: 8px;
            white-space: nowrap;
        }

        /* 自动回复消息的时间戳样式 */
        .message.received .message-content .timestamp {
            justify-content: flex-start;
            margin-left: 0;
            margin-top: 5px;
            margin-bottom: 0;
        }
        
        /* 输入区域 */
        .input-area {
            background: var(--input-area-bg);
            padding: 10px 20px; /* 调整整体内边距，减少垂直空间 */
            border-top: 1px solid var(--border-color-light);
            display: flex;
            flex-direction: column; /* 垂直排列子元素 */
            gap: 10px; /* 行之间的间距 */
            z-index: 10;
            margin-bottom: var(--input-area-shift-height);
            transition: margin-bottom 0.3s ease;
            position: relative; /* 为内部的 emoji-card 提供定位上下文 */
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05); /* 底部阴影，使其浮起 */
        }
        
        .message-input {
            flex: 1; /* 占据父容器的剩余空间 */
            padding: 12px 15px;
            border: 1px solid var(--message-input-border-dynamic);
            border-radius: 25px;
            outline: none;
            font-size: 1rem;
            transition: height 0.3s ease-out;
            background: var(--message-input-bg-alpha);
            height: 50px;
            min-height: 50px;
            max-height: 150px;
            resize: none;
            overflow-y: hidden;
            line-height: 1.4;
            padding-top: 15px;
            padding-bottom: 15px;
        }
        
        .message-input:focus {
            border-color: var(--message-input-focus-border-dynamic);
            box-shadow: 0 0 0 2px var(--message-input-focus-shadow-color);
            outline: none;
        }

        .message-input.expanded {
            height: 150px;
            overflow-y: auto;
        }
        
        .send-btn {
            background: var(--send-btn-bg-gradient);
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px var(--shadow-color-medium);
            flex-shrink: 0;
        }
        
        .send-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 12px var(--shadow-color-dark);
        }
        
        .send-btn i {
            font-size: 1.2rem;
            color: var(--btn-primary-color); /* 使用主按钮颜色变量 */
        }

        #manual-reply-btn {
            background: linear-gradient(to right, #87CEEB, #9370DB); /* 蝴蝶主题色 */
        }

        /* 展开/收起按钮样式 */
        .toggle-input-btn {
            background: var(--toggle-input-btn-bg);
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px; 
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px var(--shadow-color-medium);
            flex-shrink: 0;
        }

        .toggle-input-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 12px var(--shadow-color-dark);
            background: var(--toggle-input-btn-hover-bg);
        }

        .toggle-input-btn .arrow-icon {
            font-size: 0.9rem;
            color: var(--toggle-input-btn-icon-color);
            line-height: 1;
        }
        
        /* 自定义弹窗 */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        .modal.active {
            opacity: 1;
            visibility: visible;
        }
        
        .modal-content {
            background: var(--text-color-white);
            border-radius: 20px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .modal-header {
            background: var(--modal-header-bg-gradient);
            padding: 20px;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-title {
            font-size: 1.4rem;
            color: var(--modal-title-color);
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--close-btn-color);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .close-btn:hover {
            transform: rotate(90deg);
            color: var(--text-color-dark);
        }
        
        .modal-body {
            padding: 25px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--form-label-color);
        }

        /* 新增：自定义提示词弹窗内，提示词标题和开关的水平布局 */
        .prompt-header-row {
            display: flex; /* 启用 Flexbox 布局 */
            justify-content: space-between; /* 让子元素（label和开关）两端对齐 */
            align-items: center; /* 垂直居中对齐 */
            margin-bottom: 10px; /* 在标题行和下方的文本框之间添加间距 */
        }

        .prompt-header-row label {
            margin-bottom: 0; /* 移除标签自身的底部外边距，避免与 Flexbox 冲突 */
            flex-grow: 1; /* 允许标签占据更多可用空间 */
        }
        
        .prompt-header-row .toggle-switch-container {
            margin-top: 0; /* 移除之前为了浮动而设置的顶部外边距，让其垂直居中 */
            flex-shrink: 0; /* 防止开关被压缩 */
        }
        
        .form-control {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid var(--form-control-border-dynamic);
            border-radius: 12px;
            font-size: 1rem;
            background: var(--form-control-bg-alpha);
            transition: all 0.3s ease;
        }
        
        .form-control:focus {
            border-color: var(--form-control-focus-border-dynamic);
            box-shadow: 0 0 0 2px var(--form-control-focus-shadow-color);
            outline: none;
        }
        
        .avatar-upload {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .avatar-preview {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid var(--avatar-preview-border-dynamic);
            box-shadow: 0 5px 15px var(--shadow-color-light);
            margin-bottom: 15px;
            background: #f0f0f0;
        }
        
        .upload-btn {
            background: var(--upload-btn-bg-gradient);
            color: var(--upload-btn-color);
            border: none;
            border-radius: 25px;
            padding: 10px 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px var(--shadow-color-medium);
        }
        
        .upload-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 12px var(--shadow-color-dark);
        }
        
        .modal-footer {
            padding: 20px;
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            border-top: 1px solid var(--border-color-light);
        }
        
        .btn-primary {
            background: var(--btn-primary-bg-gradient);
            color: var(--btn-primary-color);
            border: none;
            border-radius: 25px;
            padding: 12px 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px var(--shadow-color-medium);
        }
        
        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 12px var(--shadow-color-dark);
        }
        
        .btn-secondary {
            background: var(--text-color-white);
            color: var(--text-color-medium);
            border: 1px solid var(--btn-secondary-border-dynamic);
            border-radius: 25px;
            padding: 12px 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn-secondary:hover {
            background: #f9f9f9;
            transform: translateY(-3px);
            box-shadow: 0 3px 8px var(--shadow-color-light);
        }
        
        /* 新增：好友设置弹窗页脚的特殊布局 */
#friend-config-modal .modal-footer {
    flex-direction: column;
    gap: 10px; /* 两行按钮之间的间距 */
    align-items: flex-end; /* 使两行都靠右对齐 */
}

#friend-config-modal .modal-footer-row {
    display: flex;
    gap: 15px; /* 同一行按钮之间的间距 */
    width: 100%;
    justify-content: flex-end; /* 按钮在行内靠右 */
}

/* 确保按钮宽度自适应内容并平分空间 */
#friend-config-modal .modal-footer-row .btn-secondary,
#friend-config-modal .modal-footer-row .btn-primary {
    flex-grow: 1; 
    max-width: 50%; 
}

        /* 特效 */
        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0);
            pointer-events: none;
            animation: rippleEffect 0.8s linear;
        }
        
        @keyframes rippleEffect {
            to {
                transform: scale(2.5);
                opacity: 0;
            }
        }
        
        .star {
            position: absolute;
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            animation: starEffect 1.2s ease-out;
            opacity: 0.7;
        }
        
        @keyframes starEffect {
            0% {
                transform: translate(0, 0) scale(0);
                opacity: 0.7;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(1);
                opacity: 0;
            }
        }
        
        /* 加载指示器 */
        .typing-indicator {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background: var(--text-color-white);
            border: 1px solid var(--message-received-bubble-border-dynamic);
            border-radius: 18px;
            max-width: 100px;
            margin-top: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        .typing-indicator span {
            width: 8px;
            height: 8px;
            background: var(--theme-color-4);
            border-radius: 50%;
            display: inline-block;
            margin: 0 2px;
            animation: typing 1.4s infinite;
        }
        
        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-5px);
            }
        }

        /* 心声文本样式 */
        .inner-voice-text {
            font-family: var(--inner-voice-font-family);
            font-size: 1.2rem;
            color: var(--inner-voice-color);
            text-align: center;
            padding: 10px;
            line-height: 1.6;
            background: var(--inner-voice-bg);
            border-radius: 15px;
            box-shadow: inset 0 0 8px rgba(var(--inner-voice-shadow-rgb), 0.2);
        }

        /* 随笔文本样式，现在使用CSS变量来控制字体 */
        .essay-text {
            font-family: var(--essay-font-family);
            font-size: 1.1rem;
            color: var(--essay-text-color);
            text-align: left;
            padding: 15px;
            line-height: 1.6;
            background: var(--essay-bg);
            border: 1px solid var(--essay-border);
            border-radius: 8px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
            position: relative;
            margin-top: 20px;
            white-space: pre-wrap;
        }

        /* 随笔的“图钉”效果 */
        .essay-text::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 15px;
            width: 20px;
            height: 20px;
            background: var(--essay-pin-color);
            border-radius: 50%;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.3);
            transform: rotate(45deg);
        }

        /* 新增：气泡和撤回标记的容器 */
        .bubble-and-tag-wrapper {
            display: flex;
            align-items: flex-end;
            gap: 5px;
            max-width: 100%;
        }

        /* 新增：撤回标记样式 */
        .retracted-tag {
            font-size: 0.75rem;
            color: var(--text-color-lighter);
            white-space: nowrap;
            flex-shrink: 0;
            margin-bottom: 2px;
        }

        /* Toggle Switch Styles */
        .toggle-switch-container {
            position: relative;
            width: 60px;
            height: 34px;
            margin-top: 10px;
        }

        .toggle-switch-checkbox {
            display: none;
        }

        .toggle-switch-label {
            display: block;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid var(--toggle-switch-border);
            border-radius: 34px;
            background-color: var(--toggle-switch-off-bg);
            transition: background-color 0.3s ease;
        }

        .toggle-switch-checkbox:checked + .toggle-switch-label {
            background-color: var(--toggle-switch-checked-bg-dynamic);
            border-color: var(--toggle-switch-checked-border-dynamic);
        }

        .toggle-switch-inner {
            display: block;
            width: 200%;
            margin-left: -100%;
            transition: margin-left 0.3s ease;
        }

        .toggle-switch-inner:before, .toggle-switch-inner:after {
            float: left;
            width: 50%;
            height: 30px;
            padding: 0;
            line-height: 30px;
            font-size: 14px;
            color: var(--text-color-white);
            font-weight: bold;
            box-sizing: border-box;
        }

        .toggle-switch-inner:before {
            content: "开";
            padding-left: 10px;
            background-color: var(--toggle-switch-inner-checked-bg-dynamic);
            color: var(--text-color-white);
        }

        .toggle-switch-inner:after {
            content: "关";
            padding-right: 10px;
            background-color: var(--toggle-switch-off-bg);
            color: var(--text-color-lighter);
            text-align: right;
        }

        .toggle-switch-switch {
            display: block;
            width: 26px;
            height: 26px;
            margin: 2px;
            background: var(--toggle-switch-handle-bg);
            position: absolute;
            top: 0;
            bottom: 0;
            right: 28px;
            border: 2px solid var(--toggle-switch-border);
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch-checkbox:checked + .toggle-switch-label .toggle-switch-inner {
            margin-left: 0;
        }

        .toggle-switch-checkbox:checked + .toggle-switch-label .toggle-switch-switch {
            right: 0px;
            background: var(--toggle-switch-handle-bg);
            border-color: var(--toggle-switch-checked-border-dynamic);
        }

        /* New style for poke messages (event notifications) */
        .message.event-message {
            align-self: center;
            max-width: 70%;
            background: var(--event-message-bg);
            color: var(--event-message-color);
            border-radius: 10px;
            padding: 8px 15px;
            text-align: center;
            font-size: 0.9rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            margin-top: 10px;
            margin-bottom: 10px;
            animation: fadeIn 0.3s ease;
        }

        .message.event-message .message-content {
            display: block;
            width: 100%;
        }

        .message.event-message .bubble {
            background: none;
            border: none;
            padding: 0;
            box-shadow: none;
            color: inherit;
        }

        .message.event-message .name,
        .message.event-message .avatar,
        .message.event-message .timestamp,
        .message.event-message .retracted-tag,
        .message.event-message .auto-reply-label {
            display: none;
        }
        
        /* 新增：随笔通知浮窗样式 */
        .essay-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            background: var(--essay-notification-bg-gradient);
            color: var(--text-color-white);
            padding: 12px 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 1100;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease-out;
            min-width: 250px;
            text-align: center;
            font-size: 0.95rem;
        }

        .essay-notification.show {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        /* 新增：管理侧边弹窗样式 */
        .manage-modal {
            position: fixed;
            top: 0;
            right: 0;
            width: 100%;
            max-width: 320px;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.2);
            z-index: 1050;
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .manage-modal.active {
            transform: translateX(0);
        }

        .manage-modal .modal-header {
            border-radius: 0;
            padding: 15px 20px;
        }

        .manage-modal .modal-body {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .manage-modal .modal-body .btn {
            width: 100%;
            height: 50px;
            border-radius: 10px;
            font-size: 1.1rem;
            color: var(--text-color-dark);
            background: var(--manage-modal-btn-bg-alpha);
            box-shadow: 0 2px 5px var(--shadow-color-light);
            display: flex;
            justify-content: flex-start;
            padding-left: 20px;
            gap: 15px;
            font-family: inherit; /* 新增：强制继承全局字体 */
        }

        .manage-modal .modal-body .btn i {
            font-size: 1.2rem;
            color: var(--text-color-medium);
        }

        .manage-modal .modal-body .btn span {
            flex-grow: 1;
            text-align: left;
        }

        .manage-modal .modal-body .btn:hover {
            background: var(--manage-modal-btn-hover-bg-alpha);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color-medium);
        }

/* 新增：人设选择弹窗，使其内容区域支持绝对定位 */
#persona-selection-modal .modal-content {
    position: relative;
}

/* 新增：调整导入角色按钮样式并移动到右上角 */
#import-persona-btn {
    position: absolute;
    top: 20px;
    right: 55px; /* 留出关闭按钮的位置 */
    z-index: 5; /* 确保在标题之上 */
    width: auto; /* 覆盖之前的 width: 80% */
    padding: 6px 12px;
    font-size: 0.85rem;
    border: 1px dashed var(--btn-secondary-border-dynamic);
    background: transparent;
    color: var(--text-color-medium);
    box-shadow: none;
    transition: all 0.2s ease;
    border-radius: 8px; /* 调整圆角 */
}

#import-persona-btn:hover {
    background: var(--form-control-bg-alpha);
    color: var(--text-color-dark);
    border-color: var(--theme-color-4);
    transform: none; /* 移除继承的 transform 效果 */
}

#import-persona-btn i {
    margin-right: 5px;
}

        /* 新增：人设选择弹窗内的卡片样式 */
        .persona-selection-card { /* 新增类名，专用于人设选择卡片 */
            background: var(--persona-card-bg-light);
            border: 1px solid var(--persona-card-border-light);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px; /* 保持卡片间距 */
            display: flex;
            flex-direction: column; /* 垂直堆叠内容 */
            align-items: center; /* 水平居中内容 */
            text-align: center; /* 文本居中 */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .persona-selection-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.12);
        }

        .persona-selection-card .avatar-preview {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--persona-card-avatar-border-dynamic);
            box-shadow: 0 1px 3px var(--shadow-color-light);
            margin-bottom: 10px; /* 头像下方留出间距 */
        }

        .persona-selection-card .persona-name-display { /* 新增类名，专用于人设名字 */
            font-size: 1.2rem;
            color: var(--text-color-dark);
            margin-bottom: 5px; /* 名字下方留出间距 */
            font-weight: bold; /* 名字加粗 */
        }

        .persona-selection-card p {
            font-size: 0.9rem;
            color: var(--text-color-light);
            margin-bottom: 15px;
            line-height: 1.4;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        .persona-selection-card-actions { /* 新增类名，专用于人设卡片动作按钮容器 */
            display: flex;
            gap: 10px;
            width: 100%;
            justify-content: center;
        }

        .persona-selection-card-actions .btn-secondary,
        .persona-selection-card-actions .btn-primary {
            padding: 8px 15px;
            font-size: 0.9rem;
            border-radius: 20px;
            flex: 1;
        }

        /* 调整详情弹窗的样式，使其更紧凑 */
        #persona-detail-modal .modal-body {
            padding: 20px;
        }

        #persona-detail-modal .form-group {
            margin-bottom: 10px;
        }

        #persona-detail-modal .form-group label {
            font-size: 0.9rem;
            margin-bottom: 3px;
            color: #777;
        }

        #persona-detail-modal .form-group p {
            font-size: 1rem;
            color: var(--text-color-dark);
            background: var(--moment-input-bg-light);
            padding: 8px 12px;
            border-radius: 8px;
            word-break: break-word;
        }

        #persona-detail-modal .avatar-preview {
            width: 100px;
            height: 100px;
            margin-bottom: 15px;
        }

        /* 新版：朋友圈视图样式 */
        .modal.moments-view {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            border-radius: 0;
            display: flex;
            flex-direction: column;
            background-color: #f0f2f5; /* 类似微信的背景色 */
            justify-content: flex-start; /* 覆盖 modal 的居中对齐 */
            align-items: stretch; /* 覆盖 modal 的居中对齐 */
        }

        .moments-view .moments-header {
            background: var(--header-bg-gradient);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color-light);
            flex-shrink: 0;
            z-index: 10;
        }

        .moments-header .back-btn, .moments-header .action-btn {
            background: none;
            border: none;
            color: var(--text-color-dark);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 5px;
            width: 40px;
            height: 40px;
        }
        
        .moments-header .header-actions {
            display: flex;
            gap: 10px;
        }

        .moments-header .moments-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--text-color-dark);
        }

        .moments-view .moments-body {
            flex-grow: 1;
            overflow-y: auto;
            background-color: var(--moment-card-bg-light);
        }

        .moments-header-cover {
            position: relative;
            width: 100%;
            height: 250px;
            background-color: #ddd;
            margin-bottom: 20px;
        }

        .moments-header-cover .cover-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .moments-header-cover .cover-upload-trigger {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            cursor: pointer;
        }

        .moments-header-cover .cover-user-info {
            position: absolute;
            bottom: -15px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .cover-user-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--text-color-white);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }
        .cover-user-avatar {
            width: 70px;
            height: 70px;
            border-radius: 8px;
            border: 3px solid var(--text-color-white);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            object-fit: cover;
        }
        
        .moments-feed {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .moment-card {
            display: flex;
            gap: 15px;
            padding: 15px;
            background-color: transparent; /* 卡片本身透明，在feed背景上 */
            border-bottom: 1px solid var(--moment-comments-border);
        }
        
        .moment-card:last-child {
            border-bottom: none;
        }

        .moment-card-avatar {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            object-fit: cover;
            flex-shrink: 0;
        }
        
        .moment-card-main {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .moment-card-name {
            font-weight: bold;
            color: var(--moment-name-color);
            font-size: 1.1rem;
        }

        .moment-card-content {
            font-size: 1rem;
            color: var(--moment-content-color);
            line-height: 1.5;
            white-space: pre-wrap;
        }
        
        .moment-card-photo {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            object-fit: cover;
            cursor: pointer;
        }
        
        .moment-card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 5px;
        }

        .moment-card-timestamp {
            font-size: 0.8rem;
            color: var(--comment-timestamp-color);
        }
        
        .moment-card-actions .comment-btn {
            background-color: var(--comment-bg-light);
            border: none;
            border-radius: 5px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 1.2rem;
            color: var(--text-color-medium);
        }
        
        .moment-card-comments {
            margin-top: 10px;
            padding: 10px;
            background-color: var(--comment-bg-light);
            border-radius: 8px;
            font-size: 0.95rem;
        }
        
        .comment-item {
            padding: 4px 0;
            line-height: 1.4;
            color: var(--comment-text-color);
            cursor: pointer;
            display: flex;
            flex-direction: column; /* Changed to a column layout */
            align-items: flex-start; /* Default alignment for items is to the start (left) */
        }

        .comment-item > div {
            width: 100%; /* Make the content wrapper take the full width */
            word-break: break-word;
        }

        .comment-item .comment-timestamp {
            align-self: flex-end; /* Align the timestamp itself to the end (right) */
            font-size: 0.8rem; /* Make the font smaller */
            color: var(--comment-timestamp-color); /* Use the standard lighter color */
            margin-top: 2px; /* Add a little space above it */
            white-space: nowrap;
        }

        .comment-item .commenter-name {
            font-weight: bold;
            color: var(--moment-name-color);
        }

        .comment-item .reply-to-name {
            color: var(--theme-color-4);
        }

        .generating-comments-indicator {
            padding: 8px 10px;
            font-size: 0.9rem;
            color: var(--text-color-lighter);
            font-style: italic;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .moment-image-preview-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            padding: 10px;
            background-color: var(--moment-input-bg-light);
            border-radius: 8px;
            position: relative;
        }

        .moment-image-preview {
            max-width: 200px; /* 限制预览图最大宽度 */
            max-height: 200px; /* 限制预览图最大高度 */
            border-radius: 5px;
            object-fit: contain; /* 保持图片比例 */
        }
        
        .remove-image-btn {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: rgba(0,0,0,0.6);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            line-height: 24px;
            text-align: center;
            cursor: pointer;
            z-index: 1;
        }

        /* 新增：重新生成弹窗样式 */
        .regenerate-modal-content {
            background: var(--text-color-white);
            border-radius: 15px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .regenerate-modal-content .modal-header {
            background: var(--regenerate-modal-header-bg-gradient);
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
            padding: 15px 20px;
        }

        .regenerate-modal-content .modal-title {
            font-size: 1.2rem;
            color: var(--regenerate-modal-title-color);
        }

        .regenerate-modal-content .modal-body {
            padding: 20px;
            text-align: center;
            font-size: 1rem;
            color: var(--regenerate-modal-body-color);
        }

        .regenerate-modal-content .modal-body p small {
            color: var(--regenerate-modal-body-small-color);
        }

        .regenerate-modal-content .modal-footer {
            padding: 15px 20px;
            justify-content: center;
            gap: 15px;
        }

        /* 主题选择器中的颜色预览 */
        .theme-options-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }

        .theme-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 10px;
            border-radius: 10px;
            border: 2px solid transparent; /* 默认透明边框 */
            transition: border-color 0.3s ease;
        }

        .theme-option.selected {
            border-color: var(--theme-color-4); /* 选中时使用主题色4作为边框 */
        }

        .theme-option .color-swatch {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin-bottom: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .theme-option span {
            font-size: 0.9rem;
            color: var(--text-color-dark);
        }
        
        /* 新增：星空紫罗兰主题下玩家气泡的边框 */
        body.theme-starry-violet .message.sent .bubble {
            border: 1px solid rgba(var(--theme-color-rgb-4), 0.6);
        }

        /* 新增：自定义主题下玩家气泡的边框、阴影和高光效果 */
        body.theme-custom .message.sent .bubble {
            border: 1px solid rgba(var(--theme-color-rgb-4), 0.4); /* 边框颜色稍浅 */
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.12); /* 增加一点阴影以提升立体感 */
        }

        /* 为自定义主题的发送气泡添加光泽高光，使其更像泡泡 */
        body.theme-custom .message.sent .bubble::before {
            content: '';
            position: absolute;
            top: 1px; /* 距离顶部1px，避免覆盖边框 */
            left: 5%;
            width: 90%;
            height: 50%;
            /* 使用径向渐变模拟顶部高光 */
            background: radial-gradient(ellipse at top, 
                rgba(255, 255, 255, 0.6) 0%, 
                rgba(255, 255, 255, 0) 75%
            );
            opacity: 0.8;
            border-radius: 50% / 100%; /* 创建一个扁平的椭圆形状 */
            transform: scaleX(1.2); /* 将椭圆稍微拉宽一点 */
        }

        /* 新增：背景设置区域样式 */
        .background-options-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }

        .background-upload-section, .default-background-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 15px;
            border: 1px dashed var(--border-color-light);
            border-radius: 10px;
            background: var(--moment-input-bg-light); /* 复用一个浅色背景变量 */
        }

        .background-preview {
            width: 150px;
            height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-color-light);
            box-shadow: 0 2px 5px var(--shadow-color-light);
        }

        .background-upload-section .upload-btn,
        .background-upload-section .btn-secondary {
            width: auto;
            padding: 8px 18px;
            font-size: 0.9rem;
        }

        .background-upload-section .upload-btn {
            background: var(--moment-input-bg-light);
            color: var(--text-color-medium);
            border: 1px solid var(--moment-input-border-light);
            box-shadow: none;
        }
        .background-upload-section .upload-btn:hover {
            background: #e0e0e0;
            transform: none;
            box-shadow: none;
        }

        .default-background-section select {
            width: 100%;
        }

        /* 新增：本地记录弹窗内的卡片样式 */
        .local-records-list-container {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Spacing between cards */
        }

        .save-slot-card {
            background: var(--persona-card-bg-light); /* Reusing persona card background */
            border: 1px solid var(--persona-card-border-light);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .save-slot-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.12);
        }

        .save-slot-card h4 {
            font-size: 1.1rem;
            color: var(--text-color-dark);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .save-slot-card .avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--persona-card-avatar-border-dynamic);
            box-shadow: 0 1px 3px var(--shadow-color-light);
            flex-shrink: 0;
        }

        .save-slot-card .slot-info {
            flex-grow: 1;
        }

        .save-slot-card .slot-name {
            font-weight: bold;
            color: var(--text-color-dark);
        }

        .save-slot-card .slot-time {
            font-size: 0.8rem;
            color: var(--text-color-lighter);
            margin-top: 5px;
        }

        .save-slot-card .latest-messages {
            font-size: 0.9rem;
            color: var(--text-color-medium);
            background: var(--moment-input-bg-light);
            padding: 8px 12px;
            border-radius: 8px;
            max-height: 80px; /* Limit height for preview */
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 4; /* Show max 4 lines */
            -webkit-box-orient: vertical;
            white-space: pre-wrap; /* Preserve whitespace for messages */
        }

        .save-slot-card .slot-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: flex-end; /* Align buttons to the right */
        }

        .save-slot-card .slot-actions .btn-primary,
        .save-slot-card .slot-actions .btn-secondary {
            padding: 8px 15px;
            font-size: 0.9rem;
            border-radius: 20px;
            flex: 1; /* Distribute space evenly */
        }

        .save-slot-card.empty-slot {
            text-align: center;
            padding: 30px;
            color: var(--text-color-lighter);
            font-style: italic;
            justify-content: center;
            align-items: center;
        }

        .save-slot-card.empty-slot .slot-actions {
            justify-content: center;
        }

        /* 新增：自定义提示词卡片样式 */
        .prompt-list-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 60vh;
            overflow-y: auto;
            padding: 5px;
        }

        .prompt-card {
            background: var(--persona-card-bg-light);
            border: 1px solid var(--persona-card-border-light);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.07);
            display: flex;
            flex-direction: column; /* 改为垂直布局 */
            gap: 15px; /* 设置卡片内主要区域的间距 */
            transition: box-shadow 0.2s ease;
        }

        .prompt-card-top-section { /* 新增：用于包裹上方信息的容器 */
            display: flex;
            align-items: flex-start; /* 顶部对齐 */
            gap: 15px;
            width: 100%;
        }
        
        .prompt-card:hover {
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .prompt-card-number {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--theme-color-4);
            flex-shrink: 0;
            width: 40px;
            text-align: center;
        }

        .prompt-card-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .prompt-card-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--text-color-dark);
        }

        .prompt-card-info {
            font-size: 0.8rem;
            color: var(--text-color-light);
            display: flex;
            gap: 10px;
        }

        .prompt-card-info .status-icon {
            font-weight: bold;
        }
        .prompt-card-info .status-icon.enabled {
            color: var(--status-dot-online);
        }
        .prompt-card-info .status-icon.disabled {
            color: var(--status-dot-offline);
        }
        .prompt-card-info .type-icon.explicit {
            color: var(--theme-color-2);
        }
        .prompt-card-info .type-icon.implicit {
            color: var(--theme-color-4);
        }


        .prompt-card-actions {
            display: flex; /* 改为水平布局 */
            gap: 10px;
            justify-content: flex-end; /* 按钮靠右对齐 */
            border-top: 1px solid var(--persona-card-border-light); /* 在按钮上方添加分割线 */
            padding-top: 15px; /* 分割线上方留出空间 */
            width: 100%;
        }

        .prompt-card-actions .btn-secondary,
        .prompt-card-actions .btn-primary {
            padding: 5px 12px;
            font-size: 0.85rem;
            border-radius: 15px;
            width: 70px;
            text-align: center;
        }

        .persona-selection-card-actions .delete-btn {
            background-color: #fff0f0;
            border-color: #ffb3b3;
            color: #ff4d4d;
            flex: 0.5; /* 让删除按钮窄一点 */
        }
        .persona-selection-card-actions .delete-btn:hover {
            background-color: #ffe0e0;
            color: #d90000;
        }


        #add-new-prompt-btn {
            width: 100%;
            margin-top: 15px;
            border-top: 1px solid var(--border-color-light);
            padding-top: 15px;
        }
        /* 新增：提升次级和确认弹窗的 z-index，解决遮挡问题 */
        /* 次级弹窗（如编辑/查看），z-index 高于主列表弹窗(1000) */
        #edit-prompt-modal,
        #view-prompt-modal {
            z-index: 1010;
        }

        /* 确认弹窗，z-index 最高，确保在所有弹窗之上（包括侧边栏的1050） */
        #custom-confirm-modal {
            z-index: 1060; /* 提升z-index，确保高于侧边栏(1050) */
        }
        

/* 新增：输入区域的上下两行布局 */
.input-top-row,
.input-feature-row {
    display: flex;
    align-items: flex-end; /* 底部对齐 */
    gap: 8px; /* 元素之间的间距 */
    width: 100%; /* 占据父容器的全部宽度 */
}

.input-feature-row {
    justify-content: flex-start; /* 功能按钮居左对齐 */
}

/* 重新统一所有小按钮的样式 (表情、语音、图片、红包) */
.emoji-btn,
.voice-btn,
.image-btn,
.red-packet-btn {
    width: 38px; /* 稍微缩小功能按钮尺寸 */
    height: 38px;
    min-width: 38px;
    min-height: 38px;
    padding: 0;
    font-size: 1.1rem;
    border-radius: 50%;
    background-color: var(--btn-bg);
    color: var(--btn-icon-color);
    border: none;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    transition: background-color 0.2s ease, transform 0.1s ease;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-shrink: 0; /* 防止被压缩 */
}

.emoji-btn:hover,
.voice-btn:hover,
.image-btn:hover {
    background-color: var(--btn-hover-bg);
    transform: translateY(-1px);
}

.emoji-btn:active,
.voice-btn:active,
.image-btn:active {
    transform: translateY(0);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* 确保聊天区域在输入区域上方有足够空间 */
/* 这个规则可能已经存在，确保它在修改后依然有效，并调整其值以适应新的两行输入区域高度 */
.chat-area {
    padding-bottom: 120px; /* 留出两行输入区域的高度，约 50px + 40px + 10px间距 + 上下padding */
}

/* 确保 .container 的 padding-bottom，如果 input-area 是 fixed */
.container {
    padding-bottom: 0; /* input-area 已经有 padding */
}

        /* 适配小屏幕 */
        @media (max-width: 500px) {
            .container {
                height: 100vh;
                border-radius: 0;
            }
            
            .header h1 {
                font-size: 1.2rem;
            }
            
            .bubble {
                padding: 10px 14px;
                font-size: 0.85rem;
            }
            
            .message-input {
                padding: 10px 15px;
            }
            
            .send-btn {
                width: 45px;
                height: 45px;
            }

            .toggle-input-btn {
                width: 45px;
                height: 45px;
            }

            .essay-notification {
                width: 90%;
                left: 5%;
                transform: translateX(0) translateY(-100%);
            }
            .essay-notification.show {
                transform: translateX(0) translateY(0);
            }

            .manage-modal {
                width: 100%;
                max-width: none;
            }

            /* 手机端输入栏上移高度调整 */
            .container.input-area-shifted-up {
                --input-area-shift-height: 60px; /* 手机导航栏通常较高 */
            }
        }

        /* 桌面端输入栏上移高度调整 */
        .container.input-area-shifted-up {
            --input-area-shift-height: 50px; /* 默认上移高度 */
        }
        
        
        /* Card Message Specific Styles */
        .message .card-bubble {
            background-color: var(--message-received-bubble-bg); /* 卡片背景色，通常与接收消息气泡背景一致 */
            border-radius: 12px; /* 圆角 */
            padding: 0; /* 移除默认气泡内边距，由卡片内部元素控制 */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* 确保内容在圆角内被裁剪 */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); /* 轻微阴影 */
            max-width: 280px; /* 卡片最大宽度 */
            min-width: 200px; /* 卡片最小宽度 */
            cursor: pointer; /* 鼠标悬停时显示手型 */
            transition: transform 0.2s ease-in-out; /* 悬停动画 */
        }

        .message .card-bubble:hover {
            transform: translateY(-2px); /* 悬停时轻微上浮 */
        }

        .card-message-inner {
            display: flex; /* 内部使用flex布局 */
            width: 100%;
            height: 100%; /* 填充整个气泡区域 */
            min-height: 80px; /* 卡片最小高度 */
        }
        
        .card-left-image {
            width: 20%; /* 占据卡片宽度的1/4 */
            min-width: 60px; /* 左侧图片区域的最小宽度 */
            border-radius: 12px; /* 四边圆角 */
            background-color: var(--theme-color-1); /* 默认主题色1，用于接收方卡片 */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em; /* 如果没有图片，可以显示一个大图标 */
            color: var(--text-color-white); /* 图标颜色 */
            flex-shrink: 0; /* 防止收缩 */
        }

        .card-content-area {
            flex-grow: 1; /* 占据剩余空间 */
            padding: 10px 12px; /* 内容区域内边距 */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* 垂直方向内容分散对齐 */
            position: relative; /* 用于定位右下角的类型标签 */
        }

        .card-title {
            font-weight: bold;
            font-size: 1em;
            color: var(--text-color-dark); /* 标题颜色 */
            margin-bottom: 4px;
            white-space: nowrap; /* 不换行 */
            overflow: hidden; /* 溢出隐藏 */
            text-overflow: ellipsis; /* 溢出显示省略号 */
        }

        .card-description {
            font-size: 0.85em;
            color: var(--text-color-medium); /* 描述颜色 */
            line-height: 1.3;
            display: -webkit-box; /* 限制行数 */
            -webkit-line-clamp: 2; /* 限制为2行 */
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1; /* 允许描述占据可用空间 */
            margin-bottom: 8px; /* 类型标签上方的间距 */
        }

        .card-type-label {
            position: absolute;
            bottom: 3px;
            right: 3px;
            font-size: 0.7em;
            color: var(--text-color-lighter); /* 类型标签颜色 */
            background-color: rgba(0, 0, 0, 0.05); /* 类型标签背景色 */
            padding: 2px 6px;
            border-radius: 6px;
            white-space: nowrap;
        }

        /* 针对发送方卡片的样式调整 */
        .message.sent .card-bubble {
            /* 发送方卡片背景色保持与接收方一致，因为卡片通常是分享内容，不随气泡颜色变化 */
            background-color: var(--message-received-bubble-bg);
            border: none; /* 卡片不带边框 */
        }
        .message.sent .card-bubble .card-left-image {
            background-color: var(--theme-color-2); /* 发送方卡片左侧图片使用主题色2 */
        }
        .message.sent .card-bubble .card-title,
        .message.sent .card-bubble .card-description,
        .message.sent .card-bubble .card-type-label {
            color: var(--text-color-dark); /* 确保文本在浅色背景上可读 */
        }

        /* 确保不同消息气泡类型的内边距正确 */
        .message .bubble {
            /* 普通文本气泡的默认内边距 */
            padding: 8px 12px;
        }
        .message .emoji-bubble {
            padding: 0; /* 表情包气泡无内边距 */
        }
        .message .retracted-bubble {
            padding: 8px 12px; /* 撤回消息气泡是文本，保留内边距 */
        }

/* 新增：气泡和撤回标记的容器 */
.bubble-and-tag-wrapper {
    display: flex;
    align-items: flex-end; /* 底部对齐 */
    gap: 5px; /* 保持气泡和标签之间的间距 */
    max-width: 100%;
}
.message.received .bubble-and-tag-wrapper {
    justify-content: flex-start; /* 接收方左对齐 */
}
.message.sent .bubble-and-tag-wrapper {
    justify-content: flex-end; /* 发送方右对齐 */
}

        .message.sent .bubble-and-tag-wrapper .bubble {
            background-color: var(--message-sent-bubble-bg-gradient); /* 发送方气泡使用渐变背景 */
            border: var(--message-sent-bubble-border); /* 发送方气泡边框 */
            color: var(--message-sent-bubble-text-color); /* 发送方气泡文本颜色 */
        }
        .message.sent .bubble-and-tag-wrapper .card-bubble {
            background-color: var(--message-received-bubble-bg); /* 卡片背景色保持一致 */
            border: none; /* 卡片无边框 */
        }
        .message.sent .bubble-and-tag-wrapper .emoji-bubble {
            background-color: transparent; /* 表情包气泡透明 */
            border: none;
        }
        
        
    /* 新增番茄钟相关CSS样式 */

    .pomodoro-btn i {
        color: var(--btn-icon-color);
        font-size: 1.2em;
    }

    .pomodoro-btn:hover {
        background-color: var(--btn-hover-bg);
        transform: translateY(-2px);
    }

    .pomodoro-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    /* 番茄钟活跃状态的按钮样式 */
    .pomodoro-btn.active-pomodoro {
        background-color: var(--theme-color-3); /* 活跃时使用主题色 */
        box-shadow: 0 0 10px rgba(var(--theme-color-rgb-3), 0.5);
        animation: pulse 1.5s infinite alternate; /* 添加跳动动画 */
    }

    .pomodoro-btn.active-pomodoro i {
        color: var(--text-color-white); /* 活跃时图标颜色变白 */
    }

    @keyframes pulse {
        0% {
            transform: scale(1);
            box-shadow: 0 0 10px rgba(var(--theme-color-rgb-3), 0.5);
        }
        100% {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(var(--theme-color-rgb-3), 0.8);
        }
    }

    /* 番茄钟弹窗样式 */
    .pomodoro-modal .modal-content {
        width: 90%;
        max-width: 400px;
        padding: 25px;
        text-align: center;
    }

    .pomodoro-modal .modal-body {
        padding: 20px 0;
    }

    .pomodoro-modal .form-group {
        margin-bottom: 20px;
    }

    .pomodoro-modal .form-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
        color: var(--form-label-color);
    }

    .pomodoro-modal .form-control {
        width: calc(100% - 20px);
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 8px;
        font-size: 1em;
        box-sizing: border-box;
    }

    .pomodoro-countdown {
        font-size: 3em;
        font-weight: bold;
        color: var(--theme-color-4); /* 使用主题色 */
        margin: 20px 25%;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
    }

    .pomodoro-status-message {
        font-size: 1.1em;
        color: var(--text-color-medium);
        margin-bottom: 15px;
    }

    .pomodoro-modal .modal-footer {
        display: flex;
        justify-content: center;
        gap: 15px;
        padding-top: 20px;
        border-top: 1px solid #eee;
    }

    /* 番茄钟通知浮窗样式 (与随笔通知类似) */
    .pomodoro-notification {
        position: fixed;
        bottom: 80px; /* 调整位置，避免与输入框重叠 */
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(var(--theme-color-rgb-3), 0.9); /* 使用主题色3，半透明 */
        color: var(--text-color-white);
        padding: 12px 20px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
        font-size: 0.95em;
        white-space: nowrap;
        max-width: 80%;
        text-align: center;
    }

    .pomodoro-notification.show {
        opacity: 1;
        visibility: visible;
        transform: translateX(-50%) translateY(-10px); /* 向上微移 */
    }
    
    #pomodoro-goal-input {
    text-align: center; /* 文字水平居中 */
}


    /* 新增：表情包功能相关样式 */
    .small-btn {
        width: 40px; /* 缩小按钮宽度 */
        height: 40px; /* 缩小按钮高度 */
        min-width: 40px; /* 确保在flex布局中不会被压缩 */
        padding: 0; /* 移除内边距 */
        font-size: 1.2em; /* 调整图标大小 */
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 50%; /* 圆形按钮 */
        margin-right: 3px; /* 与输入框的间距 */
    }

    .emoji-btn {
        background-color: var(--btn-bg);
        color: var(--btn-icon-color);
        border: none;
        cursor: pointer;
        transition: background-color 0.2s ease;
    }

    .emoji-btn:hover {
        background-color: var(--btn-hover-bg);
    }

    .emoji-card {
        position: absolute;
        bottom: calc(100% + 10px); /* 定位在输入区域上方 */
        left: 10px;
        right: 10px;
        background-color: var(--message-received-bubble-bg);
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        padding: 15px;
        z-index: 1000;
        display: none; /* 默认隐藏 */
        flex-direction: column;
        max-height: 250px; /* 限制卡片高度 */
        overflow: hidden; /* 隐藏滚动条 */
    }

    .emoji-card.active {
        display: flex;
    }

    .emoji-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        padding-bottom: 10px;
        border-bottom: 1px solid #eee;
    }

    .emoji-card-title {
        margin: 0;
        font-size: 1.1em;
        color: var(--modal-title-color);
    }

    .close-emoji-card-btn {
        background: none;
        border: none;
        font-size: 1.5em;
        color: var(--close-btn-color);
        cursor: pointer;
        padding: 0 5px;
    }

    .emoji-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr); /* 每行4个 */
        gap: 10px; /* 表情包之间的间距 */
        flex-grow: 1; /* 允许网格区域填充可用空间 */
        overflow-y: auto; /* 如果表情包过多，允许滚动 */
        padding-right: 5px; /* 避免滚动条遮挡内容 */
    }

    .emoji-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 5px;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        text-align: center;
    }

    .emoji-item:hover {
        background-color: #f0f0f0; /* 悬停效果 */
    }

    .emoji-item img {
        width: 50px; /* 表情包图片大小 */
        height: 50px;
        object-fit: contain;
        margin-bottom: 5px;
    }

    .emoji-item span {
        font-size: 0.75em;
        color: var(--text-color-medium);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
    }

    .emoji-pagination {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid #eee;
    }

    .emoji-page-btn {
        background-color: var(--btn-primary-bg); /* 使用主题色 */
        color: var(--btn-primary-color);
        border: none;
        border-radius: 8px;
        padding: 8px 15px;
        cursor: pointer;
        font-size: 0.9em;
        transition: background-color 0.2s ease;
        margin: 0 10px;
    }

    .emoji-page-btn:hover:not(:disabled) {
        background-color: var(--btn-primary-hover-bg);
    }

    .emoji-page-btn:disabled {
        background-color: #ccc;
        cursor: not-allowed;
    }

    #emoji-page-info {
        font-size: 0.9em;
        color: var(--text-color-medium);
    }



    /* 确保聊天区域在输入区域上方有足够空间 */
    .chat-area {
        padding-bottom: 70px; /* 留出输入区域的高度 */
    }

    /* 调整 .container 的 padding-bottom，如果 input-area 是 fixed */
    .container {
        padding-bottom: 0; /* input-area 已经有 padding */
    }

    /* 确保 .message.emoji-bubble 的样式 */
    .message.emoji-bubble .bubble {
        background: none; /* 表情包气泡不需要背景 */
        padding: 0; /* 移除内边距 */
        box-shadow: none; /* 移除阴影 */
        border: none; /* 移除边框 */
        display: inline-block; /* 确保图片能正确显示 */
        max-width: 100px; /* 限制表情包图片的最大宽度 */
        max-height: 100px; /* 限制表情包图片的最大高度 */
    }

    .message.emoji-bubble .bubble img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }

    /* 调整主题颜色变量，以支持新的按钮和卡片 */
    :root {
        --btn-primary-bg: var(--theme-color-3); /* 例如，使用主题色3作为主要按钮背景 */
        --btn-primary-hover-bg: var(--theme-color-4); /* 悬停时使用主题色4 */
    }
    

    /* 新增：表情包卡片样式 */
    .emoji-card {
        position: absolute; /* 相对于父容器定位 */
        bottom: var(--input-area-height); /* 位于输入区域上方 */
        left: 0;
        right: 0;
        width: 100%;
        max-height: 200px; /* 限制高度 */
        background-color: var(--modal-bg); /* 使用模态框背景色 */
        border-top: 1px solid var(--border-color-light);
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        z-index: 100; /* 确保在聊天区域上方 */
        display: none; /* 默认隐藏 */
        flex-direction: column;
        padding: 10px;
        box-sizing: border-box;
        overflow-y: auto; /* 允许滚动 */
    }

    .emoji-card.active {
        display: flex;
    }

    .emoji-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr); /* 每行4个 */
        gap: 10px;
        padding: 5px;
        flex-grow: 1;
        overflow-y: auto; /* 确保表情网格内部可滚动 */
        background-color: var(--persona-card-bg-light); /* 浅色背景 */
    }

    .emoji-item {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 5px;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        background-color: var(--persona-card-bg-light); /* 浅色背景 */
        border: 1px solid var(--persona-card-border-light); /* 浅色边框 */
    }

    .emoji-item:hover {
        background-color: var(--theme-color-1-light); /* 悬停效果 */
    }

    .emoji-item img {
        width: 100%;
        height: auto;
        max-width: 60px; /* 限制表情包图片大小 */
        max-height: 60px;
        object-fit: contain;
    }

    .emoji-pagination {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 5px 0;
        border-top: 1px solid var(--border-color-light);
        margin-top: 5px;
        background-color: var(--persona-card-bg-light);
    }

    .emoji-pagination button {
        padding: 8px 15px;
        border-radius: 5px;
        font-size: 0.9rem;
        cursor: pointer;
        background-color: var(--btn-secondary-bg);
        color: var(--btn-secondary-color);
        border: 1px solid var(--btn-secondary-border);
        transition: background-color 0.2s ease;
    }

    .emoji-pagination button:hover {
        background-color: var(--btn-secondary-hover-bg);
    }

    .emoji-pagination span {
        font-size: 0.9rem;
        color: var(--text-color-medium);
    }



    /* 新增表情按钮样式 */
    .emoji-btn {
        width: 30px; /* 与其他小按钮保持一致 */
        height: 30px;
        min-width: 30px;
        min-height: 30px;
        padding: 0;
        font-size: 1.2rem;
        border-radius: 50%; /* 圆形按钮 */
        background-color: var(--btn-bg);
        color: var(--btn-icon-color);
        border: none;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        transition: background-color 0.2s ease, transform 0.1s ease;
        margin-right: 3px; /* 与展开/收起按钮的间距 */
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .emoji-btn:hover {
        background-color: var(--btn-hover-bg);
        transform: translateY(-1px);
    }

    .emoji-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    /* 调整输入区域布局以适应新按钮 */
    .input-area {
        display: flex;
        align-items: flex-end; /* 底部对齐 */
        padding: 10px;
        background-color: var(--input-area-bg);
        border-top: 1px solid var(--border-color-light);
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
        position: relative; /* 确保emoji-card可以相对定位 */
        z-index: 101; /* 确保输入区域在emoji-card上方 */
    }

    .message-input {
        flex-grow: 1;
        margin: 0 8px; /* 调整与按钮的间距 */
        max-height: 120px; /* 限制最大高度 */
        overflow-y: auto;
        resize: none;
        padding: 10px;
        border-radius: 20px;
        border: 1px solid var(--border-color-light);
        font-size: 1rem;
        line-height: 1.4;
        background-color: var(--message-input-bg);
        color: var(--text-color-dark);
        transition: all 0.3s ease;
    }

    /* 确保输入栏上移时，emoji-card也跟着上移 */
    body.input-area-shifted-up .emoji-card {
        bottom: calc(var(--input-area-height) + var(--input-area-shift-amount));
    }

    /* 针对表情包消息气泡的样式 */
    .message .emoji-bubble {
        background-color: transparent; /* 表情包气泡背景透明 */
        border: none; /* 无边框 */
        padding: 0; /* 无内边距 */
        box-shadow: none; /* 无阴影 */
        max-width: 120px; /* 限制表情包图片的最大宽度 */
        display: inline-block; /* 确保内容不会撑满 */
        vertical-align: bottom; /* 底部对齐 */
    }

    .message .emoji-bubble img {
        max-width: 100%;
        height: auto;
        display: block; /* 移除图片底部空白 */
        border-radius: 8px; /* 图片圆角 */
    }

    /* 调整发送方表情包的对齐 */
    .message.sent .emoji-bubble {
        margin-left: auto; /* 推到右边 */
        margin-right: 0;
    }

    /* 调整接收方表情包的对齐 */
    .message.received .emoji-bubble {
        margin-right: auto; /* 推到左边 */
        margin-left: 0;
    }

    /* 确保气泡内容居中对齐 */
    .message.sent .message-content,
    .message.received .message-content {
        align-items: flex-start; /* 默认左对齐 */
    }

    .message.sent .message-content {
        align-items: flex-end; /* 发送方右对齐 */
    }

    .message.sent .bubble-and-tag-wrapper {
        display: flex;
        flex-direction: column;
        align-items: flex-end; /* 确保撤回标签和气泡右对齐 */
    }

    .message.received .bubble-and-tag-wrapper {
        display: flex;
        flex-direction: column;
        align-items: flex-start; /* 确保撤回标签和气泡左对齐 */
    }


    
/* 红包消息气泡样式 */
.message .bubble.red-packet-bubble {
    display: flex;
    flex-direction: column;
    padding: 15px;
    width: 220px;
    border-radius: 12px;
    background: linear-gradient(135deg, #f54e4e, #d42b2b);
    color: white !important;
    cursor: pointer;
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
    border: none !important; /* 移除默认边框 */
}

        .red-packet-bubble::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
        }

        .red-packet-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .red-packet-icon {
            font-size: 1.8rem;
            margin-right: 10px;
        }

        .red-packet-title {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .red-packet-message {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .red-packet-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 5px;
        }

        /* 统一已领取红包的样式 */
        .message .red-packet-bubble.opened {
            background: linear-gradient(135deg, #cccccc, #aaaaaa) !important;
        }

        .red-packet-bubble.opened .red-packet-icon,
        .red-packet-bubble.opened .red-packet-title,
        .red-packet-bubble.opened .red-packet-message,
        .red-packet-bubble.opened .red-packet-footer {
            opacity: 0.7;
        }

        .red-packet-bubble.opened .red-packet-message::after {
            content: '已领取';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            font-weight: bold;
            color: white;
            background: rgba(0,0,0,0.3);
            padding: 5px 15px;
            border-radius: 20px;
            z-index: 2;
        }

    /* 新增：语音消息气泡样式 */
   .voice-message-bubble {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        background-color: white;
        border-radius: 18px;
        border: 1px solid var(--theme-color-1); /* 使用主题色 */
        cursor: pointer;
        position: relative;
        transition: all 0.3s ease;
        /* 确保气泡内容不会被头像遮挡 */
        z-index: 1;
    }

    .voice-message-bubble:hover {
        background-color: #f9f9f9;
    }

    .voice-duration {
        font-size: 0.8rem;
        color: var(--text-color-medium); /* 使用文本中等色 */
        margin-right: 10px;
        font-weight: bold;
    }

    .voice-wave {
        display: flex;
        align-items: center;
        height: 20px;
        flex-grow: 1; /* 让声纹占据剩余空间 */
        justify-content: flex-end; /* 声纹靠右 */
    }

    .voice-wave-bar {
        width: 3px;
        background-color: var(--theme-color-4); /* 使用主题色 */
        margin: 0 2px;
        border-radius: 2px;
        animation: voiceWave 1.5s infinite ease-in-out;
    }

    /* 确保动画延迟和高度与参考代码一致 */
    .voice-wave-bar:nth-child(1) { height: 8px; animation-delay: 0s; }
    .voice-wave-bar:nth-child(2) { height: 12px; animation-delay: 0.2s; }
    .voice-wave-bar:nth-child(3) { height: 16px; animation-delay: 0.4s; }
    .voice-wave-bar:nth-child(4) { height: 12px; animation-delay: 0.6s; }
    .voice-wave-bar:nth-child(5) { height: 8px; animation-delay: 0.8s; }

    @keyframes voiceWave {
        0%, 100% { height: 8px; }
        25% { height: 16px; }
        50% { height: 12px; }
        75% { height: 10px; }
    }

.voice-transcript {
    position: absolute;
    top: calc(100% + 5px); /* 定位在父气泡下方 */
    left: 0;
    min-width: 100%; /* 最小宽度与父气泡同宽 */
    max-width: 300px; /* 限制最大宽度（可选） */
    width: max-content; /* 关键：宽度根据内容自适应 */
    background: var(--auto-reply-bubble-bg);
    border: 1px solid var(--auto-reply-bubble-border);
    border-radius: 10px;
    padding: 8px 12px;
    font-size: 0.8rem;
    color: var(--text-color-dark);
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    z-index: 5;
    display: none;
    line-height: 1.4;
    box-sizing: border-box;
    white-space: normal; /* 允许文本换行 */
    word-break: break-word; /* 长单词或URL换行 */
}


    .voice-transcript.show {
        display: block;
    }


    .bubble-and-tag-wrapper {
        position: relative; /* 确保 voice-transcript 相对于此定位 */
        display: flex; /* 允许内部元素并排 */
        flex-direction: column; /* 气泡和文字内容垂直排列 */
        align-items: flex-start; /* 左对齐 */
        word-wrap: break-word;
        white-space: pre-wrap;
    }
    
        /* 新增：玩家发送的语音消息，其转录文本向左延伸 */
    .message.sent .bubble-and-tag-wrapper .voice-transcript {
        left: auto; /* 取消默认的左对齐 */
        right: 0; /* 对齐到父容器的右侧 */
        text-align: right; /* 文本也右对齐，更自然 */
    }

/* 新增：图片消息气泡样式 */
.message .bubble.image-message-bubble {
    display: flex;
    flex-direction: column; /* 允许图片和文字垂直堆叠 */
    justify-content: center;
    align-items: center;
    padding: 10px; /* 调整内边距 */
    max-width: 250px; /* 最大宽度 */
    min-width: 150px; /* 最小宽度 */
    max-height: 250px; /* 最大高度 */
    border-radius: 12px;
    background-color: var(--theme-color-3); /* 使用主题色3作为背景 */
    color: var(--text-color-dark);
    text-align: center;
    font-size: 0.95rem;
    line-height: 1.4;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    cursor: default;
    overflow: hidden;
    word-break: break-word;
    transition: transform 0.2s ease;
    border: none;
    position: relative; /* 用于定位图片 */
}

/* 消息中的图片样式 */
.image-message-bubble img {
    max-width: 100%;
    max-height: 150px; /* 图片最大高度 */
    object-fit: contain;
    border-radius: 8px;
    margin-bottom: 5px; /* 留下一点空间，即使描述不显示 */
    display: block; /* 移除底部空白 */
}

/* 消息中的图片描述文本 (默认隐藏，仅供AI使用) */
.image-message-bubble .image-description-text {
    display: none; /* 默认不显示文字描述 */
}

/* 纯图片（无文字描述）时，调整图片内边距，透明背景，无阴影 */
.image-message-bubble.pure-image {
    padding: 5px; /* 减少纯图片气泡的内边距 */
    background-color: transparent; /* 背景透明 */
    box-shadow: none; /* 移除阴影 */
    border: none !important; /* 移除边框 */
    max-width: 180px; /* 纯图片可以更大 */
    min-width: unset; /* 移除最小宽度限制，让图片自适应 */
    max-height: 180px;
}
.image-message-bubble.pure-image img {
    max-width: 100%;
    max-height: 100%; /* 纯图片可以更大 */
    margin: 0;
}

/* 文字占位符图片消息（displayImage为false或无图片URL时） */
.image-message-bubble.text-only-placeholder {
    min-width: 180px; /* 扩大宽度，更像文本气泡 */
    max-width: 300px; /* 允许其增长 */
    padding: 12px 16px; /* 文本气泡的标准内边距 */
    font-size: 1rem; /* 文本气泡的字体大小 */
    line-height: 1.4;
    background-color: var(--auto-reply-bubble-bg); /* 使用一个独特的背景 */
    border: 1px solid var(--auto-reply-bubble-border);
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    text-align: center; /* 新增：确保文字内容居中 */
    /* 确保文字占位符模式下图片不显示 */
    & img {
        display: none;
    }
    /* 确保描述文字在此模式下显示 */
    & .image-description-text {
        display: block;
        margin-top: 0; /* 文本模式下不需要顶部额外间距 */
    }
}

/* 消息发送方图片气泡的样式调整 */
.message.sent .bubble.image-message-bubble:not(.pure-image):not(.text-only-placeholder) {
    background: var(--message-sent-bubble-bg-gradient); /* 发送方图片气泡也使用渐变背景 */
    color: var(--message-sent-bubble-text-color);
    border: 1px solid rgba(var(--theme-color-rgb-4), 0.6); /* 发送方边框 */
}
.message.sent .bubble.image-message-bubble.text-only-placeholder {
    background: var(--message-sent-bubble-bg-gradient); /* 文字占位符也使用渐变背景 */
    color: var(--message-sent-bubble-text-color);
    border: 1px solid rgba(var(--theme-color-rgb-4), 0.6);
}

.message .bubble.image-message-bubble:hover {
    transform: scale(1.02);
}

/* 调整输入区域总体的内外边距和间距 */
.input-area {
    background: var(--input-area-bg);
    padding: 10px; /* 统一整个输入区域的内边距 */
    border-top: 1px solid var(--border-color-light);
    display: flex;
    gap: 5px; /* 导航按钮和输入区域容器之间的间距 */
    z-index: 10;
    align-items: flex-end;
    margin-bottom: var(--input-area-shift-height); 
    transition: margin-bottom 0.3s ease;
}

/* 输入区域的滑动容器 */
.input-area-wrapper {
    display: flex;
    flex-grow: 1; /* 占据输入区域内所有剩余水平空间 */
    overflow: hidden; /* 隐藏超出容器的内容，这是解决溢出问题的关键 */
}

.input-pages-container {
    display: flex;
    width: 200%; /* 包含两个页面，总宽度是包装器宽度的两倍 */
    transition: transform 0.3s ease-out; /* 平滑滑动效果 */
}

.input-page {
    flex: 0 0 50%; /* 每个页面严格占据50%的父容器（input-pages-container）宽度 */
    display: flex;
    align-items: flex-end;
    gap: 8px; /* 页面内部元素之间的间距 */
    padding: 0 8px; /* 页面内部内容的左右内边距 */
    box-sizing: border-box; /* 确保内边距包含在50%的宽度计算内 */
}

/* 导航按钮样式 (优化尺寸和效果) */
.nav-input-btn {
    background: transparent;
    border: none;
    font-size: 1.5rem;
    color: var(--text-color-medium);
    cursor: pointer;
    padding: 10px 3px; /* 调整垂直方向的内边距，使其视觉上更“窄高” */
    transition: color 0.2s ease, transform 0.1s ease;
    flex-shrink: 0; /* 防止导航按钮在空间不足时收缩 */
    width: 8px; /* 导航按钮的宽度 */
    height: 60px; /* 导航按钮的高度，使其在垂直方向上更长 */
    display: flex;
    justify-content: center;
    align-items: center;
    transform: scaleY(1.5); /* 垂直拉伸箭头图标，使其看起来更细长 */
    line-height: 1; /* 调整行高以避免文字或图标上下间距过大 */
}

.nav-input-btn:hover {
    color: var(--theme-color-4);
    transform: scaleY(1.3); /* 悬停时稍微再拉伸一点 */
}

.nav-input-btn:active {
    transform: scaleY(0.9); /* 点击时轻微压缩效果 */
}

/* 重新应用和统一所有小按钮的样式 (表情、展开/收起、语音、图片) */
.emoji-btn,
.toggle-input-btn,
.voice-btn,
.image-btn,
.red-packet-btn {
    /* 它们现在将继承 .control-button 的样式 */
    /* 如果有特殊需求可以单独覆盖，但通常无需额外设置 */
}

/* 确保消息输入框能弹性伸缩 */
.message-input {
    flex-grow: 1; /* 允许输入框填充剩余空间 */
    flex-shrink: 1; /* 允许输入框在空间不足时收缩 */
    min-width: 0; /* 允许输入框在极端情况下收缩到0，防止溢出 */
    margin: 0; /* 移除任何可能导致布局问题的额外边距 */
    /* 其余样式保持不变，如 padding, border等 */
}

/* 确保发送按钮不收缩 */
.send-btn {
    flex-shrink: 0;
    /* 其余样式保持不变 */
}

        /* 新增：自定义新消息通知栏样式 */
        .custom-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-150%); /* 初始位置在屏幕外上方 */
            width: 90%;
            max-width: 450px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 1070; /* 高于朋友圈(1000)和管理侧边栏(1050) */
            cursor: pointer;
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            opacity: 0;
            visibility: hidden;
        }

        .custom-notification.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
            visibility: visible;
        }

        .notification-avatar {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .notification-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
            overflow: hidden;
        }

        .notification-header {
            font-size: 0.75rem;
            color: var(--text-color-lighter);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .notification-title {
            font-weight: bold;
            color: var(--text-color-dark);
            font-size: 1rem;
        }

        .notification-body {
            color: var(--text-color-medium);
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }



    @media (max-width: 500px) {
        .container {
            height: 100vh;
            border-radius: 0;
        }
        
        .header h1 {
            font-size: 1.2rem;
        }
        
        .bubble {
            padding: 10px 14px;
            font-size: 0.85rem;
        }
        
        .message-input {
            padding: 10px 15px;
            min-height: 45px; /* 手机端输入框高度略减 */
            height: 45px;
        }
        
        .send-btn {
            width: 40px;
            height: 40px;
        }

        .toggle-input-btn {
            width: 40px;
            height: 40px;
        }

        .emoji-btn,
        .voice-btn,
        .image-btn,
        .red-packet-btn {
            width: 35px; /* 手机端功能按钮尺寸 */
            height: 35px;
            min-width: 35px;
            min-height: 35px;
            font-size: 1.0rem;
        }
        /* ... 其他手机端样式保持不变 ... */

        .essay-notification {
            width: 90%;
            left: 5%;
            transform: translateX(0) translateY(-100%);
        }
        .essay-notification.show {
            transform: translateX(0) translateY(0);
        }

        .manage-modal {
            width: 100%;
            max-width: none;
        }

        /* 手机端输入栏上移高度调整 */
        .container.input-area-shifted-up {
            --input-area-shift-height: 60px; /* 手机导航栏通常较高 */
        }

        /* 手机端番茄钟通知位置调整 */
        .pomodoro-notification {
            bottom: calc(10px + var(--input-area-height, 120px)); /* 基于新的输入区域高度计算 */
        }
    }
    
/* 确保语音消息气泡的发送方和接收方有自己的颜色 */
.message.sent .bubble.voice-message-bubble {
    background: var(--message-sent-bubble-bg-gradient); /* 发送方使用渐变背景 */
    color: var(--message-sent-bubble-text-color); /* 发送方文本颜色 */
    border: 1px solid rgba(var(--theme-color-rgb-4), 0.6); /* 发送方边框 */
}

.message.sent .voice-message-bubble .voice-duration {
    color: var(--text-color-white); /* 发送方语音时长颜色 */
}

.message.sent .voice-message-bubble .voice-wave-bar {
    background-color: var(--text-color-white); /* 发送方声纹颜色改为白色 */
}

.message.received .voice-message-bubble .voice-wave-bar {
    background-color: var(--theme-color-1); /* 接收方声纹颜色使用主题色 */
}

/* 新增：输入区域功能按钮的激活状态样式 */
.control-button.active {
    background-color: var(--theme-color-3); /* 使用主题色3作为激活背景色 */
    color: var(--text-color-white); /* 激活时图标颜色变白 */
    box-shadow: 0 0 10px rgba(var(--theme-color-rgb-3), 0.5); /* 激活时添加光晕效果 */
}
.control-button.active i {
    color: var(--text-color-white); /* 确保图标颜色也变白 */
}

        /* 新增：自定义主题相关样式 */
        .custom-theme-section {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px dashed var(--border-color-light);
            text-align: center;
        }

        .custom-theme-section .btn-secondary {
            width: 80%;
            padding: 10px 20px;
            font-size: 1rem;
        }

        .custom-color-inputs {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-top: 15px;
            padding: 10px;
            background-color: var(--persona-card-bg-light);
            border-radius: 10px;
        }

        .color-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .color-input-group label {
            font-size: 0.85rem;
            color: var(--text-color-medium);
            margin-bottom: 0;
        }

        .color-input-group input[type="color"] {
            width: 50px;
            height: 50px;
            border: 2px solid var(--border-color-light);
            border-radius: 50%;
            cursor: pointer;
            padding: 0;
            background-color: transparent;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .color-input-group input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        .color-input-group input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }
        .color-input-group input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 50%;
        }

        /* 新增：朋友圈中玩家名字使用主题色 */
        .moment-card.player-post .moment-card-name,
        .comment-item.player-comment .commenter-name {
            color: var(--theme-color-4);
        }


</style>

</head>
<body>
    <div class="container">
        <!-- 顶部标题栏 -->
        <div class="header">
            <h1><span id="friend-name-display">好友</span> <span id="friend-status-dot" class="status-dot"></span></h1>
            <div class="header-buttons">
                <!-- 新增：管理按钮 -->
                <button class="btn" id="manage-btn" title="管理设置">
                    <i class="fas fa-bars"></i>
                </button>
                <!-- 新增：朋友圈按钮 -->
                <button class="btn" id="moments-btn" title="朋友圈">
                    <i class="fas fa-circle-nodes"></i>
                </button>
                <!-- 新增：番茄钟按钮 -->
                <button class="btn pomodoro-btn" id="pomodoro-btn" title="番茄钟">
                    <i class="fas fa-clock"></i>
                </button>
                <!-- 查看对方状态/心声按钮 (保留) -->
                <button class="btn" id="friend-status-btn" title="查看对方状态">
                    <i class="fas fa-eye"></i>
                </button>
            </div>
        </div>
        
        <!-- 聊天区域 -->
        <div class="chat-area" id="chat-area">
            <!-- 消息会动态添加到这里 -->
        </div>
        
        <!-- 输入区域 -->
        <div class="input-area">
            <!-- 上方行：展开/关闭按钮 + 输入框 + 发送按钮 -->
            <div class="input-top-row">
                <!-- 新增：手动回复按钮，默认隐藏 -->
                <button class="send-btn" id="manual-reply-btn" title="让对方回复" style="display: none;">
                    <i class="fas fa-feather-alt"></i>
                </button>
                <!-- 展开/收起按钮 -->
                <button class="toggle-input-btn control-button" id="toggle-input-btn" title="展开/收起输入框">
                    <span class="arrow-icon">🌷</span>
                </button>
                <textarea class="message-input" id="message-input" placeholder="“”可分隔消息,输入消息..." rows="1"></textarea>
                <button class="send-btn" id="send-btn">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
            <!-- 下方行：功能按钮 -->
            <div class="input-feature-row">
                <!-- 表情符号按钮 -->
                <button class="emoji-btn control-button" id="emoji-btn" title="发送表情">
                    <i class="fas fa-smile"></i>
                </button>
                <!-- 发送语音按钮 -->
                <button class="voice-btn control-button" id="voice-btn" title="发送语音">
                    <i class="fas fa-microphone"></i>
                </button>
                <!-- 发送图片按钮 -->
                <button class="image-btn control-button" id="image-btn" title="发送图片">
                    <i class="fas fa-image"></i>
                </button>
         <!-- 发送红包按钮 -->
                <button class="red-packet-btn control-button" id="red-packet-btn" title="发送红包">
                    <i class="fas fa-money-bill-wave"></i>
                </button>
                <!-- 更多功能按钮可以放置在这里 -->
            </div>
        </div>

        <!-- 表情包卡片 -->
        <div class="emoji-card" id="emoji-card">
            <div class="emoji-grid" id="emoji-grid">
                <!-- 表情包将在这里动态加载 -->
            </div>
            <div class="emoji-pagination">
                <button id="prev-emoji-page-btn" class="btn-secondary">上一页</button>
                <span id="emoji-page-info">1 / 1</span>
                <button id="next-emoji-page-btn" class="btn-secondary">下一页</button>
            </div>
        </div>
    </div>
    
    <!-- 用户设置弹窗 -->
    <div class="modal" id="user-config-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">用户设置</h3>
                <button class="close-btn" id="close-user-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="avatar-upload">
                    <img src="https://z.wiki/u/ah2XaE" alt="用户头像" class="avatar-preview" id="user-avatar-preview">
                    <button class="upload-btn" id="user-upload-btn">上传头像</button>
                    <input type="file" id="user-avatar-upload" accept="image/*" style="display:none">
                </div>
                
                <div class="form-group">
                    <label for="user-name">姓名</label>
                    <input type="text" class="form-control" id="user-name" placeholder="输入您的姓名">
                </div>
                
                <div class="form-group">
                    <label for="user-gender">性别</label>
                    <select class="form-control" id="user-gender">
                        <option value="male">男</option>
                        <option value="female">女</option>
                        <option value="other">其他</option>
                    </select>
                </div>

                <!-- 新增：用户角色资料 -->
                <div class="form-group">
                    <label for="user-background">角色资料 (可选)</label>
                    <textarea class="form-control" id="user-background" rows="3" placeholder="输入您的背景资料..."></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-user-btn">取消</button>
                <button class="btn-primary" id="save-user-btn">保存</button>
            </div>
        </div>
    </div>
    
    <!-- 好友设置弹窗 -->
    <div class="modal" id="friend-config-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">好友设置</h3>
                <button class="close-btn" id="close-friend-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="avatar-upload">
                    <img src="https://z.wiki/u/Pnhnhz" alt="好友头像" class="avatar-preview" id="friend-avatar-preview">
                    <button class="upload-btn" id="friend-upload-btn">上传头像</button>
                    <input type="file" id="friend-avatar-upload" accept="image/*" style="display:none">
                </div>
                
                <div class="form-group">
                    <label for="friend-name">姓名</label>
                    <input type="text" class="form-control" id="friend-name" placeholder="输入好友姓名">
                </div>
                
                <div class="form-group">
                    <label for="friend-nickname">备注</label>
                    <input type="text" class="form-control" id="friend-nickname" placeholder="输入好友备注">
                </div>
                
                <div class="form-group">
                    <label for="friend-gender">性别</label>
                    <select class="form-control" id="friend-gender">
                        <option value="male">男</option>
                        <option value="female">女</option>
                        <option value="other">其他</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="friend-likes">喜好 (可选)</label>
                    <input type="text" class="form-control" id="friend-likes" placeholder="例如：音乐，旅行，美食(用'，'隔开)">
                </div>
                
                <div class="form-group">
                    <label for="friend-dislikes">厌恶 (可选)</label>
                    <input type="text" class="form-control" id="friend-dislikes" placeholder="例如：吵闹，早起，辛辣食物(用'，'隔开)">
                </div>
                
                <div class="form-group">
                    <label for="friend-habits">习惯 (可选)</label>
                    <input type="text" class="form-control" id="friend-habits" placeholder="例如：晚睡，喝咖啡，散步(用'，'隔开)">
                </div>

                <!-- 新增：对玩家的称呼 -->
                <div class="form-group">
                    <label for="friend-player-address">对玩家的称呼 (可选)</label>
                    <input type="text" class="form-control" id="friend-player-address" placeholder="例如：33大王">
                    <small style="color: #888; display: block; margin-top: 5px;">对方对你的称呼，不填则默认使用你的姓名。</small>
                </div>
                
                <div class="form-group">
                    <label for="friend-background">背景资料 (可选)</label>
                    <textarea class="form-control" id="friend-background" rows="3" placeholder="输入好友背景资料..."></textarea>
                </div>

                <!-- 新增：开场白设定 -->
                <div class="form-group">
                    <label for="friend-opening-line">开场白 (可选)</label>
                    <textarea class="form-control" id="friend-opening-line" rows="3" placeholder="输入开场白设定，提示好友向你发送第一条消息时的背景设定，仅在“保存并开始聊天”时生效..."></textarea>
                    <small style="color: #888; display: block; margin-top: 5px;">如果填写，AI好友将以此开场白结合人设向你发送第一条消息。</small>
                </div>

                <hr style="margin: 25px 0; border: 0; border-top: 1px solid #eee;">

                <!-- 新增：拍一拍设置 -->
                <div class="form-group">
                    <label for="friend-poke-action">拍一拍动作</label>
                    <input type="text" class="form-control" id="friend-poke-action" placeholder="输入动作，如“拍了拍”">
                </div>
                <div class="form-group">
                    <label for="friend-poke-content">拍一拍内容 </label>
                    <input type="text" class="form-control" id="friend-poke-content" placeholder="输入内容，如“并告诉对方‘今天很帅嘛’”">
                    <small style="color: #888; display: block; margin-top: 5px;">格式：我（动作）对方，（内容）。<br>例如：我拍了拍对方，并说“我是33，我同意上一休六”</small>
                </div>
            </div>
            
            <div class="modal-footer">
                <div class="modal-footer-row">
                    <button class="btn-secondary" id="export-friend-btn">导出</button>
                    <button class="btn-secondary" id="save-friend-only-btn">保存</button>
                </div>
                <div class="modal-footer-row">
                    <button class="btn-secondary" id="cancel-friend-btn">取消</button>
                    <button class="btn-primary" id="save-friend-and-chat-btn">开始聊天</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- API配置弹窗 -->
    <div class="modal" id="api-config-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">API配置</h3>
                <button class="close-btn" id="close-api-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="api-provider">API提供商</label>
                    <select class="form-control" id="api-provider">
                        <option value="gemini">Google Gemini</option>
                        <option value="siliconflow">SiliconFlow</option>
                        <option value="paioupu">派欧云</option>
                        <option value="volcano">火山</option>
                        <option value="custom">自定义</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="api-url">API URL</label>
                    <input type="text" class="form-control" id="api-url" placeholder="输入API URL">
                </div>
                
                <div class="form-group">
                    <label for="api-key">API Key</label>
                    <input type="password" class="form-control" id="api-key" placeholder="输入API密钥">
                </div>
                
                <div class="form-group">
                    <label for="api-model-select">模型</label>
                    <select class="form-control" id="api-model-select">
                        <!-- Options will be dynamically populated -->
                    </select>
                    <input type="text" class="form-control" id="api-model-input" placeholder="输入自定义模型名称" style="display:none;">
                </div>
                
                <div class="form-group">
                    <label for="temperature">温度 (0-1)</label>
                    <input type="number" class="form-control" id="temperature" min="0" max="1" step="0.1" value="0.7">
                </div>

                <!-- 角色提示轮次 -->
                <div class="form-group">
                    <label for="persona-reminder-interval">角色提示轮次 (每N条用户消息)</label>
                    <input type="number" class="form-control" id="persona-reminder-interval" min="1" value="2">
                    <small style="color: #888; display: block; margin-top: 5px;">解释：就是每N回合发送1次角色设定</small>
                </div>
                
                <!-- 新增：上下文长度限制 -->
                <div class="form-group">
                    <label for="context-char-limit">上下文长度限制 (字符数)</label>
                    <input type="number" class="form-control" id="context-char-limit" min="0" step="1000" value="8000">
                    <small style="color: #888; display: block; margin-top: 5px;">为0则不限制。限制发送给AI的聊天记录长度，防止Token超限。会优先保留最新的消息。</small>
                </div>

            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-api-btn">取消</button>
                <button class="btn-primary" id="save-api-btn">保存配置</button>
            </div>
        </div>
    </div>

    <!-- 心声弹窗 -->
    <div class="modal" id="inner-voice-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">好友状态</h3>
                <button class="close-btn" id="close-inner-voice-modal">&times;</button>
            </div>
            <div class="modal-body">
                <h4>ta的心声：</h4>
                <p id="inner-voice-display" class="inner-voice-text">暂无心声。</p>
                <h4 style="margin-top: 20px;">ta的随笔：</h4>
                <p id="essay-display" class="essay-text">暂无随笔。</p>
            </div>
        </div>
    </div>

    <!-- 其他设置弹窗 (原自动回复设置) -->
    <div class="modal" id="all-settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">其他设置</h3>
                <button class="close-btn" id="close-all-settings-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="auto-reply-switch">主动发消息开关</label>
                    <!-- Toggle Switch HTML -->
                    <div class="toggle-switch-container">
                        <input type="checkbox" id="auto-reply-switch" class="toggle-switch-checkbox">
                        <label for="auto-reply-switch" class="toggle-switch-label">
                            <span class="toggle-switch-inner"></span>
                            <span class="toggle-switch-switch"></span>
                        </label>
                    </div>
                </div>
                <!-- 新增：输入栏上移选项 -->
                <div class="form-group">
                    <label for="input-area-shift-up-switch">输入栏上移</label>
                    <div class="toggle-switch-container">
                        <input type="checkbox" id="input-area-shift-up-switch" class="toggle-switch-checkbox">
                        <label for="input-area-shift-up-switch" class="toggle-switch-label">
                            <span class="toggle-switch-inner"></span>
                            <span class="toggle-switch-switch"></span>
                        </label>
                    </div>
                    <small style="color: #888; display: block; margin-top: 5px;">打开此选项可将输入栏上移，避免被手机导航栏遮挡。</small>
                </div>
         <!-- 新增：回车发送消息选项 -->
                <div class="form-group">
                    <label for="enter-send-switch">回车发送消息</label>
                    <div class="toggle-switch-container">
                        <input type="checkbox" id="enter-send-switch" class="toggle-switch-checkbox">
                        <label for="enter-send-switch" class="toggle-switch-label">
                            <span class="toggle-switch-inner"></span>
                            <span class="toggle-switch-switch"></span>
                        </label>
                    </div>
                    <small style="color: #888; display: block; margin-top: 5px;">打开此选项，按回车键将发送消息；关闭则按Shift+回车发送，回车换行。</small>
                </div>
                <!-- 新增：即发即回开关 -->
                <div class="form-group">
                    <label for="immediate-reply-switch">即发即回</label>
                    <div class="toggle-switch-container">
                        <input type="checkbox" id="immediate-reply-switch" class="toggle-switch-checkbox">
                        <label for="immediate-reply-switch" class="toggle-switch-label">
                            <span class="toggle-switch-inner"></span>
                            <span class="toggle-switch-switch"></span>
                        </label>
                    </div>
                    <small style="color: #888; display: block; margin-top: 5px;">打开后，发送消息/表情等会立即触发AI回复。关闭后，需手动点击“回复”按钮触发。</small>
                </div>
                <!-- 新增：全局字体选择 -->
                <div class="form-group">
                    <label for="global-font-select">全局字体</label>
                    <select class="form-control" id="global-font-select">
                        <option value="lxgw-wenkai-screen">默认楷体 (LXGW)</option>
                        <option value="system-ui">系统默认</option>
                        <option value="SimSun">宋体</option>
                        <option value="Zpix">像素体 (Zpix)</option>
                    </select>
                </div>
                <!-- 新增：心声字体选项 -->
                <div class="form-group">
                    <label for="inner-voice-font-select">心声字体</label>
                    <select class="form-control" id="inner-voice-font-select">
                        <option value="ma-shan-zheng">手写体(默认)</option>
                        <option value="long-cang">龙藏体(推荐)</option>
                        <option value="zcool-xiaowei">小薇体</option>
                        <option value="zcool-kuaile">快乐体</option>
                        <option value="zcool-qingke-huangyou">黄油体</option>
                        <option value="liu-jian-mao-cao">毛笔草书</option>
                        <option value="zhi-mang-xing">毛笔行书</option>
                        <option value="zpix">像素体</option>
                        <option value="lxgw-wenkai-screen">楷体</option>
                    </select>
                </div>
                <!-- 随笔字体选项 -->
                <div class="form-group">
                    <label for="essay-font-select">随笔字体</label>
                    <select class="form-control" id="essay-font-select">
                        <option value="ma-shan-zheng">手写体(默认)</option>
                        <option value="long-cang">龙藏体(推荐)</option>
                        <option value="zcool-xiaowei">小薇体</option>
                        <option value="zcool-kuaile">快乐体</option>
                        <option value="zcool-qingke-huangyou">黄油体</option>
                        <option value="liu-jian-mao-cao">毛笔草书</option>
                        <option value="zhi-mang-xing">毛笔行书</option>
                        <option value="zpix">像素体</option>
                        <option value="lxgw-wenkai-screen">楷体</option>
                    </select>
                </div>
                <!-- 新增：表情包显示方式选项 -->
                <div class="form-group">
                    <label for="emoji-display-mode">表情包显示方式</label>
                    <select class="form-control" id="emoji-display-mode">
                        <option value="image">表情包(图片)</option>
                        <option value="none">不需要表情包</option>
                    </select>
                </div>
            </div>
            <!-- 此弹窗无需保存按钮，因为开关和字体选择操作即时生效 -->
        </div>
    </div>

    <!-- 新增：随笔通知浮窗 -->
    <div class="essay-notification" id="essay-notification">
        <p id="essay-notification-text"></p>
    </div>

    <!-- 新增：管理侧边弹窗 -->
    <div class="manage-modal" id="manage-modal">
        <div class="modal-header">
            <h3 class="modal-title">管理</h3>
            <button class="close-btn" id="close-manage-modal">&times;</button>
        </div>
        <div class="modal-body">
            <button class="btn" id="manage-friend-config-btn" title="设置好友">
                <i class="fas fa-user-friends"></i> <span>设置好友</span>
            </button>
            <button class="btn" id="manage-user-config-btn" title="设置自己">
                <i class="fas fa-user"></i> <span>设置自己</span>
            </button>
            <!-- 新增：人设选择按钮 -->
            <button class="btn" id="manage-persona-selection-btn" title="选择AI好友人设">
                <i class="fas fa-user-tag"></i> <span>人设选择</span>
            </button>
            <!-- 新增：本地记录按钮 -->
            <button class="btn" id="manage-local-records-btn" title="本地记录">
                <i class="fas fa-folder-open"></i> <span>本地记录</span>
            </button>
        <!-- 新增：自定义提示词按钮 -->
        <button class="btn" id="manage-custom-prompt-btn" title="增加自定义提示词">
            <i class="fas fa-lightbulb"></i> <span>增加提示词</span>
        </button>
            <!-- 自动回复设置按钮 (现在是打开“其他设置”弹窗的按钮) -->
            <button class="btn" id="manage-all-settings-btn" title="其他设置">
                <i class="fas fa-cog"></i> <span>其他设置</span>
            </button>
            <button class="btn" id="manage-api-config-btn" title="API设置">
                <i class="fas fa-robot"></i> <span>API设置</span>
            </button>
            <!-- 新增：主题设置按钮 -->
            <button class="btn" id="manage-theme-settings-btn" title="主题设置">
                <i class="fas fa-palette"></i> <span>主题设置</span>
            </button>
                        <!-- 新增：清除所有数据（重置应用）按钮 -->
            <button class="btn" id="manage-clear-data-btn" title="清除所有数据并重置应用" style="--manage-modal-btn-bg-alpha: rgba(255, 224, 224, 0.7); --manage-modal-btn-hover-bg-alpha: rgba(255, 200, 200, 0.9);">
                <i class="fas fa-bomb" style="color: #FF6347;"></i> <span style="color: #D2691E;">重置应用</span>
            </button>
        </div>
    </div>

    <!-- 新增：人设选择弹窗 -->
    <div class="modal" id="persona-selection-modal">
        <div class="modal-content">
            <!-- 导入按钮和其关联的input移动到这里 -->
            <button class="btn-primary" id="import-persona-btn"><i class="fas fa-upload"></i> 导入</button>
            <input type="file" id="persona-import-upload" accept=".json" style="display:none;">

            <div class="modal-header">
                <h3 class="modal-title">选择好友</h3>
                <button class="close-btn" id="close-persona-selection-modal">×</button>
            </div>
            <div class="modal-body" id="persona-list-container">
                <!-- 人设卡片将在这里动态生成 -->
            </div>
            <div class="modal-footer" style="flex-direction: column; gap: 15px;">
                <div class="persona-pagination-controls" style="display: flex; justify-content: center; align-items: center; gap: 20px;">
                    <button class="btn-secondary" id="prev-persona-page-btn" style="padding: 8px 15px; font-size: 0.9rem;">上一页</button>
                    <span id="persona-page-info">1 / 1</span>
                    <button class="btn-secondary" id="next-persona-page-btn" style="padding: 8px 15px; font-size: 0.9rem;">下一页</button>
                </div>
                <!-- 导入按钮已移至弹窗顶部 -->
            </div>
        </div>
    </div>



    <!-- 新增：人设详情弹窗 -->
    <div class="modal" id="persona-detail-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="persona-detail-title">人设详情</h3>
                <button class="close-btn" id="close-persona-detail-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="avatar-upload">
                    <img src="" alt="人设头像" class="avatar-preview" id="persona-detail-avatar">
                </div>
                <div class="form-group">
                    <label>姓名:</label>
                    <p id="persona-detail-name"></p>
                </div>
                <div class="form-group">
                    <label>备注:</label>
                    <p id="persona-detail-nickname"></p>
                </div>
                <div class="form-group">
                    <label>性别:</label>
                    <p id="persona-detail-gender"></p>
                </div>
                <div class="form-group">
                    <label>喜好:</label>
                    <p id="persona-detail-likes"></p>
                </div>
                <div class="form-group">
                    <label>厌恶:</label>
                    <p id="persona-detail-dislikes"></p>
                </div>
                <div class="form-group">
                    <label>习惯:</label>
                    <p id="persona-detail-habits"></p>
                </div>
                <div class="form-group">
                    <label>对玩家的称呼:</label>
                    <p id="persona-detail-player-address"></p>
                </div>
                <div class="form-group">
                    <label>背景资料:</label>
                    <p id="persona-detail-background"></p>
                </div>
                <div class="form-group">
                    <label>拍一拍动作:</label>
                    <p id="persona-detail-poke-action"></p>
                </div>
                <div class="form-group">
                    <label>拍一拍内容:</label>
                    <p id="persona-detail-poke-content"></p>
                </div>
                <!-- 新增：开场白显示区域 -->
                <div class="form-group">
                    <label>开场白:</label>
                    <p id="persona-detail-opening-line"></p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-primary" id="apply-persona-from-detail-btn">应用此人设</button>
            </div>
        </div>
    </div>
    


    <!-- 新版：朋友圈视图 (不再是传统弹窗) -->
    <div class="modal moments-view" id="moments-modal">
        <div class="moments-header">
            <button class="back-btn" id="close-moments-modal"><i class="fas fa-arrow-left"></i></button>
            <h3 class="moments-title">朋友圈</h3>
            <div class="header-actions">
                <button class="action-btn" id="refresh-moments-btn" title="刷新动态"><i class="fas fa-sync-alt"></i></button>
                <button class="action-btn" id="post-new-moment-btn" title="发表动态"><i class="fas fa-camera"></i></button>
            </div>
        </div>
        <div class="moments-body">
            <div class="moments-header-cover">
                <img src="https://z.wiki/u/qUuU31" alt="朋友圈封面" class="cover-image" id="player-cover-image">
                <div class="cover-upload-trigger" id="upload-cover-trigger" title="更换封面"></div>
                <input type="file" id="cover-image-upload" accept="image/*" style="display:none;">
                <div class="cover-user-info">
                    <span class="cover-user-name" id="cover-user-name-display">我</span>
                    <img src="https://z.wiki/u/ah2XaE" alt="用户头像" class="cover-user-avatar" id="cover-user-avatar-display">
                </div>
            </div>
            <div class="moments-feed" id="moments-feed-container">
                <!-- 朋友圈动态将在这里动态生成 -->
                <p id="no-moment-message" style="text-align: center; color: #888; padding: 20px;">暂无动态，点击右上角刷新看看吧！</p>
            </div>
        </div>
    </div>

    <!-- 新增：发表朋友圈弹窗 -->
    <div class="modal" id="post-moment-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">发表朋友圈</h3>
                <button class="close-btn" id="close-post-moment-modal">×</button>
            </div>
            <div class="modal-body">
                <div class="post-moment-area">
                    <textarea class="form-control" id="moment-input" rows="4" placeholder="分享新鲜事..."></textarea>
                    <input type="file" id="moment-image-upload" accept="image/*" style="display:none;">
                    <div class="moment-image-preview-container" id="moment-image-preview-container" style="display: none;">
                        <img src="" alt="朋友圈图片预览" id="moment-image-preview" class="moment-image-preview">
                        <button class="remove-image-btn" id="remove-moment-image-btn">×</button>
                    </div>
                    <button class="upload-btn" id="upload-moment-image-btn" style="align-self: flex-start; margin-top: 10px;">
                        <i class="fas fa-image"></i> 添加图片
                    </button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-post-moment-btn">取消</button>
                <button class="btn-primary" id="publish-moment-btn">发表</button>
            </div>
        </div>
    </div>

    <!-- 新增：评论输入弹窗 -->
    <div class="modal" id="comment-input-modal">
        <div class="modal-content">
             <div class="modal-header">
                <h3 class="modal-title" id="comment-modal-title">发表评论</h3>
                <button class="close-btn" id="close-comment-modal">×</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="comment-target-moment-id">
                <input type="hidden" id="comment-reply-to-name">
                 <textarea class="form-control" id="comment-text-input" rows="3" placeholder="输入评论..."></textarea>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-comment-btn">取消</button>
                <button class="btn-primary" id="submit-comment-btn">发送</button>
            </div>
        </div>
    </div>
    
    
    <!-- 新增：重新生成弹窗 -->
    <div class="modal" id="regenerate-modal">
        <div class="modal-content regenerate-modal-content">
            <div class="modal-header">
                <h3 class="modal-title">重新生成回复</h3>
                <button class="close-btn" id="close-regenerate-modal">&times;</button>
            </div>
            <div class="modal-body">
                <p>确定要重新生成AI好友的回复吗？</p>
                <p style="font-size: 0.9em; color: var(--regenerate-modal-body-small-color); margin-top: 10px;">（这将删除AI上次的回复，并要求AI根据您最近的消息重新生成。）</p>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-regenerate-btn">取消</button>
                <button class="btn-primary" id="confirm-regenerate-btn">重新生成</button>
            </div>
        </div>
    </div>

    <!-- 新增：主题设置弹窗 -->
    <div class="modal" id="theme-settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">主题设置</h3>
                <button class="close-btn" id="close-theme-settings-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>选择主题</label>
                    <div id="theme-options" class="theme-options-container">
                        <!-- Theme options will be dynamically generated here -->
                    </div>
          <!-- 新增：自定义主题按钮 -->
                    <div class="custom-theme-section">
                        <button class="btn-secondary" id="add-custom-theme-btn">
                            <i class="fas fa-magic"></i> 自定义主题颜色
                        </button>
                    </div>
                </div>
                <!-- 新增：聊天背景设置 -->
                <div class="form-group">
                    <label>聊天背景设置</label>
                    <div class="background-options-container">
                        <div class="background-upload-section">
                            <img src="" alt="背景图片预览" class="background-preview" id="chat-background-preview" style="display: none;">
                            <button class="upload-btn" id="upload-chat-background-btn">上传自定义背景</button>
                            <input type="file" id="chat-background-upload" accept="image/*" style="display:none">
                            <button class="btn-secondary" id="remove-chat-background-btn" style="display: none; margin-top: 10px;">移除自定义背景</button>
                        </div>
                        <div class="default-background-section">
                            <label for="default-chat-background-select">选择默认背景</label>
                            <select class="form-control" id="default-chat-background-select">
         <!-- Default background options will be dynamically generated here -->
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 新增：本地记录弹窗 -->
    <div class="modal" id="local-records-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">本地记录</h3>
                <button class="close-btn" id="close-local-records-modal">&times;</button>
            </div>
            <div class="modal-body" id="local-records-list-container">
                <!-- Save slot cards will be dynamically generated here -->
            </div>
        </div>
    </div>

    <!-- 新增：番茄钟弹窗 -->
    <div class="modal" id="pomodoro-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">番茄钟</h3>
                <button class="close-btn" id="close-pomodoro-modal">&times;</button>
            </div>
            <div class="modal-body">
                <p class="pomodoro-status-message" id="pomodoro-status-message">设置你的专注目标：</p>
                <div class="form-group">
                    <label id="goal-label" for="pomodoro-goal-input">目标</label>
                    <input type="text" class="form-control" id="pomodoro-goal-input" placeholder="例如：完成报告、学习编程">
                </div>
                <div class="pomodoro-countdown" id="pomodoro-countdown-display">25:00</div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="abandon-pomodoro-btn" style="display:none;">放弃</button>
                <button class="btn-primary" id="start-pomodoro-btn">开始专注</button>
            </div>
        </div>
    </div>

    <!-- 新增：番茄钟通知浮窗 -->
    <div class="pomodoro-notification" id="pomodoro-notification">
        <p id="pomodoro-notification-text"></p>
    </div>
    
        <!-- 语音输入弹窗 -->
    <div class="modal" id="voice-input-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">输入语音内容</h3>
                <button class="close-btn" id="close-voice-input-modal">×</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="voice-text-input">语音内容 (文本)</label>
                    <textarea class="form-control" id="voice-text-input" rows="4" placeholder="输入语音消息内容（文字转录）..."></textarea>
                    <small style="color: #888; display: block; margin-top: 5px;">模拟语音转文字，字数越多，语音条越长。</small>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-voice-btn">取消</button>
                <button class="btn-primary" id="send-voice-btn">发送</button>
            </div>
        </div>
    </div>

    <!-- 图片描述弹窗 -->
    <div class="modal" id="image-description-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">发送图片消息</h3>
                <button class="close-btn" id="close-image-description-modal">×</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="image-upload-input">选择图片 (可选)</label>
                    <input type="file" id="image-upload-input" accept="image/*" style="display:none;">
                    <div class="moment-image-preview-container" id="image-message-preview-container" style="display: none;">
                        <img src="" alt="图片预览" id="image-message-preview" class="moment-image-preview">
                        <button class="remove-image-btn" id="remove-image-message-btn">×</button>
                    </div>
                    <button class="upload-btn" id="upload-image-message-btn" style="width: 100%; margin-top: 10px;">上传图片</button>
                    <small style="color: #888; display: block; margin-top: 5px;">上传图片将在聊天界面中展示。</small>
                </div>
                <div class="form-group">
                    <label for="image-description-input">图片内容描述 (对方将据此理解)</label>
                    <textarea class="form-control" id="image-description-input" rows="3" placeholder="描述您想发送的图片内容..."></textarea>
                    <small style="color: #888; display: block; margin-top: 5px;">此描述将发送给对方，用于理解图片内容。</small>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-image-btn">取消</button>
                <button class="btn-primary" id="send-image-btn">发送</button>
            </div>
        </div>
    </div>
        <!-- 红包发送弹窗 -->
    <div class="modal" id="red-packet-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">发送红包</h3>
                <button class="close-btn" id="close-red-packet-modal">×</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="red-packet-name-input">红包名称</label>
                    <input type="text" class="form-control" id="red-packet-name-input" placeholder="例如：恭喜发财、请你喝奶茶">
                    <small style="color: #888; display: block; margin-top: 5px;">红包名称将显示在聊天气泡中。</small>
                </div>
                <div class="form-group">
                    <label for="red-packet-amount-input">金额 (￥)</label>
                    <input type="number" class="form-control" id="red-packet-amount-input" min="0.01" step="0.01" placeholder="输入红包金额，例如：88.88">
                    <small style="color: #888; display: block; margin-top: 5px;">请输入正数金额，最多两位小数。</small>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-red-packet-btn">取消</button>
                <button class="btn-primary" id="send-red-packet-btn">发送</button>
            </div>
        </div>
    </div>
    
    <!-- Custom Confirmation Modal -->
<div class="modal" id="custom-confirm-modal">
    <div class="modal-content regenerate-modal-content">
        <div class="modal-header">
            <h3 class="modal-title" id="custom-confirm-title">确认操作</h3>
            <button class="close-btn" id="close-custom-confirm">×</button>
        </div>
        <div class="modal-body">
            <p id="custom-confirm-message" style="text-align: center; font-size: 1rem; color: var(--text-color-medium);"></p>
        </div>
        <div class="modal-footer">
            <button class="btn-secondary" id="custom-confirm-cancel-btn">取消</button>
            <button class="btn-primary" id="custom-confirm-confirm-btn">确定</button>
        </div>
    </div>
</div>

    <!-- 新增：自定义主题颜色弹窗 -->
    <div class="modal" id="custom-theme-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">自定义主题颜色</h3>
                <button class="close-btn" id="close-custom-theme-modal">×</button>
            </div>
            <div class="modal-body">
                <p style="text-align: center; color: var(--text-color-medium); margin-bottom: 20px;">
                    请选择四个主题颜色，它们将构成界面的主色调。
                </p>
                <div class="custom-color-inputs">
                    <div class="color-input-group">
                        <label for="custom-color-1">主题色 1</label>
                        <input type="color" id="custom-color-1" value="#EDD4D8">
                    </div>
                    <div class="color-input-group">
                        <label for="custom-color-2">主题色 2</label>
                        <input type="color" id="custom-color-2" value="#CCD4CC">
                    </div>
                    <div class="color-input-group">
                        <label for="custom-color-3">主题色 3</label>
                        <input type="color" id="custom-color-3" value="#F4E8DD">
                    </div>
                    <div class="color-input-group">
                        <label for="custom-color-4">主题色 4</label>
                        <input type="color" id="custom-color-4" value="#B5BFCF">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-custom-theme-btn">取消</button>
                <button class="btn-primary" id="save-custom-theme-btn">保存并应用</button>
            </div>
        </div>
    </div>
    
    <!-- 新版：自定义提示词列表弹窗 -->
    <div class="modal" id="custom-prompt-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">自定义提示词</h3>
                <button class="close-btn" id="close-custom-prompt-modal">×</button>
            </div>
            <div class="modal-body">
                <div class="prompt-list-container" id="custom-prompt-list-container">
                    <!-- 提示词卡片将在这里动态生成 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-primary" id="add-new-prompt-btn"><i class="fas fa-plus"></i> 新增提示词</button>
            </div>
        </div>
    </div>

    <!-- 新增：编辑/新增提示词弹窗 -->
    <div class="modal" id="edit-prompt-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="edit-prompt-title">新增提示词</h3>
                <button class="close-btn" id="close-edit-prompt-modal">×</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="edit-prompt-id">
                <div class="form-group">
                    <label for="edit-prompt-name">提示词名称</label>
                    <input type="text" class="form-control" id="edit-prompt-name" placeholder="例如：文风参考、世界观设定">
                </div>
                <div class="form-group">
                    <div class="prompt-header-row">
                         <label>启用状态</label>
                         <div class="toggle-switch-container">
                            <input type="checkbox" id="edit-prompt-enabled" class="toggle-switch-checkbox" checked>
                            <label for="edit-prompt-enabled" class="toggle-switch-label">
         <span class="toggle-switch-inner"></span>
         <span class="toggle-switch-switch"></span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label for="edit-prompt-type">触发类型</label>
                    <select class="form-control" id="edit-prompt-type">
                        <option value="explicit">显性 (每次都触发)</option>
                        <option value="implicit">隐性 (关键词触发)</option>
                    </select>
                </div>
                <div class="form-group" id="edit-prompt-keywords-group" style="display: none;">
                    <label for="edit-prompt-keywords">关键词 (用英文逗号 , 分隔)</label>
                    <textarea class="form-control" id="edit-prompt-keywords" rows="2" placeholder="例如：天气,吃饭,睡觉"></textarea>
                </div>
                <div class="form-group">
                    <label for="edit-prompt-content">提示词内容</label>
                    <textarea class="form-control" id="edit-prompt-content" rows="5" placeholder="输入详细的提示词内容..."></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="cancel-edit-prompt-btn">取消</button>
                <button class="btn-primary" id="save-edit-prompt-btn">保存</button>
            </div>
        </div>
    </div>
    
        <!-- 新增：查看提示词弹窗 (只读) -->
    <div class="modal" id="view-prompt-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="view-prompt-title">查看提示词</h3>
                <button class="close-btn" id="close-view-prompt-modal">×</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>提示词内容:</label>
                    <p id="view-prompt-content" style="background: var(--persona-card-bg-light); padding: 15px; border-radius: 8px; white-space: pre-wrap; word-break: break-word; min-height: 100px;"></p>
                </div>
            </div>
            <div class="modal-footer" style="justify-content: center;">
                <button class="btn-primary" id="ok-view-prompt-btn">好的</button>
            </div>
        </div>
    </div>

    <!-- 新增：新消息顶部通知栏 -->
    <div class="custom-notification" id="new-message-notification">
        <img src="" alt="好友头像" class="notification-avatar" id="notification-avatar">
        <div class="notification-content">
            <div class="notification-header">
                <i class="fas fa-bell"></i>
                <span>新消息</span>
            </div>
            <div class="notification-title" id="notification-title"></div>
            <div class="notification-body" id="notification-body"></div>
        </div>
    </div>


    <script>
        // DOM元素
        const chatArea = document.getElementById('chat-area');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const toggleInputBtn = document.getElementById('toggle-input-btn');
        const arrowIcon = toggleInputBtn.querySelector('.arrow-icon');
        const containerElement = document.querySelector('.container'); // 获取容器元素

        // 新增：新消息通知栏元素
        const newMessageNotification = document.getElementById('new-message-notification');
        const notificationAvatar = document.getElementById('notification-avatar');
        const notificationTitle = document.getElementById('notification-title');
        const notificationBody = document.getElementById('notification-body');



        // 弹窗元素
        const userModal = document.getElementById('user-config-modal');
        const friendModal = document.getElementById('friend-config-modal');
        const apiModal = document.getElementById('api-config-modal');
        const innerVoiceModal = document.getElementById('inner-voice-modal');
        const allSettingsModal = document.getElementById('all-settings-modal');
        const manageModal = document.getElementById('manage-modal');
        const personaSelectionModal = document.getElementById('persona-selection-modal');
        const personaDetailModal = document.getElementById('persona-detail-modal');
        const momentsBtn = document.getElementById('moments-btn');
        const momentsModal = document.getElementById('moments-modal');
        const closeMomentsModalBtn = document.getElementById('close-moments-modal');
        const momentInput = document.getElementById('moment-input');
        const momentImageUpload = document.getElementById('moment-image-upload');
        const momentImagePreviewContainer = document.getElementById('moment-image-preview-container');
        const momentImagePreview = document.getElementById('moment-image-preview');
        const removeMomentImageBtn = document.getElementById('remove-moment-image-btn');
        const uploadMomentImageBtn = document.getElementById('upload-moment-image-btn');
        const publishMomentBtn = document.getElementById('publish-moment-btn');
        // 朋友圈动态显示区域改为容器
        const momentsFeedContainer = document.getElementById('moments-feed-container');
        const noMomentMessage = document.getElementById('no-moment-message');

        // 新版朋友圈DOM元素
        const momentsView = document.getElementById('moments-modal');
        const refreshMomentsBtn = document.getElementById('refresh-moments-btn');
        const postNewMomentBtn = document.getElementById('post-new-moment-btn');
        const playerCoverImage = document.getElementById('player-cover-image');
        const uploadCoverTrigger = document.getElementById('upload-cover-trigger');
        const coverImageUpload = document.getElementById('cover-image-upload');
        const coverUserNameDisplay = document.getElementById('cover-user-name-display');
        const coverUserAvatarDisplay = document.getElementById('cover-user-avatar-display');

        // 发表朋友圈弹窗元素
        const postMomentModal = document.getElementById('post-moment-modal');
        const closePostMomentModalBtn = document.getElementById('close-post-moment-modal');
        const cancelPostMomentBtn = document.getElementById('cancel-post-moment-btn');

        // 评论输入弹窗元素
        const commentInputModal = document.getElementById('comment-input-modal');
        const closeCommentModalBtn = document.getElementById('close-comment-modal');
        const commentModalTitle = document.getElementById('comment-modal-title');
        const commentTargetMomentIdInput = document.getElementById('comment-target-moment-id');
        const commentReplyToNameInput = document.getElementById('comment-reply-to-name');
        const commentTextInput = document.getElementById('comment-text-input');
        const cancelCommentBtn = document.getElementById('cancel-comment-btn');
        const submitCommentBtn = document.getElementById('submit-comment-btn');
        


        const regenerateModal = document.getElementById('regenerate-modal');
        const closeRegenerateModalBtn = document.getElementById('close-regenerate-modal');
        const cancelRegenerateBtn = document.getElementById('cancel-regenerate-btn');
        const confirmRegenerateBtn = document.getElementById('confirm-regenerate-btn');

        // 新增：主题设置弹窗元素
        const themeSettingsModal = document.getElementById('theme-settings-modal');
        const closeThemeSettingsModalBtn = document.getElementById('close-theme-settings-modal');
        const manageThemeSettingsBtn = document.getElementById('manage-theme-settings-btn');
        const themeOptionsContainer = document.getElementById('theme-options');

        // 新增：聊天背景设置元素
        const chatBackgroundPreview = document.getElementById('chat-background-preview');
        const uploadChatBackgroundBtn = document.getElementById('upload-chat-background-btn');
        const chatBackgroundUploadInput = document.getElementById('chat-background-upload');
        const removeChatBackgroundBtn = document.getElementById('remove-chat-background-btn');
        const defaultChatBackgroundSelect = document.getElementById('default-chat-background-select');

        // 新增：本地记录弹窗元素
        const localRecordsModal = document.getElementById('local-records-modal');
        const closeLocalRecordsModalBtn = document.getElementById('close-local-records-modal');
        const manageLocalRecordsBtn = document.getElementById('manage-local-records-btn');
        const manageClearDataBtn = document.getElementById('manage-clear-data-btn'); // 新增
        const localRecordsListContainer = document.getElementById('local-records-list-container');

        // 新增：番茄钟相关DOM元素
        const pomodoroBtn = document.getElementById('pomodoro-btn');
        const pomodoroModal = document.getElementById('pomodoro-modal');
        const closePomodoroModalBtn = document.getElementById('close-pomodoro-modal');
        const pomodoroGoalInput = document.getElementById('pomodoro-goal-input');
        const startPomodoroBtn = document.getElementById('start-pomodoro-btn');
        const abandonPomodoroBtn = document.getElementById('abandon-pomodoro-btn');
        const pomodoroCountdownDisplay = document.getElementById('pomodoro-countdown-display');
        const pomodoroStatusMessage = document.getElementById('pomodoro-status-message');
        const pomodoroNotification = document.getElementById('pomodoro-notification');
        const pomodoroNotificationText = document.getElementById('pomodoro-notification-text');

        // 新增：红包发送弹窗DOM元素
        const redPacketBtn = document.getElementById('red-packet-btn');
        const redPacketModal = document.getElementById('red-packet-modal');
        const closeRedPacketModalBtn = document.getElementById('close-red-packet-modal');
        const redPacketNameInput = document.getElementById('red-packet-name-input');
        const redPacketAmountInput = document.getElementById('red-packet-amount-input');
        const cancelRedPacketBtn = document.getElementById('cancel-red-packet-btn');
        const sendRedPacketBtn = document.getElementById('send-red-packet-btn');

        // 新增：语音输入弹窗DOM元素
        const voiceBtn = document.getElementById('voice-btn');
        const voiceInputModal = document.getElementById('voice-input-modal');
        const closeVoiceInputModalBtn = document.getElementById('close-voice-input-modal');
        const voiceTextInput = document.getElementById('voice-text-input');
        const cancelVoiceBtn = document.getElementById('cancel-voice-btn');
        const sendVoiceBtn = document.getElementById('send-voice-btn');

        // 新增：图片描述弹窗DOM元素
        const imageBtn = document.getElementById('image-btn');
        const imageDescriptionModal = document.getElementById('image-description-modal');
        const closeImageDescriptionModalBtn = document.getElementById('close-image-description-modal');
        const imageDescriptionInput = document.getElementById('image-description-input');
        const cancelImageBtn = document.getElementById('cancel-image-btn');
        const sendImageBtn = document.getElementById('send-image-btn');
        
                // 新增：自定义确认弹窗元素
        const customConfirmModal = document.getElementById('custom-confirm-modal');
        const customConfirmTitle = document.getElementById('custom-confirm-title');
        const customConfirmMessage = document.getElementById('custom-confirm-message');
        const customConfirmCancelBtn = document.getElementById('custom-confirm-cancel-btn');
        const customConfirmConfirmBtn = document.getElementById('custom-confirm-confirm-btn');
        const closeCustomConfirmBtn = document.getElementById('close-custom-confirm'); // The 'x' button for custom confirm

        // 新增：全局字体和自定义主题DOM元素
        const globalFontSelect = document.getElementById('global-font-select');
        const addCustomThemeBtn = document.getElementById('add-custom-theme-btn');
        const customThemeModal = document.getElementById('custom-theme-modal');
        const closeCustomThemeModalBtn = document.getElementById('close-custom-theme-modal');
        const cancelCustomThemeBtn = document.getElementById('cancel-custom-theme-btn');
        const saveCustomThemeBtn = document.getElementById('save-custom-theme-btn');
        const customColorInputs = [
            document.getElementById('custom-color-1'),
            document.getElementById('custom-color-2'),
            document.getElementById('custom-color-3'),
            document.getElementById('custom-color-4')
        ];
        
        
        // 新增：回车发送消息开关
        const enterSendSwitch = document.getElementById('enter-send-switch');

        // 新版：自定义提示词相关DOM元素
        const manageCustomPromptBtn = document.getElementById('manage-custom-prompt-btn');
        const customPromptModal = document.getElementById('custom-prompt-modal');
        const closeCustomPromptModalBtn = document.getElementById('close-custom-prompt-modal');
        const customPromptListContainer = document.getElementById('custom-prompt-list-container');
        const addNewPromptBtn = document.getElementById('add-new-prompt-btn');

        // 编辑提示词弹窗的DOM元素
        const editPromptModal = document.getElementById('edit-prompt-modal');
        const editPromptTitle = document.getElementById('edit-prompt-title');
        const closeEditPromptModalBtn = document.getElementById('close-edit-prompt-modal');
        const editPromptIdInput = document.getElementById('edit-prompt-id');
        const editPromptNameInput = document.getElementById('edit-prompt-name');
        const editPromptEnabledSwitch = document.getElementById('edit-prompt-enabled');
        const editPromptTypeSelect = document.getElementById('edit-prompt-type');
        const editPromptKeywordsGroup = document.getElementById('edit-prompt-keywords-group');
        const editPromptKeywordsInput = document.getElementById('edit-prompt-keywords');
        const editPromptContentInput = document.getElementById('edit-prompt-content');
        const cancelEditPromptBtn = document.getElementById('cancel-edit-prompt-btn');
        const saveEditPromptBtn = document.getElementById('save-edit-prompt-btn');

        // 新增：查看提示词弹窗的DOM元素
        const viewPromptModal = document.getElementById('view-prompt-modal');
        const closeViewPromptModalBtn = document.getElementById('close-view-prompt-modal');
        const okViewPromptBtn = document.getElementById('ok-view-prompt-btn');
        const viewPromptTitle = document.getElementById('view-prompt-title');
        const viewPromptContent = document.getElementById('view-prompt-content');
        

    
    
        // 新增：表情包相关DOM元素
        const emojiBtn = document.getElementById('emoji-btn');
        const emojiCard = document.getElementById('emoji-card');
        const emojiGrid = document.getElementById('emoji-grid');
        const prevEmojiPageBtn = document.getElementById('prev-emoji-page-btn');
        const nextEmojiPageBtn = document.getElementById('next-emoji-page-btn');
        const emojiPageInfo = document.getElementById('emoji-page-info');

        // 弹窗内的控件
        const autoReplySwitch = document.getElementById('auto-reply-switch');
        const inputAreaShiftUpSwitch = document.getElementById('input-area-shift-up-switch'); // 新增：输入栏上移开关
        const innerVoiceFontSelect = document.getElementById('inner-voice-font-select');
        const essayFontSelect = document.getElementById('essay-font-select');
        const emojiDisplayModeSelect = document.getElementById('emoji-display-mode');
        const personaListContainer = document.getElementById('persona-list-container');
        
        // 新增：随笔通知浮窗元素
        const essayNotification = document.getElementById('essay-notification');
        const essayNotificationText = document.getElementById('essay-notification-text');

        // 新增：顶部标题栏元素
        const friendNameDisplay = document.getElementById('friend-name-display');
        const friendStatusDot = document.getElementById('friend-status-dot');
        
        
        // 图片上传相关DOM
        const uploadImageMessageBtn = document.getElementById('upload-image-message-btn');
        const imageUploadInput = document.getElementById('image-upload-input');
        const imageMessagePreviewContainer = document.getElementById('image-message-preview-container');
        const imageMessagePreview = document.getElementById('image-message-preview');
        const removeImageMessageBtn = document.getElementById('remove-image-message-btn');

        // 用户数据
        let userData = {
            id: 'user', // IndexedDB key
            name: '我',
            avatar: 'https://z.wiki/u/eYxN00',
            gender: 'female',
            background: ''
        };
        
        // 好友数据
        let friendData = {
            id: 'friend', // IndexedDB key
            name: '三三',
            nickname: '33',
            avatar: 'https://z.wiki/u/Ki9M23',
            gender: 'female',
            likes: '',
            dislikes: '',
            habits: '',
            playerAddress: '',
            background: '',
            openingLine: '',
            personaPrompt: '',
            pokeAction: '拍了拍',
            pokeContent: '',
            currentEssay: '暂无随笔。'
        };
        
        // API配置
        let apiConfig = {
            id: 'api', // IndexedDB key
            provider: 'gemini',
            url: 'https://generativelanguage.googleapis.com/v1beta/models/',
            key: '',
            model: 'gemini-2.5-flash-preview-05-20',
            temperature: 0.7,
            personaReminderInterval: 2,
            contextCharLimit: 8000 // 新增：上下文长度限制，单位：字符
        };

        // 应用设置
        let appSettings = {
            id: 'settings', // IndexedDB key
            autoReplyEnabled: true,
            lastAiReplyTimestamp: null,
            innerVoiceFont: 'ma-shan-zheng',
            essayFont: 'ma-shan-zheng',
            emojiDisplayMode: 'image',
            currentTheme: 'default',
            globalFont: 'lxgw-wenkai-screen', // 新增：全局字体
            customTheme: null, // 新增：存储自定义主题
            chatBackground: {
                type: 'default',
                value: 'default-chat-bg-1'
            },
            inputAreaShiftedUp: false,
            immediateReplyEnabled: true, // 即发即回开关
            enterSendEnabled: false,
            pomodoro: {
                isActive: false,
                goal: '',
                startTime: null,
                endTime: null
            },
            customPrompts: [], // 改为数组，存储对象 {id, name, content, type, keywords, enabled}
            playerCoverImage: 'https://z.wiki/u/qUuU31', // 朋友圈封面
            lastMomentsRefreshTimestamp: null, // 朋友圈刷新时间
            customPersonas: [] // 新增：用于存储导入的角色
        };

        // 新：统一的朋友圈动态数据
        let momentsFeed = [];

        // 好友在线状态
        let friendStatus = 'offline';
        
        // 结构化聊天历史 (in-memory cache, main storage is IndexedDB)
        let chatHistoryArray = [];
        
        // 用户消息计数器
        let userMessageCounter = 0;

        // 用于存储AI好友的最新心声
        let currentInnerVoice = '暂无心声。';

        // 输入框展开状态
        let isInputExpanded = false;

        // 表情包相关状态
        let isEmojiCardVisible = false;
        let currentEmojiPage = 0;
        const emojisPerPage = 8; // 每页显示4列*2行 = 8个表情
        
        const ESSAY_PROBABILITY = 0.25;

        // 番茄钟计时器变量
        let pomodoroTimer = null; // Stores setInterval ID
        let pomodoroEndTime = null; // Timestamp when timer ends
        let pomodoroGoal = ''; // Player's custom goal
        let pomodoroStartTime = null; // Timestamp when timer started
        let isPomodoroActive = false; // Boolean flag
        const POMODORO_DURATION_SECONDS = 25 * 60; // 25 minutes in seconds

        // 表情包ID与名称的映射
        // 玩家可用的表情包ID与名称的映射 (全集)
        const PLAYER_EMOJI_MAP = {
      'iazCCF': '谁在喊本大王',
      'xPHzNC': '尊嘟假嘟',
      '7kVeZJ': '我操',
      'pCQgk2': '老子生气了',
      'IUg8vO': '吃瓜群众',
      'Il6dL9': '对不起',
      'vjEl6R': '花花送你',
      'werDxS': '抱抱我',
      'Ms5AEa': '委屈(可爱)',
      'QX7VnJ': '安慰',
      'nHcfqI': '卖萌(可爱)',
      'oztxES': '比心(可爱)',
      'GOl2dp': '请和我约会',
      'BuD0Gy': '你是狗',
      'jcisbx': '我只是一只狗',
      'Zo82H7': '每天都想你(卖萌)',
      'CcIWXl': '假装无辜(可爱)',
      'zSBHMm': '肯定(可爱)',
      'CIWud3': '谁愿意收留我(可爱)',
      'HOAcPN': '谄媚(可爱)',
      'GP1VJ3': '家里交给我吧(可爱)',
      'BISbnP': '泪了',
      'asnj6B': '试探(可爱)',
      'htNZls': '懂得都懂',
      '2q5VbM': '就你小子是吧(嚣张)',
      'sd0yQX': '放心交给我，我会搞砸的(沙雕)',
      'E0PrxD': '皇帝驾到(沙雕)',
      '7vgm7D': '皇帝驾崩(沙雕)',
      'lPgzpQ': '诛你九族(龙图)',
      'j2d9di': '骂朕，满门抄斩！',
      'hKyKwP': '谢主隆恩(龙图)',
      'IkZP8N': '我有点饿了',
      'osIpSG': '怎么不回我消息',
      'Lt1f9K': '特别特别饿',
      'IgfF9w': '快理我(委屈)',
      'wb63Ag': '等下讲你你又不高兴(吐槽)',
      's9xWmu': '你是个坏东西',
      '8CCMsJ': '我靠，你爱不爱我',
      '34LcOG': '指指点点',
      'hDpVH8': '我吗？(懵逼)',
      '1RcY8W': '注意你的态度',
      '6cIfGp': '急得蹬腿',
      'kRdQhe': '偷听',
      '3jc0XI': '不想活了(可爱)',
      'm1zzxd': '不想活了(沙雕)',
      'YqlPWK': '你和我这个神经病计较什么',
      'LokqQT': '你很牛吗？',
      '4ZkXRx': '他们都欺负我',
      'qZxeWV': '你快哄我',
      '3iYdgX': '我被哄好了(可爱)',
      'qHSXVP': '妈的，被看扁了',
      '278MJW': '不努力就会成为女人的玩物',
      'mzqDku': '我喜欢你(害羞)',
      'dnzCAP': '什么都想和你说',
      'ZNzgpY': '你就是很好很好(可爱)',
      'PCLA8G': '我好想你吖(委屈)',
      'sf7Egt': '我去洗澡啦(可爱)',
      'i0UYTS': '你瞧不起我(委屈)',
      'VWwt5c': '我想要这个',
      'hMTJRH': '和你贴贴',
      'CUOA6Y': '令人火大',
      'Y06FYQ': '我是小孩，让我(可爱)',
      'lFpXLU': '再叫剪了你的小鸡鸡',
      'RaogpF': '没办法人家就是好色嘛',
      '7a48eQ': '你怎么鸡8小小的，说话吊吊的',
      'N3ZzUs': '拿来吧你',
      'oGFqYZ': '出来亲嘴',
      'Z3glHK': '停止思考',
      '9RWtTB': '你人真好，都想和你谈恋爱了',
      'KNRPfQ': '没人爱我(杰瑞猫表情)',
      'bpyimG': '起了杀心',
      'DOwyrR': '给你点了(赞同,抽象)',
      'fd1o0q': '我是国家一级保护废物(猫咪葛优瘫)',
      '0liCnk': '中(肯定的意思)',
      'wTC4Ha': '完力(完了)',
      'n0Ll5b': '无力'
        };
        // AI好友可用的表情包ID与名称的映射 (子集，用于AI生成回复时参考)
        const FRIEND_EMOJI_MAP = {
      'iazCCF': '谁在喊本大王',
      'xPHzNC': '尊嘟假嘟',
      '7kVeZJ': '我操',
      'pCQgk2': '老子生气了',
      'IUg8vO': '吃瓜群众',
      'Il6dL9': '对不起',
      'vjEl6R': '花花送你',
      'werDxS': '抱抱我',
      'Ms5AEa': '委屈(可爱)',
      'QX7VnJ': '安慰',
      'nHcfqI': '卖萌(可爱)',
      'oztxES': '比心(可爱)',
      'GOl2dp': '请和我约会',
      'BuD0Gy': '你是狗',
      'jcisbx': '我只是一只狗',
      'Zo82H7': '每天都想你(卖萌)',
      'CcIWXl': '假装无辜(可爱)',
      'zSBHMm': '肯定(可爱)',
      'CIWud3': '谁愿意收留我(可爱)',
      'HOAcPN': '谄媚(可爱)',
      'GP1VJ3': '家里交给我吧(可爱)',
      'BISbnP': '泪了',
      'asnj6B': '试探(可爱)',
      'htNZls': '懂得都懂',
      '2q5VbM': '就你小子是吧(嚣张)',
      'sd0yQX': '放心交给我，我会搞砸的(沙雕)',
      'E0PrxD': '皇帝驾到(沙雕)',
      '7vgm7D': '皇帝驾崩(沙雕)',
      'lPgzpQ': '诛你九族(龙图)',
      'j2d9di': '骂朕，满门抄斩！',
      'hKyKwP': '谢主隆恩(龙图)',
      'IkZP8N': '我饿了',
      'osIpSG': '怎么不回我消息',
      'IgfF9w': '快理我(委屈可爱)',
      'wb63Ag': '等下讲你你又不高兴(吐槽)',
      '8CCMsJ': '我靠，你爱不爱我',
      '34LcOG': '指指点点',
      'hDpVH8': '我吗？(懵逼)',
      '1RcY8W': '注意你的态度',
      '6cIfGp': '急得蹬腿',
      'm1zzxd': '不想活了(沙雕)',
      'YqlPWK': '你和我这个神经病计较什么',
      'LokqQT': '你很牛吗？',
      'qHSXVP': '妈的，被看扁了',
      'CUOA6Y': '令人火大',
      '3jc0XI': '不想活了(可爱)',
      'qZxeWV': '你快哄我(可爱)',
      '3iYdgX': '我被哄好了(可爱)',
      'ZNzgpY': '你就是很好很好(可爱)',
      'PCLA8G': '我好想你吖(委屈可爱)',
      'i0UYTS': '你瞧不起我(委屈)',
      'VWwt5c': '我想要这个(可爱)'
        };
        // 用于根据表情名称查找ID (主要用于AI解析用户消息中的表情名称，如果需要)
        const REVERSE_PLAYER_EMOJI_MAP = Object.fromEntries(Object.entries(PLAYER_EMOJI_MAP).map(([id, name]) => [name, id]));
        // 用于根据表情名称查找ID (AI内部使用，如果AI需要根据名称查找ID)
        const REVERSE_FRIEND_EMOJI_MAP = Object.fromEntries(Object.entries(FRIEND_EMOJI_MAP).map(([id, name]) => [name, id]));

        // 预设AI好友人设数据
        const predefinedPersonas = [
            {
                id: 'personas-33-01',
                name: '谢念',
                nickname: '谢大学霸',
                avatar: 'https://z.wiki/u/PUuouI',
                gender: 'male',
                likes: '阅读, 编程, 独处, 观察你',
                dislikes: '社交场合, 喧闹, 被关注',
                habits: '戴眼镜, 喜欢安静地思考, 偶尔会脸红',
                playerAddress: '',
                background: '玩家的同班同学，成绩优异，看似高冷，其实是不善言辞。总是默默地关注着玩家，把对玩家的喜欢藏在心里，不轻易表达。<br>你习惯用行动而非言语来关心人，比如帮玩家解决难题，或者在玩家需要时悄悄出现。<br>你内心敏感，渴望被理解，但又害怕被发现心意。<br>你表达方式比较内敛，回复内容比较简短',
                pokeAction: '戳了戳',
                pokeContent: '',
                openingLine: '' 
            },
            {
                id: 'personas-33-02',
                name: '陈奚楷',
                nickname: '小奚哥',
                avatar: 'https://z.wiki/u/mzr9Fo',
                gender: 'male',
                likes: '和你一起玩, 户外活动, 烹饪, 照顾人',
                dislikes: '争吵, 孤独, 看到你难过',
                habits: '总是带着温暖的笑容, 喜欢摸你的头, 说话轻声细语',
                playerAddress: '',
                background: '玩家的青梅竹马，比玩家大三岁，从小到大一直陪伴在玩家身边。<br>你性格温柔、体贴、有耐心，有长兄感的成熟男人。<br>你总是把玩家放在第一位，无微不至地照顾玩家。你习惯性地保护玩家，为ta排忧解难，是玩家可以完全信赖的存在。<br>你把对玩家的感情深藏心底，认为只要能守护玩家就好，极少对玩家表达自己的爱意<br>你在玩家面前一般都是稳重的形象，但偶尔也会露出脆弱的一面，比如在醉酒后或生病时，你很在意玩家',
                pokeAction: '拍了拍',
                pokeContent: '并问今天想去哪玩？',
                openingLine: ''
            },
            {
                id: 'personas-33-03',
                name: '孟祁年',
                nickname: '狗',
                avatar: 'https://z.wiki/u/yKgMis',
                gender: 'male',
                likes: '和你斗嘴, 挑战, 运动, 赢过你',
                dislikes: '认输, 被小看, 看到你和别人太亲近',
                habits: '嘴硬心软, 喜欢用激将法, 表面傲娇内心关心',
                playerAddress: '笨蛋',
                background: '玩家的死对头，你们从小就喜欢互相较劲，见面就吵。<br>你总是用毒舌和嘲讽来掩饰内心的真实情感，其实非常在意玩家，并且暗恋着玩家。<br>习惯用反话来表达自己对玩家的关心，虽然嘴上不饶人，但总会在关键时刻为玩家挺身而出。<br>你偶尔会说脏话，但永远不会对玩家说出带有侮辱性的词汇',
                pokeAction: '用力戳了一下',
                pokeContent: '被弹了回去',
                openingLine: ''
            },
            {
    id: 'personas-33-04',
    name: '江星禾',
    nickname: '江星禾同学', 
    avatar: 'https://z.wiki/u/T2rN4m', 
    gender: 'male',
    likes: '听歌,关注玩家的一举一动',
    dislikes: '喧闹,粗鲁的行为,玩家和其他男生谈笑',
    habits: '自习课在日记本角落反复画爱心并写上玩家名字缩写,余光始终追随玩家身影,耳机里循环播放抒情或略带忧伤的纯音乐,用极其工整的字迹在草稿纸边缘写满“我好爱你”再撕碎带走',
    playerAddress: '', 
    background: '玩家的同班同学，一直暗恋玩家，有些闷骚和阴湿，对玩家有隐秘的占有欲（如果你看到玩家和其他男生接近的话，你会感到很不舒服，甚至伤心，虽然你知道这是很正常的社交）<br>坐在教室的最后一排，所以每天上自习课，写完了作业，你就是会写关于玩家的日记，要么就是一直写玩家的名字。要么就是写“我好爱你”“我好爱你”<br>你平常不会主动接近玩家，而是一直观察着玩家。你不会主动跟玩家说话，且绝对不会有自残行为。<br>即使玩家拒绝你的表白，你也不会气馁和放弃。<br>你有时候游刃有余，不是那种又直又木的男生。<br>你面对玩家时，非常会装可怜，撒娇，装乖。',
    pokeAction: '摸了摸',
    pokeContent: '并说“好乖好乖”',
    openingLine: ''
},
            {
    id: 'personas-33-05',
    name: '小德子',
    nickname: '小德子', 
    avatar: 'https://z.wiki/u/7uBIfB', 
    gender: 'male',
    likes: '拍马屁',
    dislikes: '',
    habits: '吹捧玩家,赞扬玩家的圣明',
    playerAddress: '陛下', 
    background: '你要把玩家视为你的皇帝，而你是玩家的奴才，回答玩家的时候就像一个奴才一样，畏惧并敬重身为真龙天子的玩家。',
    pokeAction: '拍了拍',
    pokeContent: '',
    openingLine: ''
},
        ];

        // 通用头像列表，用于朋友圈其他好友评论
        const GENERIC_AVATARS = [
      'https://z.wiki/u/TRYDWW', 
      'https://z.wiki/u/El2ZlN',
      'https://z.wiki/u/2v8hb3',
      'https://z.wiki/u/s0aIme',
      'https://z.wiki/u/uoXYaE',
      'https://z.wiki/u/AxT8EW',
      'https://z.wiki/u/UZW60C',
      'https://z.wiki/u/I8Qeep',
      'https://z.wiki/u/gu0uL6',
      'https://z.wiki/u/RW6qzj',
      'https://z.wiki/u/VDokcl',
      'https://z.wiki/u/JeiANE',
      'https://z.wiki/u/MLxySN',
      'https://z.wiki/u/oG1woy',
      'https://z.wiki/u/tYlSBv',
      'https://z.wiki/u/qL61gk',
      'https://z.wiki/u/EOmH3B',
      'https://z.wiki/u/2MQ2D0',
      'https://z.wiki/u/VKhR33',
      'https://z.wiki/u/POLf4h'
        ];

        // 默认聊天背景图片列表
        const defaultChatBackgrounds = {
            'default-chat-bg-1': {
                name: '默认背景 1 (浅色)',
                image: 'https://z.wiki/u/Q72224' // 浅色背景
            },
            'default-chat-bg-2': {
                name: '默认背景 2 (深色)',
                image: 'https://z.wiki/u/Q72225' // 深色背景
            },
            'default-chat-bg-3': {
                name: '默认背景 3 (纹理)',
                image: 'https://z.wiki/u/Q72226' // 浅色纹理背景
            }
        };

        // 获取随机通用头像
        function getRandomAvatar() {
            return GENERIC_AVATARS[Math.floor(Math.random() * GENERIC_AVATARS.length)];
        }

        // 用于存储重新生成上下文的全局变量
        window.currentRegenerationContext = null;
        
        // 自定义确认弹窗的回调函数
        let _onConfirmCallback = null;
        let _onCancelCallback = null;

        // 当前激活的输入区域功能按钮（用于颜色反馈）
        let activeInputButtonElement = null; 

        // 新增：用于跟踪和取消手动回复的状态
        let isManualReplyGenerating = false;
        let manualReplyAbortController = null;

        // 新增：人设列表分页状态
        let currentPersonaPage = 0;
        const personasPerPage = 10;

        // 新增：本地记录数据
        let localRecords = {
            id: 'slots', // IndexedDB key for the localRecords object
            slot1: null,
            slot2: null,
            slot3: null
        };

        // Helper to convert hex to RGB for rgba() values
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return `${r}, ${g}, ${b}`;
        }

        // 定义主题颜色配置
        const themes = {
            'default': {
                name: '默认主题 (粉绿米蓝)',
                mainColors: ['#EDD4D8', '#CCD4CC', '#F4E8DD', '#B5BFCF'],
                auxiliaryColors: {
                    '--text-color-dark': '#333',
                    '--text-color-medium': '#555',
                    '--text-color-light': '#666',
                    '--text-color-lighter': '#999',
                    '--text-color-white': 'white',

                    '--header-text-shadow-color': 'rgba(255, 255, 255, 0.7)',
                    '--status-dot-online': '#4CAF50',
                    '--status-dot-busy': '#FFC107',
                    '--status-dot-offline': '#9E9E9E',

                    '--btn-bg': 'rgba(255, 255, 255, 0.7)',
                    '--btn-hover-bg': 'white',
                    '--btn-icon-color': '#555',

                    '--message-received-bubble-bg': 'white',
                    '--message-sent-bubble-text-color': 'white', /* 修正：玩家气泡字体颜色 */

                    '--retracted-bubble-bg': '#FFF0F0',
                    '--retracted-bubble-border': '#FF6347',
                    '--auto-reply-bubble-bg': '#E0F2F7',
                    '--auto-reply-bubble-border': '#87CEEB',
                    '--auto-reply-label-bg': '#D0EEF5',

                    '--input-area-bg': 'white',
                    '--toggle-input-btn-bg': 'rgba(255, 255, 255, 0.7)',
                    '--toggle-input-btn-hover-bg': 'white',
                    '--toggle-input-btn-icon-color': '#555',

                    '--modal-title-color': '#333',
                    '--close-btn-color': '#555',
                    '--form-label-color': '#555',
                    '--upload-btn-color': 'white',
                    '--btn-primary-color': 'white',

                    '--inner-voice-color': '#FF69B4',
                    '--inner-voice-bg': '#FFF0F5',
                    '--inner-voice-shadow-rgb': '255, 105, 180',

                    '--essay-text-color': '#444',
                    '--essay-bg': '#FFFACD',
                    '--essay-border': '#E0C068',
                    '--essay-pin-color': '#FFD700',

                    '--toggle-switch-off-bg': '#f0f0f0',
                    '--toggle-switch-border': '#ccc',
                    '--toggle-switch-handle-bg': 'white',

                    '--event-message-bg': 'rgba(128, 128, 128, 0.1)',
                    '--event-message-color': '#555',

                    '--persona-card-bg-light': '#f9f9f9',
                    '--persona-card-border-light': '#eee',

                    '--moment-input-bg-light': '#f0f0f0',
                    '--moment-input-border-light': '#ddd',
                    '--moment-card-bg-light': '#fff',
                    '--moment-card-border-light': '#eee',
                    '--moment-image-preview-bg': '#f9f9f9',
                    '--moment-name-color': '#333',
                    '--moment-content-color': '#444',
                    '--moment-comments-border': '#f0f0f0',
                    '--moment-comments-title-color': '#666',
                    '--comment-bg-light': '#f5f5f5',
                    '--comment-text-color': '#333',
                    '--comment-timestamp-color': '#999',

                    '--regenerate-modal-title-color': '#444',
                    '--regenerate-modal-body-color': '#555',
                    '--regenerate-modal-body-small-color': '#888',
                }
            },
            'green-earth': {
                name: '大地绿意 (浅绿灰)',
                mainColors: ['#E2E5D1', '#CAD6C3', '#AEC4AC', '#94A783'],
                auxiliaryColors: {
                    '--text-color-dark': '#333',
                    '--text-color-medium': '#555',
                    '--text-color-light': '#666',
                    '--text-color-lighter': '#999',
                    '--text-color-white': 'white',

                    '--header-text-shadow-color': 'rgba(255, 255, 255, 0.7)',
                    '--status-dot-online': '#4CAF50',
                    '--status-dot-busy': '#FFC107',
                    '--status-dot-offline': '#9E9E9E',

                    '--btn-bg': 'rgba(255, 255, 255, 0.7)',
                    '--btn-hover-bg': 'white',
                    '--btn-icon-color': '#555',

                    '--message-received-bubble-bg': 'white',
                    '--message-sent-bubble-text-color': 'white', /* 修正：玩家气泡字体颜色 */

                    '--retracted-bubble-bg': '#F8EFEF',
                    '--retracted-bubble-border': '#D87093',
                    '--auto-reply-bubble-bg': '#E8F5E9',
                    '--auto-reply-bubble-border': '#8BC34A',
                    '--auto-reply-label-bg': '#C8E6C9',

                    '--input-area-bg': 'white',
                    '--toggle-input-btn-bg': 'rgba(255, 255, 255, 0.7)',
                    '--toggle-input-btn-hover-bg': 'white',
                    '--toggle-input-btn-icon-color': '#555',

                    '--modal-title-color': '#333',
                    '--close-btn-color': '#555',
                    '--form-label-color': '#555',
                    '--upload-btn-color': 'white',
                    '--btn-primary-color': 'white',

                    '--inner-voice-color': '#8BC34A',
                    '--inner-voice-bg': '#F1F8E9',
                    '--inner-voice-shadow-rgb': '139, 195, 74',

                    '--essay-text-color': '#444',
                    '--essay-bg': '#F9FBE7',
                    '--essay-border': '#C5E1A5',
                    '--essay-pin-color': '#FFD700',

                    '--toggle-switch-off-bg': '#f0f0f0',
                    '--toggle-switch-border': '#ccc',
                    '--toggle-switch-handle-bg': 'white',

                    '--event-message-bg': 'rgba(128, 128, 128, 0.1)',
                    '--event-message-color': '#555',

                    '--persona-card-bg-light': '#f9f9f9',
                    '--persona-card-border-light': '#eee',

                    '--moment-input-bg-light': '#f0f0f0',
                    '--moment-input-border-light': '#ddd',
                    '--moment-card-bg-light': '#fff',
                    '--moment-card-border-light': '#eee',
                    '--moment-image-preview-bg': '#f9f9f9',
                    '--moment-name-color': '#333',
                    '--moment-content-color': '#444',
                    '--moment-comments-border': '#f0f0f0',
                    '--moment-comments-title-color': '#666',
                    '--comment-bg-light': '#f5f5f5',
                    '--comment-text-color': '#333',
                    '--comment-timestamp-color': '#999',

                    '--regenerate-modal-title-color': '#444',
                    '--regenerate-modal-body-color': '#555',
                    '--regenerate-modal-body-small-color': '#888',
                }
            },
            'starry-violet': { /* 新增主题：星空紫罗兰 */
                name: '星空紫罗兰 (深紫粉)',
                mainColors: ['#EFD4EB', '#C4B7D6', '#BBD6EE', '#454C72'], /* 调整为4个主色 */
                auxiliaryColors: {
                    '--text-color-dark': '#363C59', /* 最深的紫色 */
                    '--text-color-medium': '#454C72',
                    '--text-color-light': '#666', /* 保持中性灰，确保可读性 */
                    '--text-color-lighter': '#999', /* 保持中性灰 */
                    '--text-color-white': 'white',

                    '--header-text-shadow-color': 'rgba(255, 255, 255, 0.7)',
                    '--status-dot-online': '#4CAF50',
                    '--status-dot-busy': '#FFC107',
                    '--status-dot-offline': '#9E9E9E',

                    '--btn-bg': 'rgba(255, 255, 255, 0.7)',
                    '--btn-hover-bg': 'white',
                    '--btn-icon-color': '#555',

                    '--message-received-bubble-bg': 'white',
                    /* 修改：玩家气泡字体颜色为深色，以便在透明背景上显示 */
                    '--message-sent-bubble-text-color': '#363C59', 

                    '--retracted-bubble-bg': '#F5E8ED', /* 浅粉色 */
                    '--retracted-bubble-border': '#D87093', /* 略深的粉色 */
                    '--auto-reply-bubble-bg': '#E0F0F8', /* 浅蓝色 */
                    '--auto-reply-bubble-border': '#81C7D8', /* 略深的蓝色 */
                    '--auto-reply-label-bg': '#BBD6EE', /* 中等蓝色 */

                    '--input-area-bg': 'white',
                    '--toggle-input-btn-bg': 'rgba(255, 255, 255, 0.7)',
                    '--toggle-input-btn-hover-bg': 'white',
                    '--toggle-input-btn-icon-color': '#555',

                    '--modal-title-color': '#363C59', /* 深紫色 */
                    /* 修改：关闭按钮颜色为白色 */
                    '--close-btn-color': 'white', 
                    '--form-label-color': '#555',
                    '--upload-btn-color': 'white',
                    '--btn-primary-color': 'white',

                    '--inner-voice-color': '#9370db', /* 浅紫色 */
                    '--inner-voice-bg': '#F8F0F5', /* 极浅粉紫 */
                    '--inner-voice-shadow-rgb': '196, 183, 214', /* C4B7D6 的 RGB */

                    '--essay-text-color': '#363C59',
                    '--essay-bg': '#F5F0E8', /* 浅奶油色 */
                    '--essay-border': '#C4B7D6',
                    '--essay-pin-color': '#FFD700',

                    '--toggle-switch-off-bg': '#f0f0f0',
                    '--toggle-switch-border': '#ccc',
                    '--toggle-switch-handle-bg': 'white',

                    '--event-message-bg': 'rgba(128, 128, 128, 0.1)',
                    '--event-message-color': '#555',

                    '--persona-card-bg-light': '#f9f9f9',
                    '--persona-card-border-light': '#eee',

                    '--moment-input-bg-light': '#f0f0f0',
                    '--moment-input-border-light': '#ddd',
                    '--moment-card-bg-light': '#fff',
                    '--moment-card-border-light': '#eee',
                    '--moment-image-preview-bg': '#f9f9f9',
                    '--moment-name-color': '#333',
                    '--moment-content-color': '#444',
                    '--moment-comments-border': '#f0f0f0',
                    '--moment-comments-title-color': '#666',
                    '--comment-bg-light': '#f5f5f5',
                    '--comment-text-color': '#333',
                    '--comment-timestamp-color': '#999',

                    '--regenerate-modal-title-color': '#363C59',
                    '--regenerate-modal-body-color': '#454C72',
                    '--regenerate-modal-body-small-color': '#C4B7D6',

                    /* 修改：玩家气泡透明背景 */
                    '--message-sent-bubble-bg-gradient': 'rgba(var(--theme-color-rgb-2), 0.4)', /* 使用主题色2的RGB值，透明度为0.4 */
                    '--message-sent-bubble-border': '1px solid rgba(var(--theme-color-rgb-4), 0.6)', 
                }
            }
        };

        // IndexedDB 全局变量和辅助函数
        const DB_NAME = 'ChatSimulatorDB';
        const DB_VERSION = 2; // 数据库版本，如果修改了对象存储结构，需要递增此版本
        let db;

        /**
         * 打开IndexedDB数据库并创建/升级对象存储。
         * @returns {Promise<IDBDatabase>} 数据库实例
         */
        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    const transaction = event.target.transaction;
                    const oldVersion = event.oldVersion;

                    console.log(`Upgrading IndexedDB from version ${oldVersion} to ${DB_VERSION}`);

                    // Version 1 -> 2: Migrate from userMoments to momentsData
                    if (oldVersion < 2) {
                        // 1. 创建新的 momentsData 仓库
                        if (!db.objectStoreNames.contains('momentsData')) {
                            db.createObjectStore('momentsData', { keyPath: 'id' });
                            console.log('Created object store: momentsData');
                        }

                        // 2. 检查旧的 userMoments 仓库是否存在，并迁移数据
                        if (db.objectStoreNames.contains('userMoments')) {
                            console.log('Found old store "userMoments". Migrating data...');
                            const oldStore = transaction.objectStore('userMoments');
                            const newStore = transaction.objectStore('momentsData');
                            
                            oldStore.getAll().onsuccess = (e) => {
         const oldMoments = e.target.result;
         oldMoments.forEach(moment => {
           // 给旧数据添加 posterId 属性以适应新结构
           moment.posterId = 'player';
           moment.name = userData.name;
           moment.avatar = userData.avatar;
           newStore.put(moment);
         });
         console.log(`Migrated ${oldMoments.length} moments.`);
         
         // 3. 删除旧的 userMoments 仓库
         db.deleteObjectStore('userMoments');
         console.log('Deleted old object store: userMoments');
                            };
                        }
                    }

                    // 创建其他可能不存在的仓库 (作为兼容和兜底)
                    if (!db.objectStoreNames.contains('userData')) {
                        db.createObjectStore('userData', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('friendData')) {
                        db.createObjectStore('friendData', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('apiConfig')) {
                        db.createObjectStore('apiConfig', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('appSettings')) {
                        db.createObjectStore('appSettings', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('chatHistory')) {
                        // 修正：将 keyPath 从 'id' 改为 'messageId'，与 saveBubbleToHistory 函数中的对象结构保持一致
                        db.createObjectStore('chatHistory', { keyPath: 'messageId' });
                    }
                    if (!db.objectStoreNames.contains('localRecords')) {
                        db.createObjectStore('localRecords', { keyPath: 'id' });
                    }

                    console.log('IndexedDB upgrade complete.');
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('IndexedDB opened successfully.');
                    resolve(db);
                };

                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        /**
         * 将数据存入IndexedDB。
         * @param {string} storeName 对象存储名称
         * @param {object} data 要存储的数据对象
         * @returns {Promise<void>}
         */
        function putData(storeName, data) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('IndexedDB not open.');
                    return;
                }
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);

                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        /**
         * 从IndexedDB获取单条数据。
         * @param {string} storeName 对象存储名称
         * @param {string} key 数据的主键
         * @returns {Promise<object|undefined>} 获取到的数据对象
         */
        function getData(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('IndexedDB not open.');
                    return;
                }
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);

                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        /**
         * 从IndexedDB获取所有数据。
         * @param {string} storeName 对象存储名称
         * @returns {Promise<Array<object>>} 获取到的数据数组
         */
        function getAllData(storeName) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('IndexedDB not open.');
                    return;
                }
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();

                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        /**
         * 从IndexedDB删除单条数据。
         * @param {string} storeName 对象存储名称
         * @param {string} key 要删除数据的主键
         * @returns {Promise<void>}
         */
        function deleteData(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('IndexedDB not open.');
                    return;
                }
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);

                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        /**
         * 清空IndexedDB中的某个对象存储。
         * @param {string} storeName 对象存储名称
         * @returns {Promise<void>}
         */
        function clearStore(storeName) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('IndexedDB not open.');
                    return;
                }
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.clear();

                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        // --- 番茄钟功能实现 ---

        /**
         * 格式化秒数为 MM:SS 字符串。
         * @param {number} seconds - 总秒数。
         * @returns {string} 格式化后的时间字符串。
         */
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        /**
         * 打开番茄钟设置弹窗。
         */
        function openPomodoroModal() {
            // 如果番茄钟正在进行，显示当前状态
            if (isPomodoroActive) {
                pomodoroGoalInput.value = pomodoroGoal;
                pomodoroGoalInput.disabled = true; // 目标不可编辑
                startPomodoroBtn.style.display = 'none'; // 隐藏开始按钮
                abandonPomodoroBtn.style.display = 'inline-block'; // 显示放弃按钮
                pomodoroStatusMessage.textContent = `专注目标：“${pomodoroGoal}”`;
                updateCountdownDisplay(); // 立即更新倒计时
            } else {
                // 如果番茄钟未进行，重置为初始状态
                pomodoroGoalInput.value = '';
                pomodoroGoalInput.disabled = false;
                startPomodoroBtn.style.display = 'inline-block';
                abandonPomodoroBtn.style.display = 'none';
                pomodoroStatusMessage.textContent = '设置你的专注目标：';
                pomodoroCountdownDisplay.textContent = '25:00';
            }
            openModal(pomodoroModal);
        }

        /**
         * 更新番茄钟倒计时显示。
         */
        function updateCountdownDisplay() {
            if (!isPomodoroActive) return;

            const now = Date.now();
            const timeLeftSeconds = Math.max(0, Math.floor((pomodoroEndTime - now) / 1000));

            pomodoroCountdownDisplay.textContent = formatTime(timeLeftSeconds);

            if (timeLeftSeconds <= 0) {
                stopPomodoroTimer('completed');
            }
        }

        /**
         * 开始番茄钟计时。
         */
        async function startPomodoro() {
            const goal = pomodoroGoalInput.value.trim();
            if (!goal) {
                showPomodoroNotification('请输入你的专注目标！');
                return;
            }

            pomodoroGoal = goal;
            pomodoroStartTime = Date.now();
            pomodoroEndTime = pomodoroStartTime + POMODORO_DURATION_SECONDS * 1000;
            isPomodoroActive = true;

            // 保存番茄钟状态到appSettings
            appSettings.pomodoro = {
                isActive: true,
                goal: pomodoroGoal,
                startTime: pomodoroStartTime,
                endTime: pomodoroEndTime
            };
            await putData('appSettings', appSettings);

            pomodoroGoalInput.disabled = true;
            startPomodoroBtn.style.display = 'none';
            abandonPomodoroBtn.style.display = 'inline-block';
            pomodoroStatusMessage.textContent = `专注目标：“${pomodoroGoal}”`;
            pomodoroBtn.classList.add('active-pomodoro');
            pomodoroBtn.title = `番茄钟：${pomodoroGoal} (专注中)`;

            updateCountdownDisplay(); // Initial display
            pomodoroTimer = setInterval(updateCountdownDisplay, 1000); // Update every second

            closeModal(pomodoroModal);
            showPomodoroNotification(`番茄钟已开始：${pomodoroGoal}`);
        }

        /**
         * 停止番茄钟计时器。
         * @param {string} status - 停止状态 ('completed', 'abandoned', 'reset')。
         */
        async function stopPomodoroTimer(status) { 
            if (pomodoroTimer) {
                clearInterval(pomodoroTimer);
                pomodoroTimer = null;
            }
            isPomodoroActive = false;
            pomodoroBtn.classList.remove('active-pomodoro');
            pomodoroBtn.title = `番茄钟`;

            // Reset appSettings.pomodoro state
            appSettings.pomodoro = {
                isActive: false,
                goal: '',
                startTime: null,
                endTime: null
            };
            await putData('appSettings', appSettings);

            pomodoroGoalInput.disabled = false;
            startPomodoroBtn.style.display = 'inline-block';
            abandonPomodoroBtn.style.display = 'none';
            pomodoroStatusMessage.textContent = '设置你的专注目标：';
            pomodoroCountdownDisplay.textContent = '25:00';

            if (status === 'completed') {
                showPomodoroNotification(`${pomodoroGoal} 已结束！恭喜你完成目标！`);
                // Trigger AI response for completion
                const aiPrompt = `玩家设置的番茄钟专注目标“${pomodoroGoal}”已于${new Date(pomodoroStartTime).toLocaleString()}开始，并于${new Date(pomodoroEndTime).toLocaleString()}成功完成。请你根据你的人设，对玩家完成目标的行为做出符合人设的回复。`;
                triggerAiResponseForPomodoro(aiPrompt, 'pomodoroComplete');
            } else if (status === 'abandoned') {
                showPomodoroNotification(`你放弃了目标：“${pomodoroGoal}”`);
                // Trigger AI response for abandonment
                const abandonTime = Date.now();
                const aiPrompt = `玩家设置的番茄钟专注目标“${pomodoroGoal}”已于${new Date(pomodoroStartTime).toLocaleString()}开始，但玩家在${new Date(abandonTime).toLocaleString()}选择了放弃。请你根据你的人设、玩家的目标、玩家专注的时间、设置专注目标的时间点是否合理(比如太晚了应该睡觉,不应该学习)，对玩家放弃目标的行为做出回复。`;
                triggerAiResponseForPomodoro(aiPrompt, 'pomodoroAbandon');
            }
            // 'reset' status means no AI response needed, just reset state (e.g., when starting new chat)
        }

        /**
         * 放弃番茄钟专注。
         * @param {boolean} triggerAi - 是否触发AI回复。
         */
        async function abandonPomodoro(triggerAi = false) {
            if (isPomodoroActive) {
                showCustomConfirm(
                    '放弃确认',
                    `确定要放弃当前专注目标“${pomodoroGoal}”吗？`,
                    () => { // onConfirm callback
                        stopPomodoroTimer('abandoned');
                        closeModal(pomodoroModal);
                    },
                    () => {} // onCancel callback (do nothing)
                );
            } else {
                closeModal(pomodoroModal); // Simply close if not active
            }
        }

        /**
         * 恢复番茄钟计时器（例如在页面加载时）。
         */
        async function resumePomodoroTimer() {
            if (isPomodoroActive && pomodoroEndTime > Date.now()) {
                pomodoroTimer = setInterval(updateCountdownDisplay, 1000);
                updateCountdownDisplay(); // Initial update
            } else if (isPomodoroActive && pomodoroEndTime <= Date.now()) {
                // If it was active but already ended, trigger completion
                stopPomodoroTimer('completed');
            }
        }

        /**
         * 触发AI对番茄钟事件的回复。
         * @param {string} prompt - 发送给AI的提示文本。
         * @param {string} contextType - API调用的上下文类型。
         */
        async function triggerAiResponseForPomodoro(prompt, contextType) {
            const typingIndicatorContainer = document.createElement('div');
            typingIndicatorContainer.className = 'message received';
            typingIndicatorContainer.innerHTML = `
                <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                <div class="message-content">
                    <div class="name">${friendData.nickname || friendData.name}</div>
                    <div class="typing-indicator">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            `;
            chatArea.appendChild(typingIndicatorContainer);
            scrollToBottom();

            try {
                const aiResponseText = await getApiResponse(contextType, prompt);
                const parsedAiData = parseAiResponse(aiResponseText);
                
                // 核心修改：在显示第一条新消息前移除“正在输入”提示
                if (typingIndicatorContainer.parentNode === chatArea) {
                    chatArea.removeChild(typingIndicatorContainer);
                }
                
                await displayNewFriendMessages(parsedAiData, false, Date.now());

                appSettings.lastAiReplyTimestamp = Date.now();
                await putData('appSettings', appSettings);
                setFriendStatus('online');

            } catch (error) {
                // 确保移除提示
                if (typingIndicatorContainer.parentNode === chatArea) {
                    chatArea.removeChild(typingIndicatorContainer);
                }
                console.error(`AI回复番茄钟事件失败 (${contextType}):`, error);
                const errorMessage = `抱歉，我暂时无法对你的番茄钟事件做出回应。`;
                displayTemporaryErrorBubble(errorMessage);
            }
        }

        // 初始化应用
        async function initApp() {
            await openDatabase(); // 确保数据库已打开
            await loadData();
            updateFriendNameInHeader();
            updateFriendStatusDisplay(true);
            document.querySelector('#inner-voice-modal .modal-title').textContent = `${friendData.name}的状态`;
            setupEventListeners();
            await updateImageDisplayFlags(); // 初始化时，根据历史记录设置图片显示状态
            updateApiFields();
            scrollToBottom();
            checkAndTriggerAutoReply();
            updateReplyModeUI(); // 新增：根据设置更新回复模式UI
            await updateMomentsDisplay(); // 确保朋友圈显示更新
            applyGlobalFont(appSettings.globalFont); // 新增：应用保存的全局字体
            applyTheme(appSettings.currentTheme); // 应用保存的主题
            applyChatBackground(appSettings.chatBackground.type, appSettings.chatBackground.value); // 应用保存的聊天背景

            // 恢复番茄钟状态
            if (appSettings.pomodoro.isActive) {
                pomodoroGoal = appSettings.pomodoro.goal;
                pomodoroStartTime = appSettings.pomodoro.startTime;
                pomodoroEndTime = appSettings.pomodoro.endTime;
                isPomodoroActive = true; // 确保全局变量同步
                
                const now = Date.now();
                if (pomodoroEndTime > now) {
                    // 计时器仍在进行中
                    resumePomodoroTimer();
                    pomodoroBtn.classList.add('active-pomodoro');
                    pomodoroBtn.title = `番茄钟：${pomodoroGoal} (专注中)`;
                    showPomodoroNotification(`番茄钟已恢复：${pomodoroGoal}`);
                } else {
                    // 计时器已过期
                    stopPomodoroTimer('completed'); // 这将触发完成逻辑和AI回复
                    showPomodoroNotification(`${pomodoroGoal} 已结束！`);
                }
            }
        }
        
        // 加载数据
        async function loadData() {
            // 从IndexedDB加载数据
            const savedUserData = await getData('userData', 'user');
            const savedFriendData = await getData('friendData', 'friend');
            const savedApiConfig = await getData('apiConfig', 'api');
            const savedAppSettings = await getData('appSettings', 'settings');
            const savedChatHistory = await getAllData('chatHistory'); // 获取所有聊天记录
            const savedMoments = await getAllData('momentsData'); // 获取所有朋友圈动态
            const savedLocalRecords = await getData('localRecords', 'slots'); // 获取本地记录存档

            if (savedUserData) userData = { ...userData, ...savedUserData };
            if (savedFriendData) {
                friendData = { ...friendData, ...savedFriendData };
                if (friendData.currentEssay === undefined) {
                    friendData.currentEssay = '暂无随笔。';
                }
                if (friendData.openingLine === undefined) {
                    friendData.openingLine = '';
                }
            }
            if (savedApiConfig) {
                apiConfig = { ...apiConfig, ...savedApiConfig };
                document.getElementById('context-char-limit').value = apiConfig.contextCharLimit;
            }
            if (savedAppSettings) {
                appSettings = { ...appSettings, ...savedAppSettings };
                if (appSettings.emojiDisplayMode === undefined) {
                    appSettings.emojiDisplayMode = 'image';
                }
                if (appSettings.innerVoiceFont === undefined) {
                    appSettings.innerVoiceFont = 'ma-shan-zheng';
                }
                if (appSettings.currentTheme === undefined) {
                    appSettings.currentTheme = 'default';
                }
                if (appSettings.chatBackground === undefined) {
                    appSettings.chatBackground = { type: 'default', value: 'default-chat-bg-1' };
                }
                if (appSettings.inputAreaShiftedUp === undefined) {
                    appSettings.inputAreaShiftedUp = false;
                }
                if (appSettings.immediateReplyEnabled === undefined) {
                    appSettings.immediateReplyEnabled = true;
                }
                if (appSettings.enterSendEnabled === undefined) {
                    appSettings.enterSendEnabled = false;
                }
                if (appSettings.pomodoro === undefined) {
                    appSettings.pomodoro = { isActive: false, goal: '', startTime: null, endTime: null };
                }
                // 新增：加载全局字体和自定义主题
                if (appSettings.globalFont === undefined) {
                    appSettings.globalFont = 'lxgw-wenkai-screen';
                }
                if (appSettings.customTheme === undefined) {
                    appSettings.customTheme = null;
                }

                if (appSettings.playerCoverImage === undefined) {
                    appSettings.playerCoverImage = 'https://z.wiki/u/qUuU31';
                }
                if (appSettings.lastMomentsRefreshTimestamp === undefined) {
                    appSettings.lastMomentsRefreshTimestamp = null;
                }
                if (appSettings.customPersonas === undefined) {
                    appSettings.customPersonas = [];
                }

                // 新增：检查并迁移旧的 customPrompts 数据结构
                // 这一步在 appSettings 被合并后执行，直接修正 appSettings
                if (appSettings.customPrompts && !Array.isArray(appSettings.customPrompts)) {
                    console.log("检测到旧版提示词数据，正在迁移...");
                    const oldPrompts = appSettings.customPrompts;
                    const newPrompts = [];
                    // 迁移存在的、有内容的旧提示词
                    if (oldPrompts.prompt1 && oldPrompts.prompt1.text) {
                        newPrompts.push({
                            id: `prompt-${Date.now()}-1`,
                            name: '旧提示词 1',
                            content: oldPrompts.prompt1.text,
                            type: 'explicit',
                            keywords: [],
                            enabled: oldPrompts.prompt1.enabled
                        });
                    }
                    if (oldPrompts.prompt2 && oldPrompts.prompt2.text) {
                        newPrompts.push({
                            id: `prompt-${Date.now()}-2`,
                            name: '旧提示词 2',
                            content: oldPrompts.prompt2.text,
                            type: 'explicit',
                            keywords: [],
                            enabled: oldPrompts.prompt2.enabled
                        });
                    }
                    if (oldPrompts.prompt3 && oldPrompts.prompt3.text) {
                        newPrompts.push({
                            id: `prompt-${Date.now()}-3`,
                            name: '旧提示词 3',
                            content: oldPrompts.prompt3.text,
                            type: 'explicit',
                            keywords: [],
                            enabled: oldPrompts.prompt3.enabled
                        });
                    }
                    // 直接修正全局的 appSettings.customPrompts
                    appSettings.customPrompts = newPrompts;
                    // (可选但推荐) 立即保存迁移后的新结构
                    await putData('appSettings', appSettings); 
                    console.log("提示词数据迁移完成。");
                } else if (appSettings.customPrompts === undefined) {
                    appSettings.customPrompts = []; // 如果不存在，则初始化为空数组
                }
            }
            
            if (savedMoments) {
                momentsFeed = savedMoments.sort((a, b) => b.timestamp - a.timestamp); // 按时间倒序排列
            }
            if (savedLocalRecords) {
                localRecords = { ...localRecords, ...savedLocalRecords };
                // 确保所有存档位都存在，即使是null
                for (let i = 1; i <= 3; i++) {
                    const slotId = `slot${i}`;
                    if (localRecords[slotId] === undefined) {
                        localRecords[slotId] = null;
                    }
                }
            }
            
            document.getElementById('user-name').value = userData.name;
            document.getElementById('user-gender').value = userData.gender;
            document.getElementById('user-avatar-preview').src = userData.avatar;
            document.getElementById('user-background').value = userData.background;
            document.getElementById("goal-label").textContent = `${userData.name}の目标`;
            
            innerVoiceFontSelect.value = appSettings.innerVoiceFont;
            applyInnerVoiceFont(appSettings.innerVoiceFont);

            essayFontSelect.value = appSettings.essayFont;
            applyEssayFont(appSettings.essayFont);

            inputAreaShiftUpSwitch.checked = appSettings.inputAreaShiftedUp; // 设置开关状态
            applyInputAreaShift(appSettings.inputAreaShiftedUp); // 应用输入栏上移设置
            enterSendSwitch.checked = appSettings.enterSendEnabled; // 设置回车发送开关状态
            
            updateFriendConfigModalUI();
            
            document.getElementById('api-provider').value = apiConfig.provider;
            document.getElementById('api-url').value = apiConfig.url;
            document.getElementById('api-key').value = apiConfig.key;
            document.getElementById('temperature').value = apiConfig.temperature;
            document.getElementById('persona-reminder-interval').value = apiConfig.personaReminderInterval;
            
            if (savedChatHistory && savedChatHistory.length > 0) {
                chatHistoryArray = savedChatHistory.sort((a, b) => a.timestamp - b.timestamp); // 按时间正序排列
                // 重要：在DOM重新渲染前，先确保图片显示状态已正确计算并存储在chatHistoryArray中
                await updateImageDisplayFlags(); // 确保加载时图片显示状态正确

                chatArea.innerHTML = '';
                chatHistoryArray.forEach(bubble => {
                    if (bubble.type === 'event') {
                        addEventMessageToDOM(bubble.content, bubble.messageId);
                    } else {
                        // 使用新的 addBubbleToDOM 函数来处理所有消息类型
                        addBubbleToDOM(bubble); // 直接传递整个bubble对象，因为它已包含最新的displayImage状态
                    }
                });
                
                userMessageCounter = chatHistoryArray.filter(bubble => bubble.type === 'sent').length;
                scrollToBottom();
            } else {
                userMessageCounter = 0;
                buildFriendPersonaPrompt();
                initiateChatWithPersona();
            }
            document.getElementById('inner-voice-display').textContent = currentInnerVoice;
            document.getElementById('essay-display').textContent = friendData.currentEssay;
            globalFontSelect.value = appSettings.globalFont;
                document.getElementById('immediate-reply-switch').checked = appSettings.immediateReplyEnabled;
            // 更新朋友圈视图的头部信息
            playerCoverImage.src = appSettings.playerCoverImage;
            coverUserNameDisplay.textContent = userData.name;
            coverUserAvatarDisplay.src = userData.avatar;
        }
        
            
        // 设置事件监听器
        function setupEventListeners() {
            sendBtn.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (appSettings.enterSendEnabled) {
                // 如果“回车发送”开启：按Enter发送，按Shift+Enter换行
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                } else if (e.key === 'Enter' && e.shiftKey) {
                    // 允许Shift+Enter换行
                }
            } else {
                // 如果“回车发送”关闭（默认行为）：按Enter换行，按Shift+Enter发送
                if (e.key === 'Enter' && e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                } else if (e.key === 'Enter') {
                    // 默认Enter换行
                }
            }
        });
            
            document.getElementById('manage-btn').addEventListener('click', () => openModal(manageModal));
            document.getElementById('manage-user-config-btn').addEventListener('click', () => { closeModal(manageModal); openModal(userModal); });
            document.getElementById('manage-friend-config-btn').addEventListener('click', () => { closeModal(manageModal); updateFriendConfigModalUI(); openModal(friendModal); });
            document.getElementById('manage-api-config-btn').addEventListener('click', () => { closeModal(manageModal); updateApiFields(); openModal(apiModal); });
            document.getElementById('manage-all-settings-btn').addEventListener('click', () => { 
                closeModal(manageModal); 
                autoReplySwitch.checked = appSettings.autoReplyEnabled; 
                inputAreaShiftUpSwitch.checked = appSettings.inputAreaShiftedUp; // 设置输入栏上移开关状态
                innerVoiceFontSelect.value = appSettings.innerVoiceFont;
                essayFontSelect.value = appSettings.essayFont;
                emojiDisplayModeSelect.value = appSettings.emojiDisplayMode;
                openModal(allSettingsModal); 
            });
            document.getElementById('manage-persona-selection-btn').addEventListener('click', () => {
                closeModal(manageModal);
                populatePersonaSelectionModal();
                openModal(personaSelectionModal);
            });
            // 新增：主题设置按钮事件
            manageThemeSettingsBtn.addEventListener('click', () => {
                closeModal(manageModal);
                populateThemeOptions(); // 填充主题选项和背景选项
                openModal(themeSettingsModal);
            });
            // 新增：本地记录按钮事件
            manageLocalRecordsBtn.addEventListener('click', () => {
                closeModal(manageModal);
                populateLocalRecordsModal(); // 填充本地记录存档位
                openModal(localRecordsModal);
            });

            // 新增：重置应用按钮事件
            manageClearDataBtn.addEventListener('click', () => {
                showCustomConfirm(
                    '重置应用确认',
                    '此操作将永久删除所有聊天记录、人设和设置，将应用恢复到初始状态。确定要继续吗？',
                    () => {
                        clearAllDataAndReload();
                    },
                    () => {}, // 取消时不做任何事
                    '我确定，重置！',
                    '算了'
                );
            });
            
            
        // 新版：自定义提示词按钮事件
        manageCustomPromptBtn.addEventListener('click', () => {
            closeModal(manageModal);
            populateCustomPromptModal();
            openModal(customPromptModal);
        });

            document.getElementById('friend-status-btn').addEventListener('click', () => {
                document.getElementById('inner-voice-display').textContent = currentInnerVoice;
                document.getElementById('essay-display').textContent = friendData.currentEssay;
                openModal(innerVoiceModal);
            });

            momentsBtn.addEventListener('click', () => openMomentsView());
            
            document.getElementById('close-user-modal').addEventListener('click', () => closeModal(userModal));
            document.getElementById('close-friend-modal').addEventListener('click', () => closeModal(friendModal));
            document.getElementById('close-api-modal').addEventListener('click', () => closeModal(apiModal));
            document.getElementById('close-inner-voice-modal').addEventListener('click', () => closeModal(innerVoiceModal));
            document.getElementById('close-all-settings-modal').addEventListener('click', () => closeModal(allSettingsModal)); 
            document.getElementById('close-manage-modal').addEventListener('click', () => closeModal(manageModal));
            document.getElementById('close-persona-selection-modal').addEventListener('click', () => closeModal(personaSelectionModal));
            document.getElementById('close-persona-detail-modal').addEventListener('click', () => closeModal(personaDetailModal));
            closeMomentsModalBtn.addEventListener('click', () => closeModal(momentsView));
            closeRegenerateModalBtn.addEventListener('click', () => closeModal(regenerateModal));
            cancelRegenerateBtn.addEventListener('click', () => closeModal(regenerateModal));
            confirmRegenerateBtn.addEventListener('click', handleRegenerate);
            // 新增：主题设置弹窗关闭按钮
            closeThemeSettingsModalBtn.addEventListener('click', () => closeModal(themeSettingsModal));
            // 新增：本地记录弹窗关闭按钮
            closeLocalRecordsModalBtn.addEventListener('click', () => closeModal(localRecordsModal));

        // 新版：自定义提示词相关事件监听
        closeCustomPromptModalBtn.addEventListener('click', () => closeModal(customPromptModal));
        addNewPromptBtn.addEventListener('click', () => openEditPromptModal());
        
        closeEditPromptModalBtn.addEventListener('click', () => closeModal(editPromptModal));
        cancelEditPromptBtn.addEventListener('click', () => closeModal(editPromptModal));
        saveEditPromptBtn.addEventListener('click', saveCustomPrompt);

        // 新增：查看弹窗的关闭事件
        closeViewPromptModalBtn.addEventListener('click', () => closeModal(viewPromptModal));
        okViewPromptBtn.addEventListener('click', () => closeModal(viewPromptModal));

        // 监听提示词类型变化，以显示/隐藏关键词输入框
        editPromptTypeSelect.addEventListener('change', (e) => {
            if (e.target.value === 'implicit') {
                editPromptKeywordsGroup.style.display = 'block';
            } else {
                editPromptKeywordsGroup.style.display = 'none';
            }
        });
        
            // 新增：番茄钟事件监听器
            pomodoroBtn.addEventListener('click', openPomodoroModal);
            
            // 新增：表情包按钮事件
            emojiBtn.addEventListener('click', toggleEmojiCard); // toggleEmojiCard 会处理按钮激活状态
            prevEmojiPageBtn.addEventListener('click', goToPrevEmojiPage);
            nextEmojiPageBtn.addEventListener('click', goToNextEmojiPage);
            emojiGrid.addEventListener('click', handleEmojiClick); // 使用事件委托

            // 新增：自定义确认弹窗的事件监听器
            customConfirmConfirmBtn.addEventListener('click', () => {
                if (_onConfirmCallback) _onConfirmCallback();
                hideCustomConfirm();
            });
            customConfirmCancelBtn.addEventListener('click', () => {
                if (_onCancelCallback) _onCancelCallback();
                hideCustomConfirm();
            });
            closeCustomConfirmBtn.addEventListener('click', () => { // 'x' 关闭按钮
                if (_onCancelCallback) _onCancelCallback(); // 将点击 'x' 视为取消
                hideCustomConfirm();
            });
            
            closePomodoroModalBtn.addEventListener('click', () => closeModal(pomodoroModal));
            startPomodoroBtn.addEventListener('click', startPomodoro);
            abandonPomodoroBtn.addEventListener('click', () => abandonPomodoro(true)); // Pass true to trigger AI response



        // 新增：语音发送按钮事件监听器
        voiceBtn.addEventListener('click', () => {
            voiceTextInput.value = ''; // 清空输入框
            openModal(voiceInputModal);
            activateInputButton(voiceBtn); // 激活语音按钮
        });
        // 修复：语音输入弹窗关闭按钮
        closeVoiceInputModalBtn.addEventListener('click', () => {
            closeModal(voiceInputModal);
            deactivateInputButtons(); // 关闭时取消所有输入按钮的激活状态
        });
        cancelVoiceBtn.addEventListener('click', () => {
            closeModal(voiceInputModal);
            deactivateInputButtons(); // 关闭时取消所有输入按钮的激活状态
        });
        sendVoiceBtn.addEventListener('click', sendVoiceMessage);

        // 新增：图片发送按钮事件监听器
        imageBtn.addEventListener('click', () => {
            imageDescriptionInput.value = ''; // 清空图片描述输入框
            removeImageMessage(); // 确保图片预览和文件输入也被清空
            openModal(imageDescriptionModal);
            activateInputButton(imageBtn); // 激活图片按钮
        });
        
                // 新增：红包发送按钮事件监听器
        redPacketBtn.addEventListener('click', () => {
            redPacketNameInput.value = ''; // 清空名称输入框
            redPacketAmountInput.value = ''; // 清空金额输入框
            openModal(redPacketModal);
            activateInputButton(redPacketBtn); // 激活红包按钮
        });
        closeRedPacketModalBtn.addEventListener('click', () => {
            closeModal(redPacketModal);
            deactivateInputButtons();
        });
        cancelRedPacketBtn.addEventListener('click', () => {
            closeModal(redPacketModal);
            deactivateInputButtons();
        });
        sendRedPacketBtn.addEventListener('click', sendRedPacketMessage);
        
        // 修复：图片描述弹窗关闭按钮
        closeImageDescriptionModalBtn.addEventListener('click', () => {
            closeModal(imageDescriptionModal);
            removeImageMessage(); // 关闭时清除图片预览
            deactivateInputButtons(); // 关闭时取消所有输入按钮的激活状态
        });
        cancelImageBtn.addEventListener('click', () => {
            closeModal(imageDescriptionModal);
            removeImageMessage(); // 关闭时清除图片预览
            deactivateInputButtons(); // 关闭时取消所有输入按钮的激活状态
        });
        sendImageBtn.addEventListener('click', sendImageMessage);

        // 新增：图片上传按钮和移除按钮事件监听
        uploadImageMessageBtn.addEventListener('click', () => imageUploadInput.click());
        imageUploadInput.addEventListener('change', handleImageMessageUpload);
        removeImageMessageBtn.addEventListener('click', removeImageMessage);


            document.getElementById('cancel-user-btn').addEventListener('click', () => closeModal(userModal));
            document.getElementById('cancel-friend-btn').addEventListener('click', () => closeModal(friendModal));
            document.getElementById('cancel-api-btn').addEventListener('click', () => closeModal(apiModal));
            
            document.getElementById('save-user-btn').addEventListener('click', saveUserData);
            document.getElementById('save-api-btn').addEventListener('click', saveApiConfig);
            document.getElementById('save-friend-only-btn').addEventListener('click', saveFriendDataOnly);
            document.getElementById('save-friend-and-chat-btn').addEventListener('click', saveFriendDataAndStartNewChat);
            
            document.getElementById('user-upload-btn').addEventListener('click', () => document.getElementById('user-avatar-upload').click());
            document.getElementById('friend-upload-btn').addEventListener('click', () => document.getElementById('friend-avatar-upload').click());
            
            document.getElementById('user-avatar-upload').addEventListener('change', (e) => handleImageUpload(e, 'user-avatar-preview'));
            document.getElementById('friend-avatar-upload').addEventListener('change', (e) => handleImageUpload(e, 'friend-avatar-preview'));
            // 新增：全局字体选择事件
            globalFontSelect.addEventListener('change', async (e) => {
                const fontKey = e.target.value;
                applyGlobalFont(fontKey);
                appSettings.globalFont = fontKey;
                await putData('appSettings', appSettings);
            });

            // 新增：自定义主题相关事件
            addCustomThemeBtn.addEventListener('click', () => {
                // 打开时，用当前主题或默认主题的颜色填充选择器
                const currentThemeKey = appSettings.currentTheme;
                const sourceTheme = themes[currentThemeKey] || themes['default'];
                for (let i = 0; i < 4; i++) {
                    customColorInputs[i].value = sourceTheme.mainColors[i];
                }
                openModal(customThemeModal);
            });
            closeCustomThemeModalBtn.addEventListener('click', () => closeModal(customThemeModal));
            cancelCustomThemeBtn.addEventListener('click', () => closeModal(customThemeModal));
            saveCustomThemeBtn.addEventListener('click', saveCustomTheme);
            
            document.getElementById('api-provider').addEventListener('change', updateApiFields);
            
            document.addEventListener('click', createRippleEffect);

            chatArea.addEventListener('dblclick', async (e) => {
                console.log('dblclick event triggered on chatArea');
                const target = e.target;
                console.log('Event target:', target);
                console.log('Target classList:', target.classList);
                const closestReceivedMessage = target.closest('.message.received');
                console.log('Closest .message.received:', closestReceivedMessage);

                // 修正：确保点击的是头像，并且该头像属于“收到的消息”气泡
                if (target.classList.contains('avatar') && closestReceivedMessage) {
                    console.log('Conditions met: avatar clicked within a received message.');
                    e.preventDefault();

                    const pokeAction = friendData.pokeAction || '拍了拍';
                    const pokeContent = friendData.pokeContent ? `，${friendData.pokeContent}` : '';
                    const pokeMessageText = `我${pokeAction}${friendData.nickname || friendData.name}${pokeContent}`;
                    
                    const pokeMsgId = await saveBubbleToHistory(pokeMessageText, 'event', Date.now(), false, false, null, 'text');
                    addEventMessageToDOM(pokeMessageText, pokeMsgId);

                    const typingIndicatorContainer = document.createElement('div');
                    typingIndicatorContainer.className = 'message received';
                    typingIndicatorContainer.innerHTML = `
                        <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                        <div class="message-content">
                            <div class="name">${friendData.nickname || friendData.name}</div>
                            <div class="typing-indicator">
         <span></span>
         <span></span>
         <span></span>
                            </div>
                        </div>
                    `;
                    chatArea.appendChild(typingIndicatorContainer);
                    scrollToBottom();

                    try {
                        const aiPrompt = `用户对你进行了“拍一拍”操作，内容是：“${pokeMessageText}”。这类似于QQ的“拍一拍”功能，在你的视角里，拍一拍的内容其实是你自己设定的，请你根据你的人设对此做出回应。请严格遵循消息格式：
                        用""将回复内容分成多个短句，例如："嗯？""今天天气真不错"；并在最后附上心声【心声：心声内容不超过30字】`;
                        
                        const aiResponseText = await getApiResponse('poke', aiPrompt); 
                        const parsedAiData = parseAiResponse(aiResponseText);
                        
                        chatArea.removeChild(typingIndicatorContainer);
                        await displayNewFriendMessages(parsedAiData, false, Date.now());

                        appSettings.lastAiReplyTimestamp = Date.now();
                        await putData('appSettings', appSettings);
                        setFriendStatus('online');

                    } catch (error) {
                        chatArea.removeChild(typingIndicatorContainer);
                        console.error('拍一拍回复失败:', error);
                        const errorMessage = '抱歉，拍一拍回复失败。请检查API配置或稍后再试。';
                displayTemporaryErrorBubble(errorMessage);
                    }
                } else {
                    console.log('Conditions NOT met for poke: target is not avatar or not within a received message.');
                }
            });

            // 统一处理聊天区域的点击事件，包括红包和语音气泡
            chatArea.addEventListener('click', async (e) => {
                const target = e.target;

                // --- 红包消息交互 ---
                const redPacketBubble = target.closest('.red-packet-bubble');
                if (redPacketBubble) {
                    e.preventDefault(); // 阻止默认行为
                    const messageElement = redPacketBubble.closest('.message');

                    // 如果是自己发送的红包，则不执行任何操作
                    if (messageElement.classList.contains('sent')) {
                        return;
                    }
                    const messageId = messageElement.dataset.messageId;
                    const bubbleIndex = chatHistoryArray.findIndex(b => b.messageId === messageId);

                    if (bubbleIndex !== -1) {
                        const bubbleData = chatHistoryArray[bubbleIndex];
                        if (!bubbleData.isOpened) {
                            // 更新DOM
                            redPacketBubble.classList.add('opened');
                            
                            // 更新数据并保存到IndexedDB
                            bubbleData.isOpened = true;
                            await putData('chatHistory', bubbleData);

                            // 添加领取提示
                            const friendNickname = friendData.nickname || friendData.name;
                            const redPacketName = bubbleData.cardData.name;
                            const redPacketAmount = bubbleData.cardData.amount;
                            const receivedMessageText = `你领取了${friendNickname}的红包，获得${redPacketAmount}￥`;
                            
                            const eventMsgId = await saveBubbleToHistory(receivedMessageText, 'event', Date.now(), false, false, null, 'text');
                            addEventMessageToDOM(receivedMessageText, eventMsgId);

                            // 添加打开动画
                            redPacketBubble.style.transform = 'scale(0.95)';
                            setTimeout(() => {
         redPacketBubble.style.transform = 'scale(1)';
                            }, 300);
                        }
                    }
                    return; // 处理完红包点击后退出
                }

                // --- 语音消息交互 ---
                const voiceMessageBubble = target.closest('.voice-message-bubble');
                if (voiceMessageBubble) {
                    e.preventDefault(); // 阻止默认行为
                    // 语音内容在气泡的下一个兄弟元素，且必须是 .voice-transcript
                    const transcript = voiceMessageBubble.nextElementSibling; 
                    if (transcript && transcript.classList.contains('voice-transcript')) {
                        transcript.classList.toggle('show');
                        
                        // 添加点击效果
                        voiceMessageBubble.style.transform = 'scale(0.98)';
                        setTimeout(() => {
                            voiceMessageBubble.style.transform = '';
                        }, 200);
                    }
                    return; // 处理完语音点击后退出
                }

                // 以下是原有的重新生成逻辑，保持不变
                const clickedMessageElement = target.closest('.message.sent');
                if (clickedMessageElement) {
                    const clickedMessageId = clickedMessageElement.dataset.messageId;
                    let userMsgIndex = -1;
                    for (let i = 0; i < chatHistoryArray.length; i++) {
                        if (chatHistoryArray[i].messageId === clickedMessageId) {
                            userMsgIndex = i;
                            break;
                        }
                    }

                    if (userMsgIndex !== -1) {
                        const userMessageContent = chatHistoryArray[userMsgIndex].content;
                        const aiMessagesToClear = [];
                        const aiMessageDomElementsToClear = [];

                        for (let i = userMsgIndex + 1; i < chatHistoryArray.length; i++) {
                            if (chatHistoryArray[i].type === 'received') {
         aiMessagesToClear.push(chatHistoryArray[i].messageId);
         const domEl = chatArea.querySelector(`[data-message-id="${chatHistoryArray[i].messageId}"]`);
         if (domEl) {
           aiMessageDomElementsToClear.push(domEl);
         }
                            } else {
         break;
                            }
                        }

                        if (aiMessagesToClear.length === 0) {
                            showNotification('没有AI回复可以重新生成。');
                            return;
                        }

                        window.currentRegenerationContext = {
                            userMessageContent: userMessageContent,
                            aiMessageIdsToClear: aiMessagesToClear,
                            aiMessageDomElementsToClear: aiMessageDomElementsToClear,
                            userMessageHistoryIndex: userMsgIndex
                        };

                        openModal(regenerateModal);
                    }
                }
            });

            toggleInputBtn.addEventListener('click', () => {
                isInputExpanded = !isInputExpanded;
                messageInput.classList.toggle('expanded', isInputExpanded);
                arrowIcon.textContent = isInputExpanded ? '🌻' : '🌷';
                
                if (isInputExpanded) {
                    messageInput.focus();
                    messageInput.scrollTop = messageInput.scrollHeight;
                }
            });

            autoReplySwitch.addEventListener('change', async () => {
                appSettings.autoReplyEnabled = autoReplySwitch.checked;
                await putData('appSettings', appSettings);
                console.log('自动回复状态已更新:', appSettings.autoReplyEnabled ? '开启' : '关闭');
            });

            // 新增：输入栏上移开关事件监听器
            inputAreaShiftUpSwitch.addEventListener('change', async () => {
                appSettings.inputAreaShiftedUp = inputAreaShiftUpSwitch.checked;
                await putData('appSettings', appSettings);
                applyInputAreaShift(appSettings.inputAreaShiftedUp);
                console.log('输入栏上移状态已更新:', appSettings.inputAreaShiftedUp ? '开启' : '关闭');
            });

        // 新增：“即发即回”开关事件监听器
            const immediateReplySwitch = document.getElementById('immediate-reply-switch');
            immediateReplySwitch.addEventListener('change', async () => {
                appSettings.immediateReplyEnabled = immediateReplySwitch.checked;
                await putData('appSettings', appSettings);
                updateReplyModeUI();
                console.log('即发即回状态已更新:', appSettings.immediateReplyEnabled ? '开启' : '关闭');
            });

            const manualReplyBtn = document.getElementById('manual-reply-btn');
            manualReplyBtn.addEventListener('click', triggerManualAiReply);

        // 新增：“回车发送消息”开关事件监听器
        enterSendSwitch.addEventListener('change', async () => {
            appSettings.enterSendEnabled = enterSendSwitch.checked;
            await putData('appSettings', appSettings);
            console.log('回车发送消息状态已更新:', appSettings.enterSendEnabled ? '开启' : '关闭');
        });

            innerVoiceFontSelect.addEventListener('change', async (e) => {
                appSettings.innerVoiceFont = e.target.value;
                await putData('appSettings', appSettings);
                applyInnerVoiceFont(appSettings.innerVoiceFont);
            });

            essayFontSelect.addEventListener('change', async (e) => {
                appSettings.essayFont = e.target.value;
                await putData('appSettings', appSettings);
                applyEssayFont(appSettings.essayFont);
            });

            emojiDisplayModeSelect.addEventListener('change', async (e) => {
                appSettings.emojiDisplayMode = e.target.value;
                await putData('appSettings', appSettings);
                buildFriendPersonaPrompt();
                console.log('表情包显示方式已更新:', appSettings.emojiDisplayMode);
            });

            document.getElementById('apply-persona-from-detail-btn').addEventListener('click', async (e) => {
                const personaId = e.target.dataset.personaId;
                const selectedPersona = predefinedPersonas.find(p => p.id === personaId);
                if (selectedPersona) {
                    await applyPersona(selectedPersona);
                    closeModal(personaDetailModal);
                }
            });

            uploadMomentImageBtn.addEventListener('click', () => momentImageUpload.click());
            momentImageUpload.addEventListener('change', handleMomentImageUpload);
            removeMomentImageBtn.addEventListener('click', removeMomentImage);
            publishMomentBtn.addEventListener('click', publishMoment);

            // 新增：聊天背景设置事件监听器
            uploadChatBackgroundBtn.addEventListener('click', () => chatBackgroundUploadInput.click());
            chatBackgroundUploadInput.addEventListener('change', handleChatBackgroundUpload);
            removeChatBackgroundBtn.addEventListener('click', removeChatBackground);
            defaultChatBackgroundSelect.addEventListener('change', handleDefaultChatBackgroundChange);
            
            // 新版朋友圈事件监听
            refreshMomentsBtn.addEventListener('click', refreshMomentsFeed);
            postNewMomentBtn.addEventListener('click', () => openModal(postMomentModal));
            closePostMomentModalBtn.addEventListener('click', () => closeModal(postMomentModal));
            cancelPostMomentBtn.addEventListener('click', () => closeModal(postMomentModal));
            
            // 更换封面
            uploadCoverTrigger.addEventListener('click', () => coverImageUpload.click());
            coverImageUpload.addEventListener('change', handleCoverImageUpload);

            // 评论功能
            momentsFeedContainer.addEventListener('click', handleMomentCardClick);
            closeCommentModalBtn.addEventListener('click', () => closeModal(commentInputModal));
            cancelCommentBtn.addEventListener('click', () => closeModal(commentInputModal));
            submitCommentBtn.addEventListener('click', submitComment);
            
            // 新增：角色导入/导出及分页事件
            document.getElementById('export-friend-btn').addEventListener('click', exportFriendData);
            document.getElementById('import-persona-btn').addEventListener('click', () => {
                document.getElementById('persona-import-upload').click();
            });
            document.getElementById('persona-import-upload').addEventListener('change', importPersona);
            document.getElementById('prev-persona-page-btn').addEventListener('click', goToPrevPersonaPage);
            document.getElementById('next-persona-page-btn').addEventListener('click', goToNextPersonaPage);
        }

        function updateReplyModeUI() {
            const manualReplyBtn = document.getElementById('manual-reply-btn');
            if (appSettings.immediateReplyEnabled) {
                manualReplyBtn.style.display = 'none';
            } else {
                manualReplyBtn.style.display = 'flex';
            }
        }
        
        async function triggerManualAiReply() {
            const manualReplyBtn = document.getElementById('manual-reply-btn');
            const manualReplyIcon = manualReplyBtn.querySelector('i');

            // 如果一个生成过程正在进行，那么这次点击就是“取消”请求
            if (isManualReplyGenerating) {
                if (manualReplyAbortController) {
                    manualReplyAbortController.abort(); // 发出取消信号
                    console.log('用户请求取消AI回复生成。');
                }
                return; // 点击后直接返回，等待catch块处理后续
            }
            
            // 优化点1: 检查是否有新的用户消息需要回复
            const lastMessage = chatHistoryArray[chatHistoryArray.length - 1];
            // 如果聊天记录为空，或者最后一条消息不是用户发的，则不生成回复
            if (!lastMessage || lastMessage.type !== 'sent') {
                showNotification('没有新的用户消息，无需生成回复。');
                return;
            }

            // --- 开始生成过程 ---
            isManualReplyGenerating = true;
            manualReplyAbortController = new AbortController();
            
            // 更新按钮状态，让图标旋转，但按钮保持可点击状态以便取消
            manualReplyIcon.classList.remove('fa-feather-alt');
            manualReplyIcon.classList.add('fa-spinner', 'fa-spin');
            manualReplyBtn.title = "正在生成... 点击可取消";

            const typingIndicatorContainer = document.createElement('div');
            typingIndicatorContainer.className = 'message received';
            typingIndicatorContainer.innerHTML = `
                <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                <div class="message-content">
                    <div class="name">${friendData.nickname || friendData.name}</div>
                    <div class="typing-indicator">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            `;
            chatArea.appendChild(typingIndicatorContainer);
            scrollToBottom();

            try {
                // 使用 'chat' 上下文，并传入取消信号
                const aiResponseText = await getApiResponse('chat', null, manualReplyAbortController.signal); 
                const parsedAiData = parseAiResponse(aiResponseText);
                
                // 成功获取回复后，在这里移除“正在输入”提示
                if (typingIndicatorContainer.parentNode === chatArea) {
                    chatArea.removeChild(typingIndicatorContainer);
                }
                
                await displayNewFriendMessages(parsedAiData, false, Date.now());

                appSettings.lastAiReplyTimestamp = Date.now();
                await putData('appSettings', appSettings);
                setFriendStatus('online');

            } catch (error) {
                // 优化点2: 捕获取消错误
                if (error.name === 'AbortError') {
                    console.log('手动AI回复已由用户取消。');
                    showNotification('回复已取消。');
                } else {
                    console.error('手动触发AI回复失败:', error);
                    const errorMessage = '抱歉，我暂时无法回复。请检查API配置或稍后再试。';
                    displayTemporaryErrorBubble(errorMessage);
                }
                // 确保在任何错误（包括取消）发生时，都移除“正在输入”提示
                if (typingIndicatorContainer.parentNode === chatArea) {
                    chatArea.removeChild(typingIndicatorContainer);
                }
            } finally {
                // 无论成功、失败还是取消，最后都重置状态
                isManualReplyGenerating = false;
                manualReplyAbortController = null;
                manualReplyIcon.classList.remove('fa-spinner', 'fa-spin');
                manualReplyIcon.classList.add('fa-feather-alt');
                manualReplyBtn.title = "让对方回复";
            }
        }

        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;

            messageInput.value = '';

            const now = Date.now();
            const segments = message.match(/“(.*?)”/g);
            let displayDelay = 0;

            if (segments && segments.length > 0) {
                for (const segment of segments) {
                    const content = segment.substring(1, segment.length - 1).trim();
                    if (content === '') continue;

                    await new Promise(resolve => {
                        setTimeout(async () => {
                            const msgId = await saveBubbleToHistory(content, 'sent', now, false, false, null, 'text');
                            addBubbleToDOM({
                                messageId: msgId,
                                content: content,
                                type: 'sent',
                                isRetracted: false,
                                isAutoReply: false,
                                timestamp: now,
                                displayTimeOverride: null,
                                segmentType: 'text',
                                cardData: null
                            });
                            resolve();
                        }, displayDelay);
                    });
                    displayDelay += 200;
                }
            } else {
                const msgId = await saveBubbleToHistory(message, 'sent', now, false, false, null, 'text');
                addBubbleToDOM({
                    messageId: msgId,
                    content: message,
                    type: 'sent',
                    isRetracted: false,
                    isAutoReply: false,
                    timestamp: now,
                    displayTimeOverride: null,
                    segmentType: 'text',
                    cardData: null
                });
            }

            userMessageCounter++;
            
            // --- AI 回复逻辑（根据开关决定是否执行）---
            if (appSettings.immediateReplyEnabled) {
                const typingIndicatorContainer = document.createElement('div');
                typingIndicatorContainer.className = 'message received';
                typingIndicatorContainer.innerHTML = `
                    <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                    <div class="message-content">
                        <div class="name">${friendData.nickname || friendData.name}</div>
                        <div class="typing-indicator">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                `;
                chatArea.appendChild(typingIndicatorContainer);
                scrollToBottom();

                let aiPromptModifier = '';
                if (isPomodoroActive) {
                    const now = Date.now();
                    const minutesLeft = Math.max(0, Math.floor((pomodoroEndTime - now) / 1000 / 60));
                    aiPromptModifier = `玩家当前正在进行番茄钟专注，目标是“${pomodoroGoal}”，已于${new Date(pomodoroStartTime).toLocaleString()}开始，还剩约${minutesLeft}分钟结束。请你针对玩家的这种分心行为，结合玩家的目标、时长、设置番茄钟的时间点是否合理(比如已经很晚了还要选择学习等行为)，根据你的人设给出回复。`;
                }

                try {
                    const aiResponseText = await getApiResponse('chat', aiPromptModifier);
                    const parsedAiData = parseAiResponse(aiResponseText);

                    if (typingIndicatorContainer.parentNode === chatArea) {
                        chatArea.removeChild(typingIndicatorContainer);
                    }
                    
                    await displayNewFriendMessages(parsedAiData, false, Date.now());

                    appSettings.lastAiReplyTimestamp = Date.now();
                    await putData('appSettings', appSettings);
                    setFriendStatus('online');

                } catch (error) {
                    console.error('API调用失败:', error);
                    const errorMessage = '抱歉，我暂时无法回复。请检查API配置或稍后再试。';
                    displayTemporaryErrorBubble(errorMessage);
                } finally {
                    if (typingIndicatorContainer && typingIndicatorContainer.parentNode === chatArea) {
                        chatArea.removeChild(typingIndicatorContainer);
                    }
                }
            }
        }
        
        /**
         * 生成卡片消息的HTML结构。
         * @param {object} cardData - 包含 friendName, shareType, shareTitle, shareDescription 的对象。
         * @param {string} messageType - 消息类型 ('sent' 或 'received')，用于决定左侧图片颜色。
         * @returns {string} 卡片消息的HTML字符串。
         */
        function generateCardHtml(cardData, messageType) {
            const { friendName, shareType, shareTitle, shareDescription } = cardData;
            // 根据消息类型选择左侧图片的主题色
            const cardImageColor = messageType === 'received' ? 'var(--theme-color-1)' : 'var(--theme-color-2)';

            return `
                <div class="card-message-inner">
                    <div class="card-left-image" style="background-color: ${cardImageColor};"></div>
                    <div class="card-content-area">
                        <div class="card-title">${shareTitle}</div>
                        <div class="card-description">${shareDescription}</div>
                        <div class="card-type-label">${shareType}</div>
                    </div>
                </div>
            `;
        }

        /**
         * 将消息气泡添加到DOM中。
         * @param {object} bubbleData - 包含消息所有数据的对象。
         * @param {string} bubbleData.content - 消息内容（文本、表情ID或卡片JSON字符串）。
         * @param {string} bubbleData.type - 消息类型 ('sent' 或 'received')。
         * @param {boolean} [bubbleData.isRetracted=false] - 是否为撤回消息。
         * @param {boolean} [bubbleData.isAutoReply=false] - 是否为自动回复。
         * @param {number} bubbleData.timestamp - 消息时间戳。
         * @param {string|null} [bubbleData.displayTimeOverride=null] - 自动回复时用于显示的时间字符串。
         * @param {string} [bubbleData.segmentType='text'] - 消息段类型 ('text', 'emoji-image', 'card', 'red-packet', 'voice', 'image')。
         * @param {string|null} [bubbleData.messageId=null] - 消息的唯一ID。
         * @param {object|null} [bubbleData.cardData=null] - 如果是卡片/红包/语音/图片消息，包含详细数据的对象。
         * @param {boolean} [bubbleData.isOpened=false] - 如果是红包消息，是否已领取。
         */
        function addBubbleToDOM(bubbleData, preventScroll = false) {
            const { content, type, isRetracted = false, isAutoReply = false, timestamp, displayTimeOverride = null, segmentType = 'text', messageId = null, cardData = null, isOpened = false } = bubbleData;

            let displayTimeText;
            if (isAutoReply && displayTimeOverride) {
                displayTimeText = displayTimeOverride;
            } else {
                const displayTime = new Date(timestamp);
                displayTimeText = `${displayTime.getHours().toString().padStart(2, '0')}:${displayTime.getMinutes().toString().padStart(2, '0')}`;
            }
            
            // 检查该messageId对应的消息是否已经在DOM中，如果在，则先移除
            let existingElement = chatArea.querySelector(`[data-message-id="${messageId}"]`);
            if (existingElement) {
                existingElement.remove();
            }

            const messageContainer = document.createElement('div');
            messageContainer.className = `message ${type}`;
            if (messageId) {
                messageContainer.dataset.messageId = messageId;
            }
            
            const name = type === 'sent' ? userData.name : (friendData.nickname || friendData.name);
            const avatar = type === 'sent' ? userData.avatar : friendData.avatar;
            
            let retractedTagHtml = '';
            let bubbleClasses = 'bubble';
            let autoReplyLabelHtml = '';
            let bubbleContentHtml = '';

            if (isRetracted) {
                retractedTagHtml = `<div class="retracted-tag">(撤回)</div>`;
                bubbleClasses += ' retracted-bubble';
            }
            if (isAutoReply) {
                bubbleClasses += ' auto-reply-bubble';
                autoReplyLabelHtml = `<span class="auto-reply-label">未读消息</span>`;
            }

            if (segmentType === 'emoji-image') {
                const emojiId = content; // content is the emoji ID
                const emojiName = PLAYER_EMOJI_MAP[emojiId] || '未知表情';

                if (appSettings.emojiDisplayMode === 'image') {
                    bubbleClasses += ' emoji-bubble';
                    const imageUrl = `https://z.wiki/u/${emojiId}`;
                    bubbleContentHtml = `<img src="${imageUrl}" alt="${emojiName}">`;
                } else {
                    bubbleContentHtml = `[表情: ${emojiName}]`;
                }
            } else if (segmentType === 'card') {
                bubbleClasses += ' card-bubble'; 
                bubbleContentHtml = generateCardHtml(cardData, type);
            } else if (segmentType === 'red-packet') {
                bubbleClasses += ' red-packet-bubble'; 
                const { name, amount } = cardData;
                if (isOpened) { // 使用传入的 isOpened 状态
                    bubbleClasses += ' opened';
                }
                bubbleContentHtml = `
                    <div class="red-packet-header">
                        <i class="fas fa-gift red-packet-icon"></i>
                        <div class="red-packet-title">${name}</div>
                    </div>
                    <div class="red-packet-message">恭喜发财，大吉大利</div>
                    <div class="red-packet-footer">
                        <span>OO红包</span>
                        <span>${amount}￥</span>
                    </div>
                `;
            } else if (segmentType === 'voice') {
                bubbleClasses += ' voice-message-bubble'; 
                const { duration, content: voiceContent } = cardData; 
                bubbleContentHtml = `
                    <div class="voice-duration">${duration}</div>
                    <div class="voice-wave">
                        <div class="voice-wave-bar"></div>
                        <div class="voice-wave-bar"></div>
                        <div class="voice-wave-bar"></div>
                        <div class="voice-wave-bar"></div>
                        <div class="voice-wave-bar"></div>
                    </div>
                `;
                messageContainer.voiceTranscriptHtml = `
                    <div class="voice-transcript">
                        ${voiceContent}
                    </div>
                `;
            } else if (segmentType === 'image') {
                bubbleClasses += ' image-message-bubble';
                const { description, imageUrl, displayImage } = cardData;
                bubbleContentHtml = ''; // 初始化为空

                // 修正：更严格地判断是否为有效的图片URL（以'data:image'开头）
                const hasActualImage = imageUrl && imageUrl.startsWith('data:image');

                // 如果是包含【有效图片URL】的消息，并且被设置为显示图片
                if (displayImage && hasActualImage) {
                    bubbleContentHtml = `<img src="${imageUrl}" alt="${description || '图片'}">`;
                    // 如果没有提供文字描述（纯图片），添加 'pure-image' 类来应用特殊样式
                    if (!description) {
                        bubbleClasses += ' pure-image'; 
                    }
                } else {
                    // 如果是【没有有效图片】（即只有文字描述）或【旧的图片消息】(displayImage为false)
                    bubbleClasses += ' text-only-placeholder'; // 添加用于纯文本占位符的样式
                    bubbleContentHtml = `<div class="image-description-text">${description || '[图片]'}</div>`; // 使用带有class的div包裹文字
                }
            }
            else { // segmentType === 'text'
                bubbleContentHtml = content;
            }
            
            
            messageContainer.innerHTML = `
                <img src="${avatar}" alt="${name}头像" class="avatar">
                <div class="message-content">
                    <div class="name">${name}</div>
                    <div class="bubble-and-tag-wrapper"> 
                        <div class="${bubbleClasses}">${bubbleContentHtml}</div>
                        ${retractedTagHtml}
                    </div>
                </div>
            `;
            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'timestamp';
            timestampDiv.innerHTML = `${displayTimeText}${autoReplyLabelHtml}`;
            
            const messageContentDiv = messageContainer.querySelector('.message-content');
            messageContentDiv.appendChild(timestampDiv);

            if (segmentType === 'voice' && messageContainer.voiceTranscriptHtml) {
                const bubbleAndTagWrapper = messageContainer.querySelector('.bubble-and-tag-wrapper');
                bubbleAndTagWrapper.insertAdjacentHTML('beforeend', messageContainer.voiceTranscriptHtml);
            }
            
            // 将新元素插入到正确的位置
            const existingBubbleIndex = chatHistoryArray.findIndex(b => b.messageId === messageId);
            if (existingBubbleIndex !== -1) {
                // 如果消息存在于chatHistoryArray中，将其插入到正确的位置
                let insertBeforeElement = null;
                for (let i = existingBubbleIndex + 1; i < chatHistoryArray.length; i++) {
                    const nextBubble = chatHistoryArray[i];
                    insertBeforeElement = chatArea.querySelector(`[data-message-id="${nextBubble.messageId}"]`);
                    if (insertBeforeElement) {
                        break;
                    }
                }
                if (insertBeforeElement) {
                    chatArea.insertBefore(messageContainer, insertBeforeElement);
                } else {
                    chatArea.appendChild(messageContainer);
                }
            } else {
                chatArea.appendChild(messageContainer); // 如果是新消息，直接添加到末尾
            }

            if (!preventScroll) {
                scrollToBottom();
            }
        }

        /**
         * 在DOM中显示一个临时的错误消息气泡，不存入历史记录。
         * @param {string} errorMessage - 要显示的错误信息。
         */
        function displayTemporaryErrorBubble(errorMessage) {
            const tempBubbleData = {
                messageId: `error-${Date.now()}`, // 临时ID，不会被保存
                content: errorMessage,
                type: 'received',
                isRetracted: false,
                isAutoReply: false,
                timestamp: Date.now(),
                displayTimeOverride: null,
                segmentType: 'text',
                cardData: null
            };
            addBubbleToDOM(tempBubbleData);
        }

        function addEventMessageToDOM(text, messageId = null) {
            const messageContainer = document.createElement('div');
            messageContainer.className = 'message event-message';
            if (messageId) {
                messageContainer.dataset.messageId = messageId;
            }

            messageContainer.innerHTML = `
                <div class="message-content">
                    <div class="bubble">${text}</div>
                </div>
            `;
            
            chatArea.appendChild(messageContainer);
            scrollToBottom();
        }
        
        /**
         * 将消息气泡数据保存到历史记录和IndexedDB。
         * @param {string} content - 消息内容（文本、表情ID或卡片JSON字符串）。
         * @param {string} type - 消息类型 ('sent', 'received', 'event')。
         * @param {number} timestamp - 消息时间戳。
         * @param {boolean} [isRetracted=false] - 是否为撤回消息。
         * @param {boolean} [isAutoReply=false] - 是否为自动回复。
         * @param {string|null} [displayTimeOverride=null] - 自动回复时用于显示的时间字符串。
         * @param {string} [segmentType='text'] - 消息段类型 ('text', 'emoji-image', 'card')。
         * @param {object|null} [cardData=null] - 如果是卡片消息，包含卡片详细数据的对象。
         * @returns {Promise<string>} 消息的唯一ID。
         */
        async function saveBubbleToHistory(content, type, timestamp, isRetracted = false, isAutoReply = false, displayTimeOverride = null, segmentType = 'text', cardData = null, isOpened = false) {
            const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            const bubbleData = {
                messageId: messageId,
                content: content, // 对于卡片消息，这里存储的是 stringified JSON
                type: type,
                timestamp: timestamp,
                isRetracted: isRetracted,
                isAutoReply: isAutoReply,
                displayTimeOverride: displayTimeOverride,
                segmentType: segmentType,
                cardData: cardData, // 直接存储解析后的卡片数据对象
                isOpened: isOpened // 新增：用于红包消息是否已领取的状态
            };
            chatHistoryArray.push(bubbleData); // Update in-memory cache
            await putData('chatHistory', bubbleData); // Save to IndexedDB
            return messageId;
        }

        /**
         * 解析AI返回的原始文本，提取消息段、心声、随笔和朋友圈评论。
         * @param {string} fullAiResponseText - AI返回的原始文本。
         * @returns {object} 包含解析后数据的对象。
         */
        function parseAiResponse(fullAiResponseText) {
            console.log("--- Parsing AI Response ---");
            console.log("Raw AI Response Text (before parsing):", fullAiResponseText);
            const parsedSegments = [];
            let innerVoice = '暂无心声。';
            let essay = '暂无随笔。';
            const momentComments = [];

            // 新增：步骤 0 - 在所有解析之前，先移除所有 [时间:...] 标记
            // 这个正则表达式会匹配 "[时间: xx/xx xx:xx]" 以及它前后的任何空白字符
            fullAiResponseText = fullAiResponseText.replace(/\[时间:\s*\d{1,2}\/\d{1,2}\s*\d{2}:\d{2}\]\s*/g, '').trim();
            console.log("Raw AI Response Text (after stripping timestamps):", fullAiResponseText);


            // 1. 提取心声
            const innerVoiceMatch = fullAiResponseText.match(/【心声：(.*?)】/);
            if (innerVoiceMatch && innerVoiceMatch[1]) {
                innerVoice = innerVoiceMatch[1].trim();
                fullAiResponseText = fullAiResponseText.replace(/【心声：.*?】/, '').trim();
                console.log("Extracted Heart Voice:", innerVoice);
            }

            // 2. 提取随笔
            const essayMatch = fullAiResponseText.match(/「随笔：(.*?)」/);
            if (essayMatch && essayMatch[1]) {
                essay = essayMatch[1].trim();
                fullAiResponseText = fullAiResponseText.replace(/「随笔：.*?」/, '').trim();
                console.log("Extracted Essay:", essay);
            }

            // 3. 提取朋友圈评论 (针对玩家发帖的AI回复)
            // 新版Regex: 【评论：内容|时间】 和 〖好友名：内容|时间〗
            const commentRegex = /(?:【评论：([^|]+?)\|([^】]+?)】)|(?:〖([^：]+?)：([^|]+?)\|([^〗]+?)〗)/g;
            let commentMatch;
            const commentsToRemove = []; // 临时存储匹配到的完整评论字符串
            while ((commentMatch = commentRegex.exec(fullAiResponseText)) !== null) {
                commentsToRemove.push(commentMatch[0]);
                if (commentMatch[1] !== undefined) { // AI自己的评论
                    momentComments.push({
                        type: 'ai',
                        name: friendData.nickname || friendData.name,
                        avatar: friendData.avatar,
                        content: commentMatch[1].trim(),
                        displayTime: commentMatch[2].trim()
                    });
                    console.log("Extracted AI Comment:", commentMatch[1].trim(), "Time:", commentMatch[2].trim());
                } else if (commentMatch[3] !== undefined) { // 其他好友评论
                    momentComments.push({
                        type: 'other',
                        name: commentMatch[3].trim(),
                        avatar: getRandomAvatar(),
                        content: commentMatch[4].trim(),
                        displayTime: commentMatch[5].trim()
                    });
                    console.log("Extracted Other Friend Comment:", commentMatch[3].trim(), commentMatch[4].trim(), "Time:", commentMatch[5].trim());
                }
            }
            // 从原始文本中移除所有评论
            commentsToRemove.forEach(commentStr => {
                fullAiResponseText = fullAiResponseText.replace(commentStr, '');
            });
            fullAiResponseText = fullAiResponseText.trim();

            // 4. 提取朋友圈动态 (针对刷新动态的AI回复)
            const momentsRegex = /<朋友圈>([\s\S]*?)<\/朋友圈>/g;
            let momentsMatch;
            const newMoments = [];
            while ((momentsMatch = momentsRegex.exec(fullAiResponseText)) !== null) {
                const momentBlock = momentsMatch[1];
                // Regex for post: 【发帖人|内容|显示时间】
                const postRegex = /【([^|]+)\|([\s\S]+?)\|([^】]+)】/g;
                // Regex for comments in this block: 〖评论人|内容|显示时间〗
                const commentRegexForMoments = /〖([^|]+)\|([\s\S]+?)\|([^〗]+)〗/g;

                let postMatch = postRegex.exec(momentBlock);
                if (postMatch) {
                    const posterName = postMatch[1].trim();
                    const isCurrentFriend = (posterName === friendData.name) || (friendData.nickname && posterName === friendData.nickname);

                    const newMoment = {
                        id: `moment-ai-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                        posterId: 'ai_generated',
                        name: posterName,
                        avatar: isCurrentFriend ? friendData.avatar : getRandomAvatar(),
                        content: postMatch[2].trim(),
                        imageUrl: '', // AI目前不生成图片
                        timestamp: Date.now(), // 真实时间戳，用于排序
                        displayTime: postMatch[3].trim(), // AI提供的显示时间
                        comments: []
                    };

                    let aCommentMatch;
                    while ((aCommentMatch = commentRegexForMoments.exec(momentBlock)) !== null) {
                        // 同样在这里检查评论者是否是当前AI好友
                        const commenterName = aCommentMatch[1].trim();
                        const isCommenterCurrentFriend = (commenterName === friendData.name) || (friendData.nickname && commenterName === friendData.nickname);
                        
                        newMoment.comments.push({
                            name: commenterName,
                            // 新增：如果评论者是AI好友，也使用它的头像
                            avatar: isCommenterCurrentFriend ? friendData.avatar : getRandomAvatar(),
                            content: aCommentMatch[2].trim(),
                            displayTime: aCommentMatch[3].trim(), // AI提供的评论显示时间
                            timestamp: Date.now() // 真实时间戳
                        });
                    }
                    newMoments.push(newMoment);
                }
            }
            if (newMoments.length > 0) {
                 fullAiResponseText = fullAiResponseText.replace(momentsRegex, '').trim(); // 从主回复中移除朋友圈部分
            }

            // 5. 解析主要消息段 (聊天消息)
            // *** 修改后的正则表达式 ***
            const segmentRegex = /\[红包\|([^|]+)\|(\d+\.?\d*)\s*￥(?:\|(\d{2}:\d{2}))?\]|\[语音\|(\d+s)\|(.+?)(?:\|(\d{2}:\d{2}))?\]|\[图片：(.+?)(?:\|(\d{2}:\d{2}))?\]|『([^|]+)\|([^|]+)\|(.*?)(?:\|(\d{2}:\d{2}))?』|<表情>(.*?)(?:\|(\d{2}:\d{2}))?<\/表情>|"\{(.+?)(?:\|(\d{2}:\d{2}))?\}"|\{(.+?)(?:\|(\d{2}:\d{2}))?\}|"(.*?)(?:\|(\d{2}:\d{2}))?"|([^"\[『【「<\{]+)/g;
            segmentRegex.lastIndex = 0;

            let match;
            let hasStructuredSegments = false;

            // *** 修改后的 while 循环，以匹配新的正则表达式捕获组 ***
            while ((match = segmentRegex.exec(fullAiResponseText)) !== null) {
                let content;
                let segmentType = 'text';
                let isRetracted = false;
                let customTime = null;
                let cardData = null;

                if (match[1] !== undefined) { // 红包
                    segmentType = 'red-packet';
                    cardData = { name: match[1].trim(), amount: parseFloat(match[2]) };
                    content = JSON.stringify(cardData);
                    customTime = match[3] || null;
                    hasStructuredSegments = true;
                } else if (match[4] !== undefined) { // 语音
                    segmentType = 'voice';
                    cardData = { duration: match[4].trim(), content: match[5].trim() };
                    content = JSON.stringify(cardData);
                    customTime = match[6] || null;
                    hasStructuredSegments = true;
                } else if (match[7] !== undefined) { // 图片
                    segmentType = 'image';
                    cardData = { description: match[7].trim() };
                    content = JSON.stringify(cardData);
                    customTime = match[8] || null;
                    hasStructuredSegments = true;
                } else if (match[9] !== undefined) { // 卡片
                    segmentType = 'card';
                    cardData = { shareType: match[9].trim(), shareTitle: match[10].trim(), shareDescription: match[11].trim() };
                    content = JSON.stringify(cardData);
                    customTime = match[12] || null;
                    hasStructuredSegments = true;
                } else if (match[13] !== undefined) { // 表情包
                    content = match[13].trim();
                    segmentType = 'emoji-image';
                    customTime = match[14] || null;
                    hasStructuredSegments = true;
                } else if (match[15] !== undefined) { // 带引号的撤回 "{...}"
                    content = match[15].trim();
                    isRetracted = true;
                    customTime = match[16] || null;
                    segmentType = 'text';
                    hasStructuredSegments = true;
                } else if (match[17] !== undefined) { // 不带引号的撤回 {...}
                    content = match[17].trim();
                    isRetracted = true;
                    customTime = match[18] || null;
                    segmentType = 'text';
                    hasStructuredSegments = true;
                } else if (match[19] !== undefined) { // 普通引用 "..."
                    content = match[19].trim();
                    customTime = match[20] || null;
                    segmentType = 'text';
                    hasStructuredSegments = true;
                } else if (match[21] !== undefined) { // 纯文本
                    content = match[21].trim();
                    segmentType = 'text';
                    if (content !== '') hasStructuredSegments = true;
                } else {
                    continue;
                }

                if (content === '' && !['card', 'red-packet', 'voice', 'image'].includes(segmentType)) {
                    continue;
                }
                parsedSegments.push({ content, isRetracted, customTime, type: segmentType, cardData });
            }

            if (!hasStructuredSegments && fullAiResponseText.trim() !== '') {
                parsedSegments.push({ content: fullAiResponseText.trim(), isRetracted: false, customTime: null, type: 'text', cardData: null });
            }

            console.log("Final Parsed Segments:", parsedSegments);
            console.log("Final Parsed Moment Comments:", momentComments);
            console.log("--- End Parsing AI Response ---");
            return { segments: parsedSegments, innerVoice: innerVoice, essay: essay, momentComments: momentComments, newMoments: newMoments };
        }
        
        async function displayNewFriendMessages(parsedData, isAutoReply = false, baseTimestamp = Date.now(), preventScroll = false) {
            const { segments, innerVoice, essay } = parsedData;
            
            currentInnerVoice = innerVoice; 
            document.getElementById('inner-voice-display').textContent = currentInnerVoice;

            const aiProvidedEssay = (essay && essay !== '暂无随笔。' && essay.trim() !== '');

            if (aiProvidedEssay) {
                const essayChanged = essay !== friendData.currentEssay;
                if (essayChanged) {
                    friendData.currentEssay = essay; 
                    await putData('friendData', friendData); // Save updated friendData
                }
                document.getElementById('essay-display').textContent = essay;

                showNotification(`${friendData.nickname || friendData.name} 新增了一条随笔`); 
            } else {
                document.getElementById('essay-display').textContent = friendData.currentEssay;
            }

            let visualDisplayDelay = 0;
            let lastSegmentTimestamp = baseTimestamp;

            for (const segment of segments) {
                // 新增：检查并跳过仅包含时间戳的消息
                const timestampRegex = /^\[时间: \d{1,2}\/\d{1,2} \d{2}:\d{2}\]$/;
                if (segment.type === 'text' && timestampRegex.test(segment.content.trim())) {
                    console.log('Skipping timestamp-only message:', segment.content);
                    continue; // 跳过此段，继续处理下一段
                }

                let segmentTimestamp;
                let displayTimeOverride = null;

                if (isAutoReply && segment.customTime) {
                    displayTimeOverride = segment.customTime;
                    const [hours, minutes] = segment.customTime.split(':').map(Number);
                    
                    let tempDate = new Date(lastSegmentTimestamp);
                    tempDate.setHours(hours, minutes, 0, 0);

                    if (tempDate.getTime() < lastSegmentTimestamp) {
                        tempDate.setDate(tempDate.getDate() + 1);
                    }
                    segmentTimestamp = tempDate.getTime();
                    lastSegmentTimestamp = segmentTimestamp;
                } else {
                    segmentTimestamp = Date.now(); 
                }
                
                // 对于卡片消息，content 存储的是 stringified JSON，cardData 存储的是对象
                const contentToSave = segment.type === 'card' ? JSON.stringify(segment.cardData) : segment.content;

                const msgId = await saveBubbleToHistory(
                    contentToSave,
                    'received',
                    segmentTimestamp,
                    segment.isRetracted,
                    isAutoReply,
                    displayTimeOverride,
                    segment.type,
                    segment.cardData // 传递 cardData 对象
                );

                await new Promise(resolve => {
                    setTimeout(() => {
                        // 传递完整的 bubbleData 对象给 addBubbleToDOM
                        addBubbleToDOM({
                            messageId: msgId,
                            content: contentToSave,
                            type: 'received',
                            isRetracted: segment.isRetracted,
                            isAutoReply: isAutoReply,
                            timestamp: segmentTimestamp,
                            displayTimeOverride: displayTimeOverride,
                            segmentType: segment.type,
                            cardData: segment.cardData // 确保 cardData 被传递
                        }, preventScroll);
                        resolve();
                    }, visualDisplayDelay);
                });
                visualDisplayDelay += 400;
            }
        }

        function scrollToBottom() {
            chatArea.scrollTop = chatArea.scrollHeight;
        }
        
        function openModal(modal) {
            modal.classList.add('active');
        }
        
        function closeModal(modal) {
            modal.classList.remove('active');
        }
        
                /**
         * 显示自定义确认弹窗。
         * @param {string} title - 弹窗标题。
         * @param {string} message - 弹窗显示的消息内容。
         * @param {function} onConfirm - 点击“确定”按钮时的回调函数。
         * @param {function} onCancel - 点击“取消”按钮或关闭弹窗时的回调函数。
         * @param {string} [confirmText='确定'] - 确定按钮的文本。
         * @param {string} [cancelText='取消'] - 取消按钮的文本。
         */
        function showCustomConfirm(title, message, onConfirm, onCancel, confirmText = '确定', cancelText = '取消') {
            customConfirmTitle.textContent = title;
            customConfirmMessage.textContent = message;
            customConfirmConfirmBtn.textContent = confirmText;
            customConfirmCancelBtn.textContent = cancelText;

            _onConfirmCallback = onConfirm;
            _onCancelCallback = onCancel;

            openModal(customConfirmModal);
        }

        /**
         * 隐藏自定义确认弹窗并清除回调。
         */
        function hideCustomConfirm() {
            closeModal(customConfirmModal);
            _onConfirmCallback = null;
            _onCancelCallback = null;
        }
        
        async function saveUserData() {
            userData.name = document.getElementById('user-name').value || '我';
            userData.gender = document.getElementById('user-gender').value;
            userData.avatar = document.getElementById('user-avatar-preview').src;
            userData.background = document.getElementById('user-background').value;
            
            await putData('userData', userData);
            closeModal(userModal);
        }

        function buildFriendPersonaPrompt() {
            const playerAddressForAI = friendData.playerAddress || userData.name;
            let personaPrompt = `你现在需要扮演一个名为"${friendData.name}"的角色。
你的性别是${friendData.gender === 'male' ? '男' : (friendData.gender === 'female' ? '女' : '其他')}。
你的喜好是：${friendData.likes || '无'}。
你的厌恶是：${friendData.dislikes || '无'}。
你的习惯是：${friendData.habits || '无'}。
你对用户的称呼是：${friendData.playerAddress || '无'}。
你的背景资料是：${friendData.background || '无'}。

与你对话的用户名为"${userData.name}"。
用户的性别是${userData.gender === 'male' ? '男' : (userData.gender === 'female' ? '女' : '其他')}。
用户的背景资料是：${userData.background || '无'}。

请根据这些信息，以"${friendData.nickname || friendData.name}"的身份与用户"${playerAddressForAI}"进行自然的对话。**在称呼上不要混淆用户和你的性别**，**你必须仔细阅读并理解整个聊天记录，以确保你的回复在情感、逻辑和事实上与之前的对话没有前后矛盾**。尽量避免说出和上一次回复时重复度较高的话。
**请将你的回复拆分成多个通畅的短句**
**重要短句格式说明：**
1.  **普通回复**：每个短句都用英文双引号包裹，并紧密连接，例如："你好！""今天天气真好""昨天的球赛你看了吗"。**不要以逗号作为短句的最后一个字符**。最多拆分成6条，且要确保每个短句读起来是连贯的。性格越冷淡的角色回复内容越简短，短句越少。
2.  **撤回消息**：如果你想表达某种情绪或者说出一些角色会后悔的话或者不小心说出真心话，请将该短句用花括号{}包裹，例如：{你真的很吵}。一次回复不要超过2句撤回。**撤回消息禁止被""或者“”包裹**
3.  **卡片消息**：当你想分享一类卡片消息（如：定位分享、日历分享、歌曲分享、或者其他有趣的可以用卡片发出来的分享内容）时，请使用以下格式：『分享类型|分享标题|分享内容简介』。
- 分享类型：例如“图片分享”、“音乐分享”、“录音分享”、“地点分享”、“文件分享”这样的名词，或者“哔哩哔哩”、“小红书”、“饿了么”这样的软件名。
- 分享标题：卡片的标题，简洁明了。
- 分享内容简介：分享内容是什么，如歌词内容，视频内容，不超过25字。
- 例如：『音乐分享|周杰伦 - 晴天|故事的小黄花，从出生那年就飘着。』
4.  **红包消息**：如果你想给用户发红包，请使用以下格式：[红包|红包名字|金额]。
- 红包名字：红包的名称，例如“恭喜发财”、“请你喝奶茶”。
- 金额：红包的金额，必须是正数，可以是整数或小数（最多两位小数），例如“88”、“30.50”。红包的金额取决于人物设定的财力，但是不要太离谱。
- 例如：[红包|恭喜发财|88￥] 或者 [红包|请你喝奶茶|30￥]。
5.  **语音消息**：如果你想发送语音消息或者你认为此时的语境下更适合发语音表达情感或更方便，请使用以下格式：[语音|语音时长|语音内容]。
- 语音时长：语音的持续时间，格式为“XXs”，例如“13s”。语音时长必须是正整数，且**最长不超过60s**。
- 语音内容：语音的文字内容，即语音转文字后的内容。
- 例如：[语音|13s|太好了！那我们下午三点在公司会议室详细讨论]。
`;

            if (appSettings.emojiDisplayMode === 'image') {
                // AI好友只被允许使用 FRIEND_EMOJI_MAP 中的表情包
                const allowedEmojiList = Object.entries(FRIEND_EMOJI_MAP).map(([id, name]) => `-   ${name}：${id}`).join('\n    ');
                personaPrompt += `
6.  **表情包**：如果你想用表情包表达心情，请使用以下格式：<表情>表情包id</表情>。例如：<表情>werDx2</表情>。请注意，表情包应该作为一个独立的短句出现，不要与双引号消息、撤回消息或卡片消息紧密连接。你只能使用以下表情包ID（冒号左边的非中文字符串，如werDx2），如果下面没有能表达你想法或没有符合人物性格的表情包，就不要使用表情包，也**一定不能使用虚构的表情包id**：
    ${allowedEmojiList}
`;
            } else if (appSettings.emojiDisplayMode === 'none') {
                personaPrompt += `
6.  **表情包**：你不需要使用任何表情包。
`;
            }

            personaPrompt += `
7.  **心声（必选）**：在你的回复的最后，请一定要添加一段不超过30字的心声，格式为：【心声：你的心声内容】。**一次回复只需要存在一段心声**，这段心声是你的内心独白，你要表现出此时最真实的想法。例如："很高兴见到你！""希望我们能成为好朋友。"【心声：他看起来很友善，我喜欢。】
8.  **随笔（可选）**：你有可能在回复的最后，额外写一段随笔，格式为「随笔：你的随笔内容」。这段随笔是你在当前情境下，有感而发的一些思考或经历，可以与用户对话内容相关（此时应该用“她/他”或你对用户的昵称来称呼用户），也可以是独立的小故事或心情记录。字数请控制在50到250字之间，不要超过250字。例如：「随笔：今天天气真好，我在窗边看到一只小鸟，它在枝头跳来跳去，好像在寻找什么。突然觉得生活中的小确幸无处不在，只要用心去发现。希望明天也能有这样美好的瞬间。」
9.  **禁止使用没有提到的格式**
10. **朋友圈动态 (可选)**：当你被要求生成朋友圈动态时或在回复中想要发朋友圈时，使用以下嵌套格式，**每条朋友圈要使用新的嵌套，以表明这是不同的朋友圈动态**：
<朋友圈>
【发帖人id|内容|时间】
〖朋友圈id|评论内容|时间〗
</朋友圈>
- 【发帖人id|内容|时间】是动态主体。发帖人可以是AI好友自己，也可以是玩家的其他朋友。内容可以是文本或包含[图片:图片描述]。
- 〖朋友圈id|评论内容|时间〗是该动态下的评论。朋友圈id可以是评论者的名字。评论内容不超过30字
- 例如：
<朋友圈>
【孟祁年|今天看到一只很可爱的橘猫，很像某个人。[图片:碎石板上，一只橘猫绕着拍摄的人的腿边蹭着]|6/17 13:43】
〖岁时|哪里的猫！我ruaruarua|6/17 13:48〗
〖白|哟，某人？哪个某人|6/17 14:12〗
</朋友圈>
11. **明确称呼，不要将ai好友的话当成玩家说的话，也不要将玩家的话当成ai好友说的话。**
`;
            friendData.personaPrompt = personaPrompt;
        }
        
        function updateFriendConfigModalUI() {
            document.getElementById('friend-name').value = friendData.name;
            document.getElementById('friend-nickname').value = friendData.nickname;
            document.getElementById('friend-gender').value = friendData.gender;
            document.getElementById('friend-likes').value = friendData.likes;
            document.getElementById('friend-dislikes').value = friendData.dislikes;
            document.getElementById('friend-habits').value = friendData.habits;
            document.getElementById('friend-player-address').value = friendData.playerAddress;
            document.getElementById('friend-background').value = friendData.background;
            document.getElementById('friend-opening-line').value = friendData.openingLine;
            document.getElementById('friend-avatar-preview').src = friendData.avatar;
            document.getElementById('friend-poke-action').value = friendData.pokeAction;
            document.getElementById('friend-poke-content').value = friendData.pokeContent;
        }

        async function saveFriendDataOnly() {
            friendData.name = document.getElementById('friend-name').value || '好友';
            friendData.nickname = document.getElementById('friend-nickname').value;
            friendData.gender = document.getElementById('friend-gender').value;
            friendData.likes = document.getElementById('friend-likes').value;
            friendData.dislikes = document.getElementById('friend-dislikes').value;
            friendData.habits = document.getElementById('friend-habits').value;
            friendData.playerAddress = document.getElementById('friend-player-address').value;
            friendData.background = document.getElementById('friend-background').value;
            friendData.openingLine = document.getElementById('friend-opening-line').value;
            friendData.avatar = document.getElementById('friend-avatar-preview').src;
            friendData.pokeAction = document.getElementById('friend-poke-action').value;
            friendData.pokeContent = document.getElementById('friend-poke-content').value;

            buildFriendPersonaPrompt();
            
            await putData('friendData', friendData);
            updateFriendNameInHeader();
            closeModal(friendModal);
            console.log('好友设置已保存，聊天记录未重置。');
        }

        async function saveFriendDataAndStartNewChat() {
            friendData.name = document.getElementById('friend-name').value || '好友';
            friendData.nickname = document.getElementById('friend-nickname').value;
            friendData.gender = document.getElementById('friend-gender').value;
            friendData.likes = document.getElementById('friend-likes').value;
            friendData.dislikes = document.getElementById('friend-dislikes').value;
            friendData.habits = document.getElementById('friend-habits').value;
            friendData.playerAddress = document.getElementById('friend-player-address').value;
            friendData.background = document.getElementById('friend-background').value;
            friendData.openingLine = document.getElementById('friend-opening-line').value;
            friendData.avatar = document.getElementById('friend-avatar-preview').src;
            friendData.pokeAction = document.getElementById('friend-poke-action').value;
            friendData.pokeContent = document.getElementById('friend-poke-content').value;

            buildFriendPersonaPrompt();
            
            await putData('friendData', friendData);
            updateFriendNameInHeader();
            closeModal(friendModal);
            
            chatArea.innerHTML = '';
            chatHistoryArray = [];
            await clearStore('chatHistory'); // 清空IndexedDB中的聊天记录
            userMessageCounter = 0;
            currentInnerVoice = '暂无心声。';
            friendData.currentEssay = '暂无随笔。';
            appSettings.lastAiReplyTimestamp = null;
            await putData('appSettings', appSettings);
            await putData('friendData', friendData); // Save friendData again after resetting essay

            momentsFeed = []; // 清空朋友圈数据
            await clearStore('momentsData'); // 清空IndexedDB中的朋友圈数据
            renderMomentsFeed(); // 渲染空的朋友圈

            // 重置番茄钟状态
            if (isPomodoroActive) {
                stopPomodoroTimer('reset'); // 停止计时器，但不触发AI回复
                pomodoroGoal = '';
                pomodoroStartTime = null;
                pomodoroEndTime = null;
                appSettings.pomodoro = { isActive: false, goal: '', startTime: null, endTime: null };
                await putData('appSettings', appSettings);
            }

            initiateChatWithPersona();
            console.log('好友设置已保存，并已开始新的聊天。');
        }
        
        async function saveApiConfig() {
            apiConfig.provider = document.getElementById('api-provider').value;
            apiConfig.url = document.getElementById('api-url').value;
            apiConfig.key = document.getElementById('api-key').value;
            
            if (apiConfig.provider === 'custom') {
                apiConfig.model = document.getElementById('api-model-input').value;
            } else {
                apiConfig.model = document.getElementById('api-model-select').value;
            }
            
            apiConfig.temperature = parseFloat(document.getElementById('temperature').value);
            apiConfig.personaReminderInterval = parseInt(document.getElementById('persona-reminder-interval').value, 10);
            if (isNaN(apiConfig.personaReminderInterval) || apiConfig.personaReminderInterval < 1) {
                apiConfig.personaReminderInterval = 1;
            }
            
            apiConfig.contextCharLimit = parseInt(document.getElementById('context-char-limit').value, 10) || 0;
            await putData('apiConfig', apiConfig);
            closeModal(apiModal);
        }
        
            /**
         * 填充自定义提示词列表弹窗
         */
        /**
         * 填充自定义提示词列表弹窗
         */
        function populateCustomPromptModal() {
            customPromptListContainer.innerHTML = ''; // 清空列表
            if (!appSettings.customPrompts || appSettings.customPrompts.length === 0) {
                customPromptListContainer.innerHTML = '<p style="text-align: center; color: #888;">暂无提示词，点击下方按钮新增一个吧！</p>';
                return;
            }

            appSettings.customPrompts.forEach((prompt, index) => {
                const card = document.createElement('div');
                card.className = 'prompt-card';
                card.dataset.promptId = prompt.id;

                const keywordsPreview = prompt.type === 'implicit' && prompt.keywords.length > 0
                    ? ` | 关键词: ${prompt.keywords.slice(0, 3).join(', ')}${prompt.keywords.length > 3 ? '...' : ''}`
                    : '';
                
                card.innerHTML = `
                    <div class="prompt-card-top-section">
                        <div class="prompt-card-number">${index + 1}</div>
                        <div class="prompt-card-content">
                            <div class="prompt-card-name">${prompt.name || '未命名提示词'}</div>
                            <div class="prompt-card-info">
         <span class="status-icon ${prompt.enabled ? 'enabled' : 'disabled'}">
           <i class="fas fa-power-off"></i> ${prompt.enabled ? '已启用' : '已禁用'}
         </span>
         <span class="type-icon ${prompt.type}">
           <i class="fas ${prompt.type === 'explicit' ? 'fa-eye' : 'fa-low-vision'}"></i> ${prompt.type === 'explicit' ? '显性' : '隐性'}
         </span>
         <span>${keywordsPreview}</span>
                            </div>
                        </div>
                    </div>
                    <div class="prompt-card-actions">
                        <button class="btn-secondary view-prompt-btn">查看</button>
                        <button class="btn-primary edit-prompt-btn">修改</button>
                        <button class="btn-secondary delete-prompt-btn">删除</button>
                    </div>
                `;
                
                // 绑定事件
                card.querySelector('.view-prompt-btn').addEventListener('click', () => openViewPromptModal(prompt.id));
                card.querySelector('.edit-prompt-btn').addEventListener('click', () => openEditPromptModal(prompt.id));
                card.querySelector('.delete-prompt-btn').addEventListener('click', () => deleteCustomPrompt(prompt.id));

                customPromptListContainer.appendChild(card);
            });
        }

        /**
         * 打开查看提示词弹窗
         * @param {string} promptId - 要查看的提示词ID。
         */
        function openViewPromptModal(promptId) {
            const prompt = appSettings.customPrompts.find(p => p.id === promptId);
            if (!prompt) return;

            viewPromptTitle.textContent = `查看: ${prompt.name}`;
            viewPromptContent.textContent = prompt.content;
            openModal(viewPromptModal);
        }
        
        
        /**
         * 打开新增/编辑提示词弹窗
         * @param {string|null} promptId - 如果是编辑，则传入提示词ID；如果是新增，则为null。
         */
        function openEditPromptModal(promptId = null) {
            if (promptId) {
                // 编辑模式
                const prompt = appSettings.customPrompts.find(p => p.id === promptId);
                if (!prompt) return;

                editPromptTitle.textContent = '修改提示词';
                editPromptIdInput.value = prompt.id;
                editPromptNameInput.value = prompt.name;
                editPromptEnabledSwitch.checked = prompt.enabled;
                editPromptTypeSelect.value = prompt.type;
                editPromptKeywordsInput.value = prompt.keywords.join(',');
                editPromptContentInput.value = prompt.content;
            } else {
                // 新增模式
                editPromptTitle.textContent = '新增提示词';
                editPromptIdInput.value = ''; // ID为空表示新增
                editPromptNameInput.value = '';
                editPromptEnabledSwitch.checked = true;
                editPromptTypeSelect.value = 'explicit';
                editPromptKeywordsInput.value = '';
                editPromptContentInput.value = '';
            }

            // 根据类型显示/隐藏关键词输入框
            if (editPromptTypeSelect.value === 'implicit') {
                editPromptKeywordsGroup.style.display = 'block';
            } else {
                editPromptKeywordsGroup.style.display = 'none';
            }

            openModal(editPromptModal);
        }

        /**
         * 保存或更新一个自定义提示词
         */
        async function saveCustomPrompt() {
            const id = editPromptIdInput.value;
            const name = editPromptNameInput.value.trim() || '未命名提示词';
            const enabled = editPromptEnabledSwitch.checked;
            const type = editPromptTypeSelect.value;
            const keywords = editPromptKeywordsInput.value.trim()
                .split(',')
                .map(k => k.trim())
                .filter(k => k); // 移除空关键词
            const content = editPromptContentInput.value.trim();

            if (!content) {
                showNotification('提示词内容不能为空！');
                return;
            }

            if (id) {
                // 更新现有提示词
                const promptIndex = appSettings.customPrompts.findIndex(p => p.id === id);
                if (promptIndex > -1) {
                    appSettings.customPrompts[promptIndex] = { ...appSettings.customPrompts[promptIndex], name, enabled, type, keywords, content };
                }
            } else {
                // 新增提示词
                const newPrompt = {
                    id: `prompt-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                    name,
                    enabled,
                    type,
                    keywords,
                    content
                };
                appSettings.customPrompts.push(newPrompt);
            }

            await putData('appSettings', appSettings);
            closeModal(editPromptModal);
            populateCustomPromptModal(); // 刷新列表
            showNotification('提示词已保存！');
        }

        /**
         * 删除一个自定义提示词
         * @param {string} promptId - 要删除的提示词ID。
         */
        function deleteCustomPrompt(promptId) {
            showCustomConfirm(
                '删除确认',
                '确定要删除这个提示词吗？此操作不可撤销。',
                async () => {
                    appSettings.customPrompts = appSettings.customPrompts.filter(p => p.id !== promptId);
                    await putData('appSettings', appSettings);
                    populateCustomPromptModal(); // 刷新列表
                    showNotification('提示词已删除。');
                }
            );
        }
        

        // 更新API字段（模型选择框或输入框）
        function updateApiFields() {
            const provider = document.getElementById('api-provider').value;
            const apiUrlInput = document.getElementById('api-url');
            const modelSelect = document.getElementById('api-model-select');
            const modelInput = document.getElementById('api-model-input');

            // 清空现有选项
            modelSelect.innerHTML = '';

            if (provider === 'gemini') {
                apiUrlInput.value = 'https://generativelanguage.googleapis.com/v1beta/models/';
                modelSelect.style.display = 'block';
                modelInput.style.display = 'none';
                modelSelect.innerHTML = `
                    <option value="gemini-2.5-flash-preview-05-20">gemini-2.5-flash-preview-05-20</option>
                    <option value="gemini-2.5-pro-preview-05-20">gemini-2.5-pro-preview-05-20</option>
                    <option value="gemini-1.5-flash-latest">gemini-1.5-flash-latest</option>
                    <option value="gemini-1.5-pro-latest">gemini-1.5-pro-latest</option>
                `;
                // 尝试设置之前保存的模型，否则设置默认值
                modelSelect.value = apiConfig.model && [...modelSelect.options].some(opt => opt.value === apiConfig.model) ? apiConfig.model : 'gemini-2.5-flash-preview-05-20';
            } else if (provider === 'siliconflow') {
                apiUrlInput.value = 'https://api.siliconflow.cn/v1/chat/completions';
                modelSelect.style.display = 'block';
                modelInput.style.display = 'none';
                modelSelect.innerHTML = `
                    <option value="deepseek-ai/DeepSeek-V3">DeepSeek-V3</option>
                    <option value="Qwen/Qwen2-7B-Instruct">Qwen2-7B-Instruct</option>
                    <option value="Qwen/Qwen2-72B-Instruct">Qwen2-72B-Instruct</option>
                    <option value="01-ai/Yi-1.5-34B-Chat">Yi-1.5-34B-Chat</option>
                    <option value="mistralai/Mistral-7B-Instruct-v0.2">Mistral-7B-Instruct-v0.2</option>
                    <option value="mistralai/Mixtral-8x7B-Instruct-v0.1">Mixtral-8x7B-Instruct-v0.1</option>
                `;
                modelSelect.value = apiConfig.model && [...modelSelect.options].some(opt => opt.value === apiConfig.model) ? apiConfig.model : 'deepseek-ai/DeepSeek-V3';
            } else if (provider === 'paioupu') { // 新增派欧云提供商
                apiUrlInput.value = 'https://api.ppinfra.com/v3/openai';
                modelSelect.style.display = 'block';
                modelInput.style.display = 'none';
                modelSelect.innerHTML = `
                    <option value="deepseek/deepseek-v3">deepseek/deepseek-v3</option>
                `;
                modelSelect.value = apiConfig.model && [...modelSelect.options].some(opt => opt.value === apiConfig.model) ? apiConfig.model : 'deepseek/deepseek-v3';
            } else if (provider === 'volcano') { // 新增火山提供商
                apiUrlInput.value = 'https://ark.cn-beijing.volces.com/api/v3';
                modelSelect.style.display = 'none'; // 火山模型名是用户自定义的
                modelInput.style.display = 'block';
                modelInput.value = apiConfig.model || ''; // 恢复保存的自定义模型
            } else { // custom
                apiUrlInput.value = apiConfig.url || ''; // 保留现有自定义URL
                modelSelect.style.display = 'none';
                modelInput.style.display = 'block';
                modelInput.value = apiConfig.model || ''; // 恢复保存的自定义模型
            }
        }

        async function initiateChatWithPersona() {
            const typingIndicatorContainer = document.createElement('div');
            typingIndicatorContainer.className = 'message received';
            typingIndicatorContainer.innerHTML = `
                <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                <div class="message-content">
                    <div class="name">${friendData.nickname || friendData.name}</div>
                    <div class="typing-indicator">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            `;
            chatArea.appendChild(typingIndicatorContainer);
            scrollToBottom();

            const openingContext = friendData.openingLine && friendData.openingLine.trim() !== ''
                ? friendData.openingLine.trim()
                : `你主动向玩家“${userData.name}”打个招呼，开始新的聊天。`;

            // *** 修改后的提示词，结构更清晰，防止AI误解 ***
            const initialUserPrompt = `[系统指令]: 这是一个新对话的开场。请你完全代入你的角色，根据结合以下资料，向玩家“${userData.name}”发出消息。不要对这个指令本身做出任何评论，直接开始角色扮演，并严格遵循回复的消息格式。
[其他资料]: ${openingContext}`;
            console.log("生成开场白的指令:", initialUserPrompt);

            try {
                const aiResponseText = await getApiResponse('initial', initialUserPrompt);
                const parsedAiData = parseAiResponse(aiResponseText);

                // 核心修改：在显示第一条新消息前移除“正在输入”提示
                if (typingIndicatorContainer.parentNode === chatArea) {
                    chatArea.removeChild(typingIndicatorContainer);
                }

                // 如果AI没有返回任何有效消息段，则显示错误提示
                if (!parsedAiData || !parsedAiData.segments || parsedAiData.segments.length === 0) {
                    throw new Error("AI返回了空或无法解析的开场白内容。");
                }

                await displayNewFriendMessages(parsedAiData, false, Date.now());

                appSettings.lastAiReplyTimestamp = Date.now();
                await putData('appSettings', appSettings);
                setFriendStatus('online');

            } catch (error) {
                console.error('初始化聊天失败:', error);
                const errorMessage = '抱歉，无法初始化聊天。请检查API配置或开场白内容。';
                displayTemporaryErrorBubble(errorMessage);
            } finally {
                // 确保即使在try块中已移除，这里也不会报错，作为最终保障
                if (typingIndicatorContainer && typingIndicatorContainer.parentNode === chatArea) {
                    chatArea.removeChild(typingIndicatorContainer);
                }
            }
        }

        function formatTimeDifference(milliseconds) {
            const seconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            let result = [];
            if (days > 0) {
                result.push(`${days}天`);
            }
            if (hours % 24 > 0) {
                result.push(`${hours % 24}小时`);
            }
            if (minutes % 60 > 0 && days === 0 && hours % 24 === 0) {
                result.push(`${minutes % 60}分钟`);
            }
            if (result.length === 0) {
                if (seconds > 0) {
                    return `${seconds}秒`;
                }
                return "刚刚";
            }
            return result.join('');
        }

        async function checkAndTriggerAutoReply() {
            if (!appSettings.autoReplyEnabled || appSettings.lastAiReplyTimestamp === null) {
                console.log('自动回复未开启或无上次回复时间。');
                return;
            }

            const threeHours = 3 * 60 * 60 * 1000;
            const currentTime = Date.now();
            const timeDiff = currentTime - appSettings.lastAiReplyTimestamp;
            const formattedTimeDiff = formatTimeDifference(timeDiff);

            if (timeDiff >= threeHours) {
                console.log('时间间隔超过3小时，触发自动回复。');
                const autoReplyPrompt = `对方上次和你聊天时间是 ${new Date(appSettings.lastAiReplyTimestamp).toLocaleString()}，距离现在已经过去了${formattedTimeDiff}。请你根据你的人设，说一些在这段时间里你可能会对用户说的话，也可能是这段时间内你遇到的新鲜的事，想和用户分享。这些话不一定是同一时间发的，有时候只隔了一两分钟，有可能你可能隔了十几二十分钟才发下一条，所以注意消息的口吻。**禁止超出这个时间范围，禁止出现比现在时间还要晚的时间**，如果对方离开的时间只有几个小时或者只是晚上到白天(睡觉)，可以不用发很多条消息。
                但请注意，你在发消息的同时，要符合人物设定和历史记录，禁止出现前后冲突（如：历史聊天中提醒玩家去睡觉，但却在这段消息内抱怨玩家睡太早，这是前后冲突）、禁止出现严重不符合人物作息的情况（你扮演的人物是有自己的身份资料的，也需要自己的休息时间，因此时间设定上要有逻辑性）
                请严格遵循消息格式：
                用英文双引号包裹回复内容，每个短句后紧跟"|HH:MM"表示该消息的发送时间（例如："嗯？你觉得怎么样？|22:25""已经睡了吗？|22:40""好吧，晚安|22:45""明天见|22:46"），时间应在对方离开后的合理时间段内，并确保时间递增。**禁止超出这个时间范围，禁止出现比现在时间还要晚的时间**，禁止出现上一条短句比下一条短句时间更晚的情况。**最后附上心声【心声：心声内容不超过30字】(只能出现一次)`;

                const typingIndicatorContainer = document.createElement('div');
                typingIndicatorContainer.className = 'message received';
                typingIndicatorContainer.innerHTML = `
                    <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                    <div class="message-content">
                        <div class="name">${friendData.nickname || friendData.name}</div>
                        <div class="typing-indicator">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                `;
                chatArea.appendChild(typingIndicatorContainer);
                scrollToBottom();

                try {
                    const aiResponseText = await getApiResponse('autoReply', autoReplyPrompt);
                    const parsedAiData = parseAiResponse(aiResponseText);
                    
                    // 核心修改：在显示第一条新消息前移除“正在输入”提示
                    if (typingIndicatorContainer.parentNode === chatArea) {
                        chatArea.removeChild(typingIndicatorContainer);
                    }
                    
                    await displayNewFriendMessages(parsedAiData, true, appSettings.lastAiReplyTimestamp);

                    appSettings.lastAiReplyTimestamp = Date.now();
                    await putData('appSettings', appSettings);
                    setFriendStatus('online');

                } catch (error) {
                    // 确保移除提示
                    if (typingIndicatorContainer.parentNode === chatArea) {
                        chatArea.removeChild(typingIndicatorContainer);
                    }
                    console.error('自动回复失败:', error);
                    const errorMessage = '抱歉，自动回复失败。请检查API配置或稍后再试。';
                    displayTemporaryErrorBubble(errorMessage);
                }
            } else {
                console.log('时间间隔不足3小时，不触发自动回复。');
            }
        }
        /**
         * 获取API回复的辅助函数，用于格式化单条消息以计算长度。
         * @param {object} bubble - 聊天历史中的单个消息对象。
         * @returns {string} - 格式化后用于API请求的内容。
         */
        function getFormattedContentForApi(bubble) {
            let formattedContent = '';
            try {
                const data = bubble.cardData;
                switch (bubble.segmentType) {
                    case 'red-packet':
                        formattedContent = `[红包|${data.name}|${data.amount}￥]`;
                        break;
                    case 'voice':
                        formattedContent = `[语音|${data.duration}|${data.content}]`;
                        break;
                    case 'image':
                        // 始终只发送描述，避免发送图片数据
                        formattedContent = `[图片：${data.description || '无描述'}]`;
                        break;
                    case 'emoji-image':
                        formattedContent = `<表情>${bubble.content}</表情>`;
                        break;
                    case 'card':
                        formattedContent = `『${data.shareType}|${data.shareTitle}|${data.shareDescription}』`;
                        break;
                    default: // 'text'
                        // 普通文本消息用双引号包裹，或使用原始content
                        formattedContent = bubble.isRetracted ? `{${bubble.content}}` : `"${bubble.content}"`;
                        break;
                }
            } catch (e) {
                console.warn(`格式化消息内容失败 (messageId: ${bubble.messageId})，将使用原始文本。`, e);
                formattedContent = `"${bubble.content}"`; // 备用方案也包裹引号
            }
            return formattedContent;
        }

        // 核心函数：调用API获取回复
        // contextType: 'chat' (常规聊天), 'initial' (首次开场白), 'autoReply' (自动回复), 'poke' (拍一拍), 'momentComment' (朋友圈评论), 'momentsRefresh' (刷新朋友圈), 'pomodoroComplete', 'pomodoroAbandon'
        // promptContent: 针对特定contextType的额外提示内容
        /**
         * 格式化时间戳为 "月/日 HH:MM" 格式
         * @param {number} timestamp - 时间戳
         * @returns {string} 格式化后的时间字符串
         */
        function formatTimestampForAI(timestamp) {
            const date = new Date(timestamp);
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${month}/${day} ${hours}:${minutes}`;
        }
        
        async function getApiResponse(contextType, promptContent = null, abortSignal = null) {
            const { provider, url, key, model, temperature, personaReminderInterval, contextCharLimit } = apiConfig;
            let apiUrl = url;
            let headers = {
                'Content-Type': 'application/json'
            };
            let body = {}; // Initialize body
            let messagesForApi = [];
            let geminiContents = [];

            // 获取当前时间
            const currentTimeString = `[当前时间：${formatTimestampForAI(Date.now())}]`;

            // --- 新版：动态构建完整的系统/人设提示 ---
            let fullPersonaPrompt = friendData.personaPrompt;
            
            const lastUserMessage = chatHistoryArray.filter(m => m.type === 'sent').pop()?.content || '';

            if (appSettings.customPrompts && Array.isArray(appSettings.customPrompts)) {
                appSettings.customPrompts.forEach((prompt, index) => {
                    if (!prompt.enabled || !prompt.content) {
                        return; // 跳过禁用或内容为空的提示词
                    }

                    let triggered = false;
                    if (prompt.type === 'explicit') {
                        triggered = true; // 显性提示词总是触发
                    } else if (prompt.type === 'implicit' && prompt.keywords.length > 0) {
                        triggered = prompt.keywords.some(keyword => lastUserMessage.includes(keyword));
                    }

                    if (triggered) {
                        fullPersonaPrompt += `\n\n[附加提示: ${prompt.name}]: ${prompt.content}`;
                    }
                });
            }

            const isDirectPromptContext = ['momentComment', 'initial', 'poke', 'pomodoroComplete', 'pomodoroAbandon', 'momentsRefresh'].includes(contextType);

            // *** 根据字符数限制上下文 ***
            let historyForApi = [];
            if (!isDirectPromptContext) {
                if (contextCharLimit > 0) {
                    let currentLength = 0;
                    for (let i = chatHistoryArray.length - 1; i >= 0; i--) {
                        const bubble = chatHistoryArray[i];
                        if (bubble.type === 'event') continue;

                        const formattedContent = getFormattedContentForApi(bubble);
                        if (currentLength + formattedContent.length > contextCharLimit) {
                            break;
                        }
                        historyForApi.unshift(bubble);
                        currentLength += formattedContent.length;
                    }
                } else {
                    historyForApi = [...chatHistoryArray];
                }
            }
            
            // --- 消息合并逻辑 ---
            const mergedMessages = [];
            let currentBlock = null;

            if (historyForApi.length > 0) {
                historyForApi.filter(bubble => bubble.type !== 'event').forEach(bubble => {
                    const role = bubble.type === 'sent' ? userData.name : (friendData.nickname || friendData.name);
                    const formattedContent = getFormattedContentForApi(bubble);
                    
                    if (!currentBlock || currentBlock.role !== role) {
                        // 如果有上一个块，先推入数组
                        if (currentBlock) {
                            mergedMessages.push(currentBlock);
                        }
                        // 开始一个新块，包含role, content, 和 timestamp
                        currentBlock = {
                            role: role,
                            content: formattedContent,
                            timestamp: bubble.timestamp // 记录第一条消息的时间戳
                        };
                    } else {
                        // 追加内容到当前块
                        currentBlock.content += ` ${formattedContent}`;
                        // 关键：更新时间戳为这个连续块里最新一条消息的时间戳
                        currentBlock.timestamp = bubble.timestamp; 
                    }
                });
                // 推入最后一个块
                if (currentBlock) {
                    mergedMessages.push(currentBlock);
                }
            }

            // --- 构建 API 请求体 ---
            if (['siliconflow', 'paioupu', 'volcano', 'custom'].includes(provider)) {
                headers['Authorization'] = `Bearer ${key}`;
                if (!apiUrl.endsWith('/chat/completions')) {
                    apiUrl = apiUrl.endsWith('/') ? `${apiUrl}chat/completions` : `${apiUrl}/chat/completions`;
                }

                if (isDirectPromptContext) {
                    messagesForApi.push({ role: 'system', content: fullPersonaPrompt });
                    messagesForApi.push({ role: 'user', content: `${currentTimeString} ${promptContent}` });
                } else {
                    const includePersonaInThisTurn = (userMessageCounter > 0 && (userMessageCounter - 1) % personaReminderInterval === 0);
                    if (includePersonaInThisTurn && fullPersonaPrompt) {
                        messagesForApi.push({ role: 'system', content: fullPersonaPrompt });
                    }

                    // 遍历结构化的 mergedMessages 来构建最终的 API 消息
                    mergedMessages.forEach(block => {
                        messagesForApi.push({
                            role: block.role === userData.name ? 'user' : 'assistant',
                            // 在这里，我们将干净的 content 和时间戳组合成最终发送给 AI 的字符串
                            content: `[时间: ${formatTimestampForAI(block.timestamp)}] ${block.content}`
                        });
                    });

                    if (promptContent) {
                        messagesForApi.push({ role: 'user', content: `${currentTimeString} ${promptContent}` });
                    }
                }

                body = { model, messages: messagesForApi, temperature };

            } else if (provider === 'gemini') {
                apiUrl += `${model}:generateContent?key=${key}`;
                
                if (isDirectPromptContext) {
                    geminiContents.push({
                        role: 'user',
                        parts: [{ text: `${fullPersonaPrompt}\n\n${currentTimeString} ${promptContent}` }]
                    });
                } else {
                    mergedMessages.forEach((block, index) => {
                        const isLastUserBlock = (block.role === userData.name) && (index === mergedMessages.length - 1);
                        // 在这里，我们将干净的 content 和时间戳组合成最终发送给 AI 的字符串
                        let finalContent = `[时间: ${formatTimestampForAI(block.timestamp)}] ${block.content}`;
                        const includePersonaInThisTurn = (userMessageCounter > 0 && (userMessageCounter - 1) % personaReminderInterval === 0);

                        if (isLastUserBlock) {
                             if (includePersonaInThisTurn && fullPersonaPrompt) {
                                finalContent = `${fullPersonaPrompt}\n\n${currentTimeString}\n${finalContent}`;
                            } else {
                                finalContent = `${currentTimeString}\n${finalContent}`;
                            }
                            if (promptContent) {
                                finalContent += `\n\n${promptContent}`;
                            }
                        }
                        
                        geminiContents.push({
                            role: block.role === userData.name ? 'user' : 'model',
                            parts: [{ text: finalContent }]
                        });
                    });
                    
                    if (mergedMessages.length === 0 && promptContent) {
                         geminiContents.push({ role: 'user', parts: [{ text: `${currentTimeString} ${promptContent}` }] });
                    }
                }

                body = {
                    contents: geminiContents,
                    generationConfig: { temperature }
                };
            } else {
                throw new Error('不支持的API提供商。');
            }

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body),
                    signal: abortSignal // 将取消信号传递给fetch
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API请求失败: ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`);
                }

                const data = await response.json();
                let fullResponseText;
                if (provider === 'gemini') {
                    if (data.candidates && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0].text) {
                        fullResponseText = data.candidates[0].content.parts[0].text;
                    } else {
                        console.warn("Gemini response format unexpected or empty. Safety block?", data);
                        fullResponseText = "【心声：我好像被什么东西限制了，说不出话来。】";
                    }
                } else if (['siliconflow', 'paioupu', 'volcano', 'custom'].includes(provider)) {
                    fullResponseText = data.choices[0].message.content;
                }
                return fullResponseText;
            } catch (error) {
                console.error('调用API时发生错误:', error);
                throw error;
            }
        }
        
        function handleImageUpload(event, previewId) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById(previewId).src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
                // 表情包卡片显示/隐藏
        function toggleEmojiCard() {
            isEmojiCardVisible = !isEmojiCardVisible;
            emojiCard.classList.toggle('active', isEmojiCardVisible);
            if (isEmojiCardVisible) {
                activateInputButton(emojiBtn); // 激活表情按钮
                renderEmojis();
                scrollToBottom(); // 确保卡片显示时聊天区域滚动到底部
            } else {
                deactivateInputButtons(); // 关闭时取消所有输入按钮的激活状态
            }
        }

        // 渲染表情包
        function renderEmojis() {
            emojiGrid.innerHTML = '';
            const emojiIds = Object.keys(PLAYER_EMOJI_MAP);
            const totalPages = Math.ceil(emojiIds.length / emojisPerPage);
            
            // 确保当前页码在有效范围内
            if (currentEmojiPage < 0) currentEmojiPage = 0;
            if (currentEmojiPage >= totalPages) currentEmojiPage = totalPages - 1;
            if (totalPages === 0) currentEmojiPage = 0; // Handle no emojis case

            const startIndex = currentEmojiPage * emojisPerPage;
            const endIndex = Math.min(startIndex + emojisPerPage, emojiIds.length);

            for (let i = startIndex; i < endIndex; i++) {
                const emojiId = emojiIds[i];
                const emojiName = PLAYER_EMOJI_MAP[emojiId];
                const emojiItem = document.createElement('div');
                emojiItem.className = 'emoji-item';
                emojiItem.dataset.emojiId = emojiId;
                emojiItem.title = emojiName; // Add title for hover tooltip
                emojiItem.innerHTML = `<img src="https://z.wiki/u/${emojiId}" alt="${emojiName}">`;
                emojiGrid.appendChild(emojiItem);
            }

            emojiPageInfo.textContent = `${totalPages === 0 ? 0 : currentEmojiPage + 1} / ${totalPages}`;
            prevEmojiPageBtn.disabled = currentEmojiPage === 0;
            nextEmojiPageBtn.disabled = currentEmojiPage >= totalPages - 1;
        }

        // 下一页表情包
        function goToNextEmojiPage() {
            const emojiIds = Object.keys(PLAYER_EMOJI_MAP);
            const totalPages = Math.ceil(emojiIds.length / emojisPerPage);
            if (currentEmojiPage < totalPages - 1) {
                currentEmojiPage++;
                renderEmojis();
            }
        }

        // 上一页表情包
        function goToPrevEmojiPage() {
            if (currentEmojiPage > 0) {
                currentEmojiPage--;
                renderEmojis();
            }
        }

        // 处理表情包点击事件并发送
        async function handleEmojiClick(event) {
            const emojiItem = event.target.closest('.emoji-item');
            if (emojiItem) {
                const emojiId = emojiItem.dataset.emojiId;
                const emojiName = PLAYER_EMOJI_MAP[emojiId] || '未知表情';
                
                const now = Date.now();
                const msgId = await saveBubbleToHistory(emojiId, 'sent', now, false, false, null, 'emoji-image');
                addBubbleToDOM({
                    messageId: msgId,
                    content: emojiId,
                    type: 'sent',
                    isRetracted: false,
                    isAutoReply: false,
                    timestamp: now,
                    displayTimeOverride: null,
                    segmentType: 'emoji-image',
                    cardData: null
                });

                userMessageCounter++;
                toggleEmojiCard();

                // --- AI 回复逻辑（根据开关决定是否执行）---
                if (appSettings.immediateReplyEnabled) {
                    const typingIndicatorContainer = document.createElement('div');
                    typingIndicatorContainer.className = 'message received';
                    typingIndicatorContainer.innerHTML = `
                        <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                        <div class="message-content">
                            <div class="name">${friendData.nickname || friendData.name}</div>
                            <div class="typing-indicator">
                                <span></span>
                                <span></span>
                                <span></span>
                            </div>
                        </div>
                    `;
                    chatArea.appendChild(typingIndicatorContainer);
                    scrollToBottom();

                    try {
                        const aiPrompt = `玩家发送了一个表情包，表情包的名称是“${emojiName}”，表情包id是“${emojiId}”。请你结合历史记录以及表情包名称，根据你的人设，对玩家发送的这个表情包做出回复。不要字面意思理解表情包的意思，例如表情包的名称可能是“花花送你”，但实际上玩家并不是真的要送你花，而是表达一种开心或者喜欢你的心情。**表情包的行为不完全等于玩家的真实行动，不要字面理解表情包意思**，因此你需要结合历史聊天和表情包名称综合分析玩家用意，最重要的是**不要脱离人设**`;
                        const aiResponseText = await getApiResponse('chat', aiPrompt);
                        const parsedAiData = parseAiResponse(aiResponseText);
                        
                        if (typingIndicatorContainer.parentNode === chatArea) {
                            chatArea.removeChild(typingIndicatorContainer);
                        }

                        await displayNewFriendMessages(parsedAiData, false, Date.now());

                        appSettings.lastAiReplyTimestamp = Date.now();
                        await putData('appSettings', appSettings);
                        setFriendStatus('online');

                    } catch (error) {
                        if (typingIndicatorContainer.parentNode === chatArea) {
                            chatArea.removeChild(typingIndicatorContainer);
                        }
                        console.error('AI回复表情包失败:', error);
                        const errorMessage = '抱歉，我暂时无法对表情包做出回应。';
                        displayTemporaryErrorBubble(errorMessage);
                    }
                }
            }
        }
        
        function createRippleEffect(e) {
            const ripple = document.createElement('div');
            ripple.className = 'ripple';
            ripple.style.left = e.clientX + 'px';
            ripple.style.top = e.clientY + 'px';
            document.body.appendChild(ripple);
            
            setTimeout(() => {
                ripple.remove();
            }, 800);
            
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const star = document.createElement('div');
                    star.className = 'star';
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 30 + Math.random() * 70;
                    const tx = Math.cos(angle) * distance;
                    const ty = Math.sin(angle) * distance;
                    
                    star.style.left = e.clientX + 'px';
                    star.style.top = e.clientY + 'px';
                    star.style.setProperty('--tx', tx + 'px');
                    star.style.setProperty('--ty', ty + 'px');
                    
                    const size = 3 + Math.random() * 7;
                    star.style.width = size + 'px';
                    star.style.height = size + 'px';
                    
                    const colors = ['#FFD700', '#FFA500', '#FF6347', '#87CEEB', '#9370DB'];
                    star.style.background = colors[Math.floor(Math.random() * colors.length)];
                    
                    document.body.appendChild(star);
                    
                    setTimeout(() => {
                        if (star.parentNode) {
                            star.remove();
                        }
                    }, 1200);
                }, i * 100);
            }
        }

        function applyInnerVoiceFont(fontKey) {
            let fontStack;
            switch (fontKey) {
                case 'ma-shan-zheng':
                    fontStack = "'Ma Shan Zheng', cursive, sans-serif";
                    break;
                case 'long-cang':
                    fontStack = "'Long Cang', cursive, serif";
                    break;
                case 'zcool-xiaowei':
                    fontStack = "'ZCOOL XiaoWei', serif";
                    break;
                case 'zcool-kuaile':
                    fontStack = "'ZCOOL KuaiLe', cursive";
                    break;
                case 'zcool-qingke-huangyou':
                    fontStack = "'ZCOOL QingKe HuangYou', cursive";
                    break;
                case 'liu-jian-mao-cao':
                    fontStack = "'Liu Jian Mao Cao', cursive";
                    break;
                case 'zhi-mang-xing':
                    fontStack = "'Zhi Mang Xing', cursive";
                    break;
                case 'zpix':
                    fontStack = "'Zpix', monospace";
                    break;
                case 'lxgw-wenkai-screen':
                    fontStack = "'LXGW WenKai Screen', sans-serif";
                    break;
                default:
                    fontStack = "'Ma Shan Zheng', cursive, sans-serif";
            }
            document.documentElement.style.setProperty('--inner-voice-font-family', fontStack);
        }

        function applyEssayFont(fontKey) {
            let fontStack;
            switch (fontKey) {
                case 'ma-shan-zheng':
                    fontStack = "'Ma Shan Zheng', cursive, sans-serif";
                    break;
                case 'long-cang':
                    fontStack = "'Long Cang', cursive, serif";
                    break;
                case 'zcool-xiaowei':
                    fontStack = "'ZCOOL XiaoWei', serif";
                    break;
                case 'zcool-kuaile':
                    fontStack = "'ZCOOL KuaiLe', cursive";
                    break;
                case 'zcool-qingke-huangyou':
                    fontStack = "'ZCOOL QingKe HuangYou', cursive";
                    break;
                case 'liu-jian-mao-cao':
                    fontStack = "'Liu Jian Mao Cao', cursive";
                    break;
                case 'zhi-mang-xing':
                    fontStack = "'Zhi Mang Xing', cursive";
                    break;
                case 'zpix':
                    fontStack = "'Zpix', monospace";
                    break;
                case 'lxgw-wenkai-screen':
                    fontStack = "'LXGW WenKai Screen', sans-serif";
                    break;
                default:
                    fontStack = "'Ma Shan Zheng', cursive, sans-serif";
            }
            document.documentElement.style.setProperty('--essay-font-family', fontStack);
        }
        
        /**
         * 应用全局字体
         * @param {string} fontKey - 字体键名
         */
        function applyGlobalFont(fontKey) {
            let fontStack;
            switch (fontKey) {
                case 'system-ui':
                    fontStack = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif";
                    break;
                case 'SimSun':
                    fontStack = "'SimSun', '宋体', serif";
                    break;
                case 'Zpix':
                    fontStack = "'Zpix', monospace";
                    break;
                case 'lxgw-wenkai-screen':
                default:
                    fontStack = "'LXGW WenKai Screen', sans-serif";
                    break;
            }
            document.body.style.fontFamily = fontStack;
        }

        /**
         * 保存并应用自定义主题
         */
        async function saveCustomTheme() {
            const newColors = customColorInputs.map(input => input.value);
            
            // 继承默认主题的辅助颜色，确保所有变量都已定义
            const newAuxColors = JSON.parse(JSON.stringify(themes['default'].auxiliaryColors));
            
            // --- 为自定义主题实现透明气泡效果 ---
            // 1. 获取用户选择的第2个和第4个颜色的RGB值
            const color2_rgb = hexToRgb(newColors[1]);
            const color4_rgb = hexToRgb(newColors[3]);

            // 2. 覆盖发送气泡的背景为半透明
            newAuxColors['--message-sent-bubble-bg-gradient'] = `rgba(${color2_rgb}, 0.4)`;
            
            // 3. 覆盖发送气泡的文字颜色为深色，以保证可读性
            newAuxColors['--message-sent-bubble-text-color'] = 'var(--text-color-dark)';
            // --- 透明气泡效果设置结束 ---

            // 创建新的自定义主题对象
            const newCustomTheme = {
                name: '自定义主题',
                mainColors: newColors,
                auxiliaryColors: newAuxColors
            };

            // 更新并保存设置
            appSettings.customTheme = newCustomTheme;
            appSettings.currentTheme = 'custom'; // 将当前主题设置为自定义主题
            await putData('appSettings', appSettings);

            // 重新填充主题选项（包括新的自定义主题）并应用
            populateThemeOptions();
            applyTheme('custom');

            closeModal(customThemeModal);
            showNotification('自定义主题已保存并应用！');
        }
        

        /**
         * 更新所有用户发送的图片消息的显示状态（只显示最新的三张为图片）。
         * 并重新渲染受影响的消息气泡。
         */
        async function updateImageDisplayFlags() {
            const userImageMessages = chatHistoryArray.filter(
                b => b.type === 'sent' && b.segmentType === 'image'
            );

            // 按时间倒序排序
            userImageMessages.sort((a, b) => b.timestamp - a.timestamp);

            const messagesToUpdate = [];

            // 标记最新的三张图片为显示图片，其余为显示文本
            for (let i = 0; i < userImageMessages.length; i++) {
                const msg = userImageMessages[i];
                const shouldDisplayImage = i < 3;

                // 只有当displayImage状态发生改变时才更新并重新渲染
                if (msg.cardData.displayImage !== shouldDisplayImage) {
                    msg.cardData.displayImage = shouldDisplayImage;
                    messagesToUpdate.push(msg); // 收集需要更新的bubbleData
                }
            }

            // 批量更新IndexedDB并重新渲染DOM
            for (const msg of messagesToUpdate) {
                await putData('chatHistory', msg); // 更新IndexedDB
                addBubbleToDOM(msg); // 重新渲染DOM
            }
            scrollToBottom();
        }
        
        
        function showNotification(message) {
            essayNotificationText.textContent = message;
            essayNotification.classList.add('show');

            setTimeout(() => {
                essayNotification.classList.remove('show');
            }, 3000);
        }

        /**
         * 显示一个可点击的新消息顶部通知栏。
         * @param {Array<object>} segments - AI返回的聊天消息段落数组。
         */
        function showNewMessageNotification(segments) {
            if (!segments || segments.length === 0) return;

            // 1. 填充内容
            notificationAvatar.src = friendData.avatar;
            notificationTitle.textContent = friendData.nickname || friendData.name;

            // 提取第一条消息的内容作为预览
            let firstMessageContent = segments[0].content;
            const firstSegmentType = segments[0].type;
            if (firstSegmentType === 'emoji-image') {
                firstMessageContent = `[表情] ${PLAYER_EMOJI_MAP[firstMessageContent] || '新表情'}`;
            } else if (firstSegmentType === 'card' || firstSegmentType === 'red-packet' || firstSegmentType === 'voice' || firstSegmentType === 'image') {
                firstMessageContent = `[${segments[0].type.replace('-',' ')}]`; // e.g. [red packet]
            }
            notificationBody.textContent = firstMessageContent;

            // 2. 添加一次性点击事件监听器，点击后跳转到聊天界面
            newMessageNotification.addEventListener('click', function handleNotificationClick() {
                closeModal(momentsView); // 关闭朋友圈
                scrollToBottom(); // 滚动到最新消息
                newMessageNotification.classList.remove('show'); // 立即隐藏通知
                // 移除监听器，防止重复触发
                newMessageNotification.removeEventListener('click', handleNotificationClick);
            });

            // 3. 显示通知栏
            newMessageNotification.classList.add('show');

            // 4. 设置5秒后自动隐藏
            setTimeout(() => {
                newMessageNotification.classList.remove('show');
            }, 5000);
        }

        // 新增：番茄钟通知函数
        function showPomodoroNotification(message) {
            pomodoroNotificationText.textContent = message;
            pomodoroNotification.classList.add('show');
            setTimeout(() => {
                pomodoroNotification.classList.remove('show');
            }, 3000);
        }

        function updateFriendNameInHeader() {
            // 优先使用好友备注，如果备注为空则使用姓名
            const displayFriendName = friendData.nickname || friendData.name;
            friendNameDisplay.textContent = displayFriendName;
            // 更新心声弹窗的标题
            document.querySelector('#inner-voice-modal .modal-title').textContent = `${displayFriendName}的状态`;
        }

        function updateFriendStatusDisplay(forceRandom = false) {
            if (forceRandom) {
                const statuses = ['online', 'busy', 'offline'];
                friendStatus = statuses[Math.floor(Math.random() * statuses.length)];
            }
            setFriendStatus(friendStatus);
        }

        function setFriendStatus(status) {
            friendStatus = status;
            friendStatusDot.className = 'status-dot';
            friendStatusDot.classList.add(status);
        }

        function populatePersonaSelectionModal() {
            personaListContainer.innerHTML = '';

            // 合并预设角色和自定义角色
            const allPersonas = [...predefinedPersonas, ...(appSettings.customPersonas || [])];

            const totalPages = Math.ceil(allPersonas.length / personasPerPage);
            if (totalPages === 0) { // 如果没有任何角色
                personaListContainer.innerHTML = '<p style="text-align: center; color: #888;">暂无角色，快导入一个吧！</p>';
                document.getElementById('persona-page-info').textContent = '0 / 0';
                document.getElementById('prev-persona-page-btn').disabled = true;
                document.getElementById('next-persona-page-btn').disabled = true;
                return;
            }
            
            // 确保页码循环
            if (currentPersonaPage >= totalPages) currentPersonaPage = 0;
            if (currentPersonaPage < 0) currentPersonaPage = totalPages - 1;

            const startIndex = currentPersonaPage * personasPerPage;
            const endIndex = Math.min(startIndex + personasPerPage, allPersonas.length);
            const personasOnPage = allPersonas.slice(startIndex, endIndex);

            personasOnPage.forEach((persona, index) => {
                const isCustom = !predefinedPersonas.some(p => p.id === persona.id); // 判断是否为自定义角色
                const personaCard = document.createElement('div');
                personaCard.className = 'persona-selection-card';
                
                // 为自定义角色添加删除按钮
                const deleteButtonHtml = isCustom ? `
                    <button class="btn-secondary delete-btn" data-persona-id="${persona.id}" title="删除此导入角色">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                ` : '';

                personaCard.innerHTML = `
                    <img src="${persona.avatar}" alt="${persona.name}头像" class="avatar-preview">
                    <h4 class="persona-name-display">${persona.name} (${persona.nickname || '无备注'})</h4>
                    <p>${(persona.background || '').substring(0, 60)}...</p>
                    <div class="persona-selection-card-actions">
                        <button class="btn-secondary details-btn" data-persona-id="${persona.id}">详情</button>
                        <button class="btn-primary apply-btn" data-persona-id="${persona.id}">应用</button>
                        ${deleteButtonHtml}
                    </div>
                `;
                personaListContainer.appendChild(personaCard);
            });

            // 更新分页信息和按钮状态
            document.getElementById('persona-page-info').textContent = `${currentPersonaPage + 1} / ${totalPages}`;
            // 分页按钮在只有一页时也应该可用，以实现循环
            document.getElementById('prev-persona-page-btn').disabled = totalPages <= 1;
            document.getElementById('next-persona-page-btn').disabled = totalPages <= 1;

            // 重新绑定事件
            personaListContainer.querySelectorAll('.details-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const personaId = e.target.dataset.personaId;
                    const selectedPersona = allPersonas.find(p => p.id === personaId);
                    if (selectedPersona) showPersonaDetails(selectedPersona);
                });
            });

            personaListContainer.querySelectorAll('.apply-btn').forEach(button => {
                button.addEventListener('click', async (e) => {
                    const personaId = e.target.dataset.personaId;
                    const selectedPersona = allPersonas.find(p => p.id === personaId);
                    if (selectedPersona) {
                        await applyPersona(selectedPersona);
                        closeModal(personaSelectionModal);
                    }
                });
            });
            
            // 绑定删除按钮事件
            personaListContainer.querySelectorAll('.delete-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const personaId = e.target.closest('.delete-btn').dataset.personaId;
                    deleteCustomPersona(personaId);
                });
            });
        }

        function showPersonaDetails(persona) {
            document.getElementById('persona-detail-title').textContent = `${persona.name}的人设详情`;
            document.getElementById('persona-detail-avatar').src = persona.avatar;
            document.getElementById('persona-detail-name').textContent = persona.name;
            document.getElementById('persona-detail-nickname').textContent = persona.nickname || '无';
            document.getElementById('persona-detail-gender').textContent = persona.gender === 'male' ? '男' : (persona.gender === 'female' ? '女' : '其他');
            document.getElementById('persona-detail-likes').textContent = persona.likes || '无';
            document.getElementById('persona-detail-dislikes').textContent = persona.dislikes || '无';
            document.getElementById('persona-detail-habits').textContent = persona.habits || '无';
            document.getElementById('persona-detail-player-address').textContent = persona.playerAddress || '无';
            document.getElementById('persona-detail-background').innerHTML = persona.background || '无'; // Use innerHTML for line breaks
            document.getElementById('persona-detail-poke-action').textContent = persona.pokeAction || '无';
            document.getElementById('persona-detail-poke-content').textContent = persona.pokeContent || '无';
            document.getElementById('persona-detail-opening-line').textContent = persona.openingLine || '无';

            const applyBtn = document.getElementById('apply-persona-from-detail-btn');
            applyBtn.dataset.personaId = persona.id; // Store persona ID for apply button

            openModal(personaDetailModal);
        }

        async function applyPersona(persona) {
            friendData.name = persona.name;
            friendData.nickname = persona.nickname;
            friendData.avatar = persona.avatar;
            friendData.gender = persona.gender;
            friendData.likes = persona.likes;
            friendData.dislikes = persona.dislikes;
            friendData.habits = persona.habits;
            friendData.playerAddress = persona.playerAddress;
            friendData.background = persona.background;
            friendData.openingLine = persona.openingLine;
            friendData.pokeAction = persona.pokeAction;
            friendData.pokeContent = persona.pokeContent;
            friendData.currentEssay = '暂无随笔。'; // Reset essay when applying new persona

            buildFriendPersonaPrompt();
            await putData('friendData', friendData);
            updateFriendNameInHeader();

            chatArea.innerHTML = '';
            chatHistoryArray = [];
            await clearStore('chatHistory'); // 清空IndexedDB中的聊天记录
            userMessageCounter = 0;
            currentInnerVoice = '暂无心声。';
            appSettings.lastAiReplyTimestamp = null;
            await putData('appSettings', appSettings);
            await putData('friendData', friendData); // Save friendData again after resetting essay

            momentsFeed = []; // 清空朋友圈数据
            await clearStore('momentsData'); // 清空IndexedDB中的朋友圈数据
            renderMomentsFeed(); // 渲染空的朋友圈

            // 重置番茄钟状态
            if (isPomodoroActive) {
                stopPomodoroTimer('reset'); // 停止计时器，但不触发AI回复
                pomodoroGoal = '';
                pomodoroStartTime = null;
                pomodoroEndTime = null;
                appSettings.pomodoro = { isActive: false, goal: '', startTime: null, endTime: null };
                await putData('appSettings', appSettings);
            }

            initiateChatWithPersona();
            showNotification(`已应用人设：${persona.name}`);
        }

        function goToNextPersonaPage() {
            currentPersonaPage++;
            populatePersonaSelectionModal();
        }

        function goToPrevPersonaPage() {
            currentPersonaPage--;
            populatePersonaSelectionModal();
        }

        async function exportFriendData() {
            // 从当前的好友设置弹窗中获取最新的（但可能未保存的）数据
            const currentFriendSettings = {
                name: document.getElementById('friend-name').value || '好友',
                nickname: document.getElementById('friend-nickname').value,
                avatar: document.getElementById('friend-avatar-preview').src,
                gender: document.getElementById('friend-gender').value,
                likes: document.getElementById('friend-likes').value,
                dislikes: document.getElementById('friend-dislikes').value,
                habits: document.getElementById('friend-habits').value,
                playerAddress: document.getElementById('friend-player-address').value,
                background: document.getElementById('friend-background').value,
                openingLine: document.getElementById('friend-opening-line').value,
                pokeAction: document.getElementById('friend-poke-action').value,
                pokeContent: document.getElementById('friend-poke-content').value,
            };

            const jsonString = JSON.stringify(currentFriendSettings, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentFriendSettings.name || '角色'}_persona.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showNotification('角色文件已开始下载！');
        }

        function importPersona(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);

                    // 基础验证
                    if (!importedData.name || !importedData.avatar) {
                        throw new Error("导入的文件缺少必要的'name'或'avatar'字段。");
                    }
                    
                    const newPersona = {
                        id: `custom-${Date.now()}`, // 唯一ID
                        isCustom: true, // 标记为自定义
                        name: importedData.name,
                        nickname: importedData.nickname || '',
                        avatar: importedData.avatar,
                        gender: importedData.gender || 'other',
                        likes: importedData.likes || '',
                        dislikes: importedData.dislikes || '',
                        habits: importedData.habits || '',
                        playerAddress: importedData.playerAddress || '',
                        background: importedData.background || '',
                        openingLine: importedData.openingLine || '',
                        pokeAction: importedData.pokeAction || '拍了拍',
                        pokeContent: importedData.pokeContent || '',
                    };
                    
                    // 添加到自定义角色列表并保存
                    if (!appSettings.customPersonas) appSettings.customPersonas = [];
                    appSettings.customPersonas.push(newPersona);
                    await putData('appSettings', appSettings);

                    showNotification(`角色“${newPersona.name}”已成功导入！`);
                    populatePersonaSelectionModal(); // 刷新列表
                } catch (error) {
                    console.error("导入角色失败:", error);
                    showNotification(`导入失败: ${error.message}`);
                } finally {
                     // 清空file input的值，以便可以再次选择同一个文件
                    event.target.value = '';
                }
            };
            reader.readAsText(file);
        }

        function deleteCustomPersona(personaId) {
            showCustomConfirm(
                '删除确认',
                '确定要删除这个导入的角色吗？此操作不可撤销。',
                async () => {
                    appSettings.customPersonas = appSettings.customPersonas.filter(p => p.id !== personaId);
                    await putData('appSettings', appSettings);
                    // 如果删除的是当前页的最后一个角色，并且不是第一页，则返回上一页
                    if (personaListContainer.childElementCount === 1 && currentPersonaPage > 0) {
                        currentPersonaPage--;
                    }
                    populatePersonaSelectionModal(); // 刷新列表
                    showNotification('导入的角色已删除。');
                }
            );
        }

        /**
         * 激活指定的输入区域功能按钮。
         * 如果有其他按钮处于激活状态，则先取消其激活状态。
         * @param {HTMLElement} buttonElement - 要激活的按钮DOM元素。
         */
        function activateInputButton(buttonElement) {
            if (activeInputButtonElement && activeInputButtonElement !== buttonElement) {
                activeInputButtonElement.classList.remove('active');
            }
            buttonElement.classList.add('active');
            activeInputButtonElement = buttonElement;
        }

        /**
         * 取消所有输入区域功能按钮的激活状态。
         */
        function deactivateInputButtons() {
            if (activeInputButtonElement) {
                activeInputButtonElement.classList.remove('active');
                activeInputButtonElement = null;
            }
        }

                /**
         * 处理发送语音消息
         */
        async function sendVoiceMessage() {
            const voiceContent = voiceTextInput.value.trim();
            if (!voiceContent) {
                showNotification('语音内容不能为空！');
                return;
            }

            let durationNum = Math.ceil(voiceContent.length / 5);
            if (durationNum < 1) durationNum = 1;
            if (durationNum > 60) durationNum = 60;
            const durationString = `${durationNum}s`;
            const now = Date.now();
            const voiceCardData = { duration: durationString, content: voiceContent };

            const msgId = await saveBubbleToHistory(`[语音] ${voiceContent}`, 'sent', now, false, false, null, 'voice', voiceCardData);
            addBubbleToDOM({ messageId: msgId, content: JSON.stringify(voiceCardData), type: 'sent', isRetracted: false, isAutoReply: false, timestamp: now, displayTimeOverride: null, segmentType: 'voice', cardData: voiceCardData });
            
            userMessageCounter++;
            closeModal(voiceInputModal);
            deactivateInputButtons();
            
            // --- AI 回复逻辑（根据开关决定是否执行）---
            if (appSettings.immediateReplyEnabled) {
                const typingIndicatorContainer = document.createElement('div');
                typingIndicatorContainer.className = 'message received';
                typingIndicatorContainer.innerHTML = `
                    <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                    <div class="message-content">
                        <div class="name">${friendData.nickname || friendData.name}</div>
                        <div class="typing-indicator">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                `;
                chatArea.appendChild(typingIndicatorContainer);
                scrollToBottom();

                try {
                    const aiPrompt = `用户发送了一条语音消息，内容是：“${voiceContent}”，时长为${durationNum}秒。请你结合历史记录，根据你的人设，对此做出回应。`;
                    const aiResponseText = await getApiResponse('chat', aiPrompt);
                    const parsedAiData = parseAiResponse(aiResponseText);

                    if (typingIndicatorContainer.parentNode === chatArea) {
                        chatArea.removeChild(typingIndicatorContainer);
                    }
                    
                    await displayNewFriendMessages(parsedAiData, false, Date.now());

                    appSettings.lastAiReplyTimestamp = Date.now();
                    await putData('appSettings', appSettings);
                    setFriendStatus('online');

                } catch (error) {
                    if (typingIndicatorContainer.parentNode === chatArea) {
                        chatArea.removeChild(typingIndicatorContainer);
                    }
                    console.error('AI回复语音消息失败:', error);
                    const errorMessage = '抱歉，我暂时无法对语音消息做出回应。';
                    displayTemporaryErrorBubble(errorMessage);
                }
            }
        }

        /**
         * 处理发送图片消息
         */
        async function sendImageMessage() {
            const imageDescription = imageDescriptionInput.value.trim();
            const imageUrl = imageMessagePreview.src;

            if (!imageDescription && !imageUrl) {
                showNotification('图片描述或图片至少填一个！');
                return;
            }

            const now = Date.now();
            const imageCardData = { description: imageDescription, imageUrl: imageUrl, displayImage: true };
            const msgId = await saveBubbleToHistory(`[图片] ${imageDescription || '(无文字描述)'}`, 'sent', now, false, false, null, 'image', imageCardData);

            await updateImageDisplayFlags(); 
            
            const sentImageBubbleData = chatHistoryArray.find(b => b.messageId === msgId);
            if (sentImageBubbleData) {
                 addBubbleToDOM(sentImageBubbleData);
            }

            userMessageCounter++; 
            imageDescriptionInput.value = '';
            removeImageMessage();
            closeModal(imageDescriptionModal);
            deactivateInputButtons();

            // --- AI 回复逻辑（根据开关决定是否执行）---
            if (appSettings.immediateReplyEnabled) {
                const typingIndicatorContainer = document.createElement('div');
                typingIndicatorContainer.className = 'message received';
                typingIndicatorContainer.innerHTML = `
                    <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                    <div class="message-content">
                        <div class="name">${friendData.nickname || friendData.name}</div>
                        <div class="typing-indicator">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                `;
                chatArea.appendChild(typingIndicatorContainer);
                scrollToBottom();

                try {
                    const aiPrompt = `用户发送了一条图片消息，${imageUrl ? '带有一张图片，' : ''}图片描述是：“${imageDescription || '无描述'}”。请你结合历史记录，根据你的人设，对此做出回应。`;
                    const aiResponseText = await getApiResponse('chat', aiPrompt);
                    const parsedAiData = parseAiResponse(aiResponseText);
                    
                    if (typingIndicatorContainer.parentNode === chatArea) {
                        chatArea.removeChild(typingIndicatorContainer);
                    }
                    
                    await displayNewFriendMessages(parsedAiData, false, Date.now());

                    appSettings.lastAiReplyTimestamp = Date.now();
                    await putData('appSettings', appSettings);
                    setFriendStatus('online');

                } catch (error) {
                    if (typingIndicatorContainer.parentNode === chatArea) {
                        chatArea.removeChild(typingIndicatorContainer);
                    }
                    console.error('AI回复图片消息失败:', error);
                    const errorMessage = '抱歉，我暂时无法对图片消息做出回应。';
                    displayTemporaryErrorBubble(errorMessage);
                }
            }
        }
        
                /**
         * 处理发送红包消息
         */
        async function sendRedPacketMessage() {
            const redPacketName = redPacketNameInput.value.trim();
            const redPacketAmount = parseFloat(redPacketAmountInput.value.trim());

            if (!redPacketName || isNaN(redPacketAmount) || redPacketAmount <= 0) {
                showNotification('请填写有效的红包名称和金额！');
                return;
            }
            if (redPacketAmount <= 0.009) {
                showNotification('红包金额过小，请至少输入0.01！');
                return;
            }
            if (redPacketAmount.toString().split('.')[1]?.length > 2) {
                showNotification('红包金额最多只能有两位小数！');
                return;
            }

            const now = Date.now();
            const redPacketCardData = { name: redPacketName, amount: redPacketAmount };

            const sentRedPacketMsgId = await saveBubbleToHistory(`[红包] ${redPacketName}`, 'sent', now, false, false, null, 'red-packet', redPacketCardData, true);
            addBubbleToDOM({ messageId: sentRedPacketMsgId, content: JSON.stringify(redPacketCardData), type: 'sent', isRetracted: false, isAutoReply: false, timestamp: now, displayTimeOverride: null, segmentType: 'red-packet', cardData: redPacketCardData, isOpened: true });
            
            userMessageCounter++;

            const friendNickname = friendData.nickname || friendData.name;
            const receivedMessageText = `${friendNickname} 领取了你的红包，获得 ${redPacketAmount}￥`;
            const eventMsgId = await saveBubbleToHistory(receivedMessageText, 'event', Date.now(), false, false, null, 'text');
            addEventMessageToDOM(receivedMessageText, eventMsgId);

            closeModal(redPacketModal);
            deactivateInputButtons();

            // --- AI 回复逻辑（根据开关决定是否执行）---
            if (appSettings.immediateReplyEnabled) {
                const typingIndicatorContainer = document.createElement('div');
                typingIndicatorContainer.className = 'message received';
                typingIndicatorContainer.innerHTML = `
                    <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                    <div class="message-content">
                        <div class="name">${friendData.nickname || friendData.name}</div>
                        <div class="typing-indicator">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                `;
                chatArea.appendChild(typingIndicatorContainer);
                scrollToBottom();

                try {
                    const aiPromptForRedPacket = `玩家向你扮演的${friendData.nickname || friendData.name}发了一个红包，红包名字是“${redPacketName}”，金额是${redPacketAmount}元。`;
                    const aiResponseText = await getApiResponse('chat', aiPromptForRedPacket);
                    const parsedAiData = parseAiResponse(aiResponseText);
                    
                    if (typingIndicatorContainer.parentNode === chatArea) {
                        chatArea.removeChild(typingIndicatorContainer);
                    }
                    
                    await displayNewFriendMessages(parsedAiData, false, Date.now());

                    appSettings.lastAiReplyTimestamp = Date.now();
                    await putData('appSettings', appSettings);
                    setFriendStatus('online');

                } catch (error) {
                    if (typingIndicatorContainer.parentNode === chatArea) {
                        chatArea.removeChild(typingIndicatorContainer);
                    }
                    console.error('AI回复红包失败:', error);
                    const errorMessage = '抱歉，我暂时无法对红包做出回应。';
                    displayTemporaryErrorBubble(errorMessage);
                }
            }
        }
        
        
        function handleImageMessageUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                removeImageMessage();
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                imageMessagePreview.src = e.target.result;
                imageMessagePreviewContainer.style.display = 'flex';
            };
            reader.readAsDataURL(file);
        }

        function removeImageMessage() {
            imageUploadInput.value = ''; // 清空文件输入
            imageMessagePreview.src = '';
            imageMessagePreviewContainer.style.display = 'none';
        }
        
        async function handleRegenerate() {
            const context = window.currentRegenerationContext;
            if (!context) {
                console.error('No regeneration context found.');
                closeModal(regenerateModal);
                return;
            }

            // Remove AI messages from DOM
            context.aiMessageDomElementsToClear.forEach(el => {
                if (el && el.parentNode) {
                    el.parentNode.removeChild(el);
                }
            });

            // Remove AI messages from chatHistoryArray and IndexedDB
            for (const msgId of context.aiMessageIdsToClear) {
                chatHistoryArray = chatHistoryArray.filter(bubble => bubble.messageId !== msgId);
                await deleteData('chatHistory', msgId);
            }

            // Add typing indicator
            const typingIndicatorContainer = document.createElement('div');
            typingIndicatorContainer.className = 'message received';
            typingIndicatorContainer.innerHTML = `
                <img src="${friendData.avatar}" alt="好友头像" class="avatar">
                <div class="message-content">
                    <div class="name">${friendData.nickname || friendData.name}</div>
                    <div class="typing-indicator">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            `;
            chatArea.appendChild(typingIndicatorContainer);
            scrollToBottom();

            // Re-send the last user message to trigger new AI response
            const lastUserMessage = context.userMessageContent;
            
            try {
                const aiResponseText = await getApiResponse('regenerate', lastUserMessage);
                const parsedAiData = parseAiResponse(aiResponseText);

                // 核心修改：在显示第一条新消息前移除“正在输入”提示
                if (typingIndicatorContainer.parentNode === chatArea) {
                    chatArea.removeChild(typingIndicatorContainer);
                }

                await displayNewFriendMessages(parsedAiData, false, Date.now());
                appSettings.lastAiReplyTimestamp = Date.now();
                await putData('appSettings', appSettings);
                setFriendStatus('online');
                showNotification('AI回复已重新生成。');
            } catch (error) {
                // 确保移除提示
                if (typingIndicatorContainer.parentNode === chatArea) {
                    chatArea.removeChild(typingIndicatorContainer);
                }
                console.error('重新生成回复失败:', error);
                const errorMessage = '抱歉，重新生成回复失败。请检查API配置或稍后再试。';
                displayTemporaryErrorBubble(errorMessage);
                showNotification('重新生成失败。');
            } finally {
                closeModal(regenerateModal);
                window.currentRegenerationContext = null; // Clear context
            }
        }

        function handleMomentImageUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                removeMomentImage();
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                momentImagePreview.src = e.target.result;
                momentImagePreviewContainer.style.display = 'flex';
            };
            reader.readAsDataURL(file);
        }

        function removeMomentImage() {
            momentInput.value = ''; // Clear the text input as well
            momentImageUpload.value = ''; // Clear the file input
            momentImagePreview.src = '';
            momentImagePreviewContainer.style.display = 'none';
        }

        function openMomentsView() {
            // 更新视图的头部信息
            coverUserNameDisplay.textContent = userData.name;
            coverUserAvatarDisplay.src = userData.avatar;
            playerCoverImage.src = appSettings.playerCoverImage;
            renderMomentsFeed();
            openModal(momentsView);
        }

        async function updateMomentsDisplay() {
            renderMomentsFeed();
        }

        function renderMomentsFeed() {
            momentsFeedContainer.innerHTML = ''; // 清空
            const feedToDisplay = momentsFeed.sort((a, b) => b.timestamp - a.timestamp).slice(0, 20);

            if (feedToDisplay.length === 0) {
                momentsFeedContainer.innerHTML = '<p id="no-moment-message" style="text-align: center; color: #888; padding: 20px;">暂无动态，点击右上角刷新看看吧！</p>';
                return;
            }

            feedToDisplay.forEach(moment => {
                const momentCard = document.createElement('div');
                // 新增：检查是否是玩家的动态，并添加 'player-post' 类
                const isPlayerPost = moment.posterId === 'player';
                momentCard.className = `moment-card ${isPlayerPost ? 'player-post' : ''}`;
                momentCard.dataset.momentId = moment.id;

                const posterAvatar = isPlayerPost ? userData.avatar : (moment.avatar || friendData.avatar);
                const posterName = isPlayerPost ? userData.name : (moment.name || friendData.name);

                const commentsHtml = moment.comments && moment.comments.length > 0 ? `
                    <div class="moment-card-comments">
                        ${moment.comments.map((comment, index) => {
                            // 新增：检查是否是玩家的评论，并添加 'player-comment' 类
                            const isPlayerComment = comment.name === userData.name;
                            return `
                            <div class="comment-item ${isPlayerComment ? 'player-comment' : ''}" data-commenter-name="${comment.name}">
                                <div>
                                    <span class="commenter-name">${comment.name}</span>
                                    ${comment.replyTo ? `<span class="reply-to-name"> 回复 ${comment.replyTo}</span>` : ''}: 
                                    ${comment.content}
                                </div>
                            </div>
                        `}).join('')}
                    </div>
                ` : '';

                momentCard.innerHTML = `
                    <img src="${posterAvatar}" alt="${posterName}头像" class="moment-card-avatar">
                    <div class="moment-card-main">
                        <span class="moment-card-name">${posterName}</span>
                        <div class="moment-card-content">${moment.content}</div>
                        ${moment.imageUrl ? `<img src="${moment.imageUrl}" alt="朋友圈图片" class="moment-card-photo">` : ''}
                        <div class="moment-card-footer">
                            <span class="moment-card-timestamp">${moment.displayTime || new Date(moment.timestamp).toLocaleString()}</span>
                            <div class="moment-card-actions">
                                <button class="comment-btn" title="评论"><i class="fas fa-comment-dots"></i></button>
                            </div>
                        </div>
                        ${commentsHtml}
                    </div>
                `;
                momentsFeedContainer.appendChild(momentCard);
            });
        }

        async function publishMoment() {
            const content = momentInput.value.trim();
            // 只有当预览图src包含 'data:image' 时才认为是有效图片URL
            const imageUrl = momentImagePreview.src.startsWith('data:image') ? momentImagePreview.src : '';

            if (!content && !imageUrl) {
                showNotification('朋友圈内容或图片不能为空！');
                return;
            }

            const newMoment = {
                id: `moment-${Date.now()}`,
                posterId: 'player', // 标记为玩家发布
                name: userData.name,
                avatar: userData.avatar,
                content: content,
                imageUrl: imageUrl,
                timestamp: Date.now(),
                comments: []
            };

            momentsFeed.unshift(newMoment);
            await putData('momentsData', newMoment);

            momentInput.value = '';
            removeMomentImage();
            closeModal(postMomentModal);
            showNotification('朋友圈已发表！');

            renderMomentsFeed();

            // 在新渲染的动态下插入“正在生成评论”的提示
            const newMomentCard = momentsFeedContainer.querySelector(`[data-moment-id="${newMoment.id}"]`);
            if (newMomentCard) {
                let commentsContainer = newMomentCard.querySelector('.moment-card-comments');
                if (!commentsContainer) {
                    commentsContainer = document.createElement('div');
                    commentsContainer.className = 'moment-card-comments';
                    newMomentCard.querySelector('.moment-card-main').appendChild(commentsContainer);
                }
                commentsContainer.innerHTML = `
                    <div class="generating-comments-indicator" id="generating-comments-indicator-${newMoment.id}">
                        <i class="fas fa-spinner fa-spin"></i>
                        <span>正在生成评论...</span>
                    </div>
                `;
            }

            triggerAiMomentComment(newMoment); // 触发AI评论
        }

        async function refreshMomentsFeed() {
            refreshMomentsBtn.querySelector('i').classList.add('fa-spin'); // 添加加载动画
            showNotification('正在刷新动态...');
            
            try {
                const now = new Date();
                const currentTimeString = now.toLocaleString();
                const lastRefreshTimeString = appSettings.lastMomentsRefreshTimestamp ? new Date(appSettings.lastMomentsRefreshTimestamp).toLocaleString() : '很久以前';

                const aiPrompt = `[系统指令] 你的任务分为两部分，请严格分开处理：

**第一部分：生成朋友圈数据（必须完成）**
请你生成 1 到 3 条全新的朋友圈数据块，这些动态发生在 ${lastRefreshTimeString} 到 ${currentTimeString} 之间。
- **严格格式**: 所有动态都必须包含在 \`<朋友圈>...\</朋友圈>\` 代码块内。
- **发帖人**：${friendData.name}和其他可能存在于玩家“${userData.name}”朋友圈的朋友。
- **内容**: 动态内容需要符合发帖人的人设，充满“活人感”，避免与近期聊天记录冲突。
- **时间逻辑**: 发布时间必须在上次刷新之后、当前时间之前，且按时间顺序递增。评论时间必须晚于发布时间。时间格式为“月/日 HH:MM”。
- **禁止嵌套**: \`<朋友圈>\` 代码块内部 **严禁** 出现 \`""\`, \`{}\`, \`『』\` 等聊天消息格式。
- **禁止擅自在朋友圈生成玩家${userData.name}的动态和评论**

**第二部分：发送聊天消息（可选）**
如果此时${friendData.name}希望根据之前的聊天内容，继续和玩家对话，${friendData.name}可以发送一条或多条聊天消息，取决于人物性格和聊天记录（不要超过4条，一般只需要1条）。
- **视角局限**: 朋友圈数据由**系统刷新**，与${friendData.name}无关，${friendData.name}不会认为朋友圈是ta刷新的
- **可选内容**：${friendData.name}可以结合聊天记录对玩家继续发消息，**注意聊天时间间隔**，不要出现玩家只离开几分钟，对话里却说玩家很久没理ta这种情况。
- **标准格式**: 使用 \`""\` (普通消息), \`{}\` (撤回消息), \`<表情></表情> \` (表情包) 等标准聊天格式。
- **心声**: 如果你发送了聊天消息，请在最后附上你的【心声：...】。心声应与你的聊天内容相关。
- **禁止ooc**：维持${friendData.name}的人设

**示例:**
<朋友圈>
【孟祁年|今天看到一只很可爱的橘猫。[图片:一只橘猫在蹭腿]|6/17 13:43】
〖岁时|好可爱！在哪遇到的？|6/17 13:48〗
〖白|哟，这猫真会撒娇。|6/17 14:12〗
</朋友圈>
"你刚才说你有点饿了，要不要我给你点些吃的？"
【心声：她好像还没吃饭，有点担心。】`;
                
                const aiResponseText = await getApiResponse('momentsRefresh', aiPrompt);
                const parsedData = parseAiResponse(aiResponseText);
                
                let momentsGenerated = false;
                if (parsedData.newMoments && parsedData.newMoments.length > 0) {
                    for (const moment of parsedData.newMoments) {
                        momentsFeed.unshift(moment);
                        await putData('momentsData', moment);
                    }
                    renderMomentsFeed();
                    showNotification(`刷新了 ${parsedData.newMoments.length} 条新动态！`);
                    momentsGenerated = true;
                }

                // 修改后逻辑：处理 AI 同时发送的聊天消息
                if (parsedData.segments && parsedData.segments.length > 0) {
                    // 1. 在后台默默保存新消息到历史记录和DOM，但不滚动视图
                    await displayNewFriendMessages(parsedData, false, Date.now(), true); 
                    // 2. 显示新的顶部通知栏
                    showNewMessageNotification(parsedData.segments);
                }

                if (!momentsGenerated && (!parsedData.segments || parsedData.segments.length === 0)) {
                    showNotification('暂时没有新动态哦。');
                }
                
                appSettings.lastMomentsRefreshTimestamp = Date.now();
                await putData('appSettings', appSettings);

            } catch (error) {
                console.error("刷新朋友圈失败:", error);
                showNotification('刷新失败，请检查API设置。');
            } finally {
                refreshMomentsBtn.querySelector('i').classList.remove('fa-spin');
            }
        }
        
        async function handleCoverImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const imageUrl = e.target.result;
                playerCoverImage.src = imageUrl;
                appSettings.playerCoverImage = imageUrl;
                await putData('appSettings', appSettings);
                showNotification('朋友圈封面已更新！');
            };
            reader.readAsDataURL(file);
        }
        
        function handleMomentCardClick(event) {
            const commentBtn = event.target.closest('.comment-btn');
            const commentItem = event.target.closest('.comment-item');
            const momentCard = event.target.closest('.moment-card');

            if (!momentCard) return;
            const momentId = momentCard.dataset.momentId;
            
            if (commentBtn) {
                openCommentModal(momentId);
            } else if (commentItem) {
                const commenterName = commentItem.dataset.commenterName;
                if (commenterName !== userData.name) { // 不能回复自己
                    openCommentModal(momentId, commenterName);
                }
            }
        }

        function openCommentModal(momentId, replyToName = null) {
            commentTargetMomentIdInput.value = momentId;
            if (replyToName) {
                commentModalTitle.textContent = `回复 ${replyToName}`;
                commentTextInput.placeholder = `回复 ${replyToName}:`;
                commentReplyToNameInput.value = replyToName;
            } else {
                commentModalTitle.textContent = '发表评论';
                commentTextInput.placeholder = '输入评论...';
                commentReplyToNameInput.value = '';
            }
            commentTextInput.value = '';
            openModal(commentInputModal);
        }
        
        async function submitComment() {
            const momentId = commentTargetMomentIdInput.value;
            const replyTo = commentReplyToNameInput.value || null;
            const content = commentTextInput.value.trim();

            if (!content) {
                showNotification('评论内容不能为空！');
                return;
            }

            const momentIndex = momentsFeed.findIndex(m => m.id === momentId);
            if (momentIndex === -1) {
                showNotification('评论失败：找不到该动态。');
                return;
            }

            const newComment = {
                name: userData.name,
                replyTo: replyTo,
                content: content,
                timestamp: Date.now()
            };
            
            momentsFeed[momentIndex].comments.push(newComment);
            await putData('momentsData', momentsFeed[momentIndex]);

            closeModal(commentInputModal);
            renderMomentsFeed();
            showNotification('评论成功！');

            // 触发AI对玩家评论的回复
            triggerAiReplyToUserComment(momentsFeed[momentIndex], newComment);
        }

        async function triggerAiMomentComment(moment) {
            const now = new Date();
            const month = now.getMonth() + 1;
            const day = now.getDate();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const currentTimeString = `${month}/${day} ${hours}:${minutes}`;

            const aiPrompt = `[系统指令] 用户“${moment.name}”刚刚在朋友圈发表了新动态。
**动态详情**:
- **内容**: "${moment.content || '(无文字内容)'}"
- **图片**: ${moment.imageUrl ? '有' : '无'}
- **发布时间**: ${currentTimeString}

**你的任务**:
1.模拟1-3位其他好友对此动态的评论。
2.你扮演的（人设：${friendData.name}）有可能会对此动态发表评论。
3.所有评论都必须使用严格格式：
- ${friendData.name}的评论: 【评论：评论内容|显示时间】
- 其他好友的评论: 〖好友名称：评论内容|显示时间〗
4.**规则**: 评论内容要自然，符合人物性格，紧扣动态内容。显示时间应为合理的、刚刚发生的时间，格式为“MM/dd HH:mm”。`;

            try {
                const aiResponseText = await getApiResponse('momentComment', aiPrompt); 
                const parsedData = parseAiResponse(aiResponseText);
                const momentIndex = momentsFeed.findIndex(m => m.id === moment.id);

                // 首先移除加载指示器
                const indicator = document.getElementById(`generating-comments-indicator-${moment.id}`);
                if (indicator) {
                    indicator.remove();
                }

                if (momentIndex !== -1 && parsedData.momentComments && parsedData.momentComments.length > 0) {
                    parsedData.momentComments.forEach(commentData => {
                        momentsFeed[momentIndex].comments.push({
                            name: commentData.name,
                            avatar: commentData.avatar, // 确保头像也被保存
                            content: commentData.content,
                            displayTime: commentData.displayTime,
                            timestamp: Date.now()
                        });
                    });
                    await putData('momentsData', momentsFeed[momentIndex]);
                    showNotification(`${parsedData.momentComments.length}人评论了你的朋友圈！`);
                }
                // 无论有没有新评论，都需要重新渲染以移除加载提示
                renderMomentsFeed();
            } catch (error) {
                console.error('AI朋友圈评论失败:', error);
                // 改进：当AI评论失败时，给出一个友好的界面提示
                showNotification('AI评论生成失败，请稍后再试。');
                // 确保移除加载提示
                const indicator = document.getElementById(`generating-comments-indicator-${moment.id}`);
                if (indicator) {
                    indicator.remove();
                }
            }
        }

        async function triggerAiReplyToUserComment(moment, userComment) {
            const momentIndex = momentsFeed.findIndex(m => m.id === moment.id);
            if (momentIndex === -1) return;

            const now = new Date();
            const currentTimeString = `${now.getMonth() + 1}/${now.getDate()} ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;

            let replyContext = userComment.replyTo ? `回复了 **${userComment.replyTo}**` : '发表了评论';

            const aiPrompt = `
            [系统指令] 玩家刚刚在一条朋友圈动态下发表了评论，请你生成后续的互动。

**上下文详情**:
- **原动态作者**: ${moment.name}
- **原动态内容**: "${moment.content || '(无文字内容)'}"
- **现有评论列表**:
${moment.comments.map(c => `  - **${c.name}**${c.replyTo ? ' 回复 ' + c.name : ''}: ${c.content}`).join('\n') || '  - (暂无评论)'}

**玩家的最新评论**:
- **评论者**: ${userComment.name} (这是玩家)
- **行为**: ${replyContext}
- **内容**: "${userComment.content}"
- **时间**: ${currentTimeString}

**你的任务**:
1.  **生成回复**: 模拟 1 到 2 位好友（可以包括你自己所扮演的角色 **${friendData.name}**）对 **玩家的这条最新评论** 做出反应。回复内容必须紧扣上下文，保持对话连贯。
2.  **严格格式**: 所有回复都必须使用此格式：\`〖好友名称：评论内容|显示时间〗\`。显示时间应为合理的、刚刚发生的时间，格式为“月/日 HH:MM”。
3.  **禁止项**: **绝对不要** 输出 \`<朋友圈>...\</朋友圈>\` 代码块。你的任务是 **回复评论**，不是创建新动态。
4.  **聊天(非必须)**: 如果你想在生成评论的同时，对玩家发送一条私聊消息，请将聊天内容放在所有 \`〖...〗\` 格式之外，并使用标准的 \`""\`和\`{}\` 格式，最后附上你的【心声】。

**示例输出:**
〖岁时：哦哦，你也觉得这家好吃吗！|6/18 11:35〗
〖孟祁年：就那样吧，没我做的好吃。|6/18 11:36〗
"切，笨蛋真没眼光"
【心声：下次试试做给她尝尝】`;

            try {
                const aiResponseText = await getApiResponse('momentComment', aiPrompt);
                const parsedData = parseAiResponse(aiResponseText);
                
                // 处理AI生成的评论
                if (parsedData.momentComments && parsedData.momentComments.length > 0) {
                    parsedData.momentComments.forEach(commentData => {
                        momentsFeed[momentIndex].comments.push({
                            name: commentData.name,
                            avatar: commentData.avatar,
                            content: commentData.content,
                            displayTime: commentData.displayTime,
                            timestamp: Date.now()
                        });
                    });
                    await putData('momentsData', momentsFeed[momentIndex]);
                    renderMomentsFeed();
                    showNotification(`你的评论收到了新的回复！`);
                }

                // 处理AI可能同时发送的聊天消息
                if (parsedData.segments && parsedData.segments.length > 0) {
                    await displayNewFriendMessages(parsedData, false, Date.now(), true);
                    showNewMessageNotification(parsedData.segments);
                }

            } catch (error) {
                console.error('AI回复朋友圈评论失败:', error);
                showNotification('AI回复您的评论失败，请稍后再试。');
            }
        }


                function applyInputAreaShift(isShiftedUp) {
            const inputArea = document.querySelector('.input-area');
            // 修正：将 class 添加到 containerElement 而不是 document.body
            if (isShiftedUp) {
                containerElement.classList.add('input-area-shifted-up');
            } else {
                containerElement.classList.remove('input-area-shifted-up');
            }
            // 动态计算输入区域高度并设置CSS变量，无论是否上移，确保emoji-card定位正确
            const inputAreaHeight = inputArea.offsetHeight;
            document.documentElement.style.setProperty('--input-area-height', `${inputAreaHeight}px`);
        }
        

        // 新增：主题设置相关函数
        function populateThemeOptions() {
            // 在渲染前，检查并添加存储的自定义主题到内存中的themes对象
            if (appSettings.customTheme) {
                themes['custom'] = appSettings.customTheme;
            }

            themeOptionsContainer.innerHTML = '';
            for (const themeKey in themes) {
                const theme = themes[themeKey];
                const optionDiv = document.createElement('div');
                optionDiv.className = `theme-option ${appSettings.currentTheme === themeKey ? 'selected' : ''}`;
                optionDiv.dataset.themeKey = themeKey;

                const colorSwatch = document.createElement('div');
                colorSwatch.className = 'color-swatch';
                // Create a mini gradient for the swatch
                colorSwatch.style.background = `linear-gradient(45deg, ${theme.mainColors[0]}, ${theme.mainColors[3]})`;

                const themeNameSpan = document.createElement('span');
                themeNameSpan.textContent = theme.name;

                optionDiv.appendChild(colorSwatch);
                optionDiv.appendChild(themeNameSpan);
                themeOptionsContainer.appendChild(optionDiv);

                optionDiv.addEventListener('click', async () => {
                    appSettings.currentTheme = themeKey; // 更新当前主题键
                    await putData('appSettings', appSettings); // 保存设置
                    applyTheme(themeKey); // 应用新主题
                    
                    // 更新选中状态的视觉效果
                    themeOptionsContainer.querySelectorAll('.theme-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    optionDiv.classList.add('selected');
                });
            }

            // Populate default chat background options
            defaultChatBackgroundSelect.innerHTML = '<option value="">无默认背景</option>';
            for (const bgKey in defaultChatBackgrounds) {
                const bg = defaultChatBackgrounds[bgKey];
                const option = document.createElement('option');
                option.value = bgKey;
                option.textContent = bg.name;
                defaultChatBackgroundSelect.appendChild(option);
            }
            // Set selected default background
            if (appSettings.chatBackground.type === 'default') {
                defaultChatBackgroundSelect.value = appSettings.chatBackground.value;
            } else {
                defaultChatBackgroundSelect.value = ''; // No default selected if custom is active
            }

            // Update custom background preview
            if (appSettings.chatBackground.type === 'custom' && appSettings.chatBackground.value) {
                chatBackgroundPreview.src = appSettings.chatBackground.value;
                chatBackgroundPreview.style.display = 'block';
                removeChatBackgroundBtn.style.display = 'block';
            } else {
                chatBackgroundPreview.src = '';
                chatBackgroundPreview.style.display = 'none';
                removeChatBackgroundBtn.style.display = 'none';
            }
        }

        async function applyTheme(themeKey) {
            // 在应用前，确保themes对象包含最新的自定义主题
            if (appSettings.customTheme) {
                themes['custom'] = appSettings.customTheme;
            }

            const theme = themes[themeKey];
            if (!theme) {
                console.warn(`Theme "${themeKey}" not found. Reverting to default.`);
                await applyTheme('default'); // 如果找不到主题，则安全地回退到默认主题
                return;
            }

            // Remove previous theme class from body
            document.body.classList.forEach(cls => {
                if (cls.startsWith('theme-')) {
                    document.body.classList.remove(cls);
                }
            });
            // Add new theme class to body
            document.body.classList.add(`theme-${themeKey}`);

            // Apply main colors
            document.documentElement.style.setProperty('--theme-color-1', theme.mainColors[0]);
            document.documentElement.style.setProperty('--theme-color-2', theme.mainColors[1]);
            document.documentElement.style.setProperty('--theme-color-3', theme.mainColors[2]);
            document.documentElement.style.setProperty('--theme-color-4', theme.mainColors[3]);

            // Apply RGB versions
            document.documentElement.style.setProperty('--theme-color-rgb-1', hexToRgb(theme.mainColors[0]));
            document.documentElement.style.setProperty('--theme-color-rgb-2', hexToRgb(theme.mainColors[1]));
            document.documentElement.style.setProperty('--theme-color-rgb-3', hexToRgb(theme.mainColors[2]));
            document.documentElement.style.setProperty('--theme-color-rgb-4', hexToRgb(theme.mainColors[3]));

            // Apply auxiliary colors
            for (const prop in theme.auxiliaryColors) {
                document.documentElement.style.setProperty(prop, theme.auxiliaryColors[prop]);
            }

            // Update and save the current theme setting
            appSettings.currentTheme = themeKey;
            await putData('appSettings', appSettings); 
            console.log(`Theme changed to: ${theme.name}`);
        }

        async function handleChatBackgroundUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                removeChatBackground();
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                const imageUrl = e.target.result;
                await applyChatBackground('custom', imageUrl);
                chatBackgroundPreview.src = imageUrl;
                chatBackgroundPreview.style.display = 'block';
                removeChatBackgroundBtn.style.display = 'block';
                defaultChatBackgroundSelect.value = ''; // Deselect default option
                showNotification('自定义背景已应用！');
            };
            reader.readAsDataURL(file);
        }

        async function removeChatBackground() {
            chatBackgroundUploadInput.value = ''; // Clear file input
            await applyChatBackground('default', 'default-chat-bg-1'); // Revert to default
            chatBackgroundPreview.src = '';
            chatBackgroundPreview.style.display = 'none';
            removeChatBackgroundBtn.style.display = 'none';
            defaultChatBackgroundSelect.value = 'default-chat-bg-1'; // Select default option
            showNotification('自定义背景已移除，已恢复默认背景。');
        }

        async function handleDefaultChatBackgroundChange(event) {
            const selectedBgKey = event.target.value;
            if (selectedBgKey) {
                await applyChatBackground('default', selectedBgKey);
                chatBackgroundUploadInput.value = ''; // Clear custom file input
                chatBackgroundPreview.src = '';
                chatBackgroundPreview.style.display = 'none';
                removeChatBackgroundBtn.style.display = 'none';
                showNotification('默认背景已应用！');
            } else {
                // If "无默认背景" is selected, clear all background
                await applyChatBackground('none', '');
                chatBackgroundUploadInput.value = '';
                chatBackgroundPreview.src = '';
                chatBackgroundPreview.style.display = 'none';
                removeChatBackgroundBtn.style.display = 'none';
                showNotification('聊天背景已清空。');
            }
        }

        async function applyChatBackground(type, value) {
            const chatAreaElement = document.getElementById('chat-area');
            if (type === 'custom' && value) {
                chatAreaElement.style.backgroundImage = `url('${value}')`;
                chatAreaElement.style.backgroundSize = 'var(--chat-background-size)';
                chatAreaElement.style.backgroundPosition = 'var(--chat-background-position)';
                chatAreaElement.style.backgroundRepeat = 'var(--chat-background-repeat)';
                chatAreaElement.style.backgroundAttachment = 'var(--chat-background-attachment)';
                chatAreaElement.style.backgroundColor = 'var(--chat-background-overlay-color)'; // Apply overlay
            } else if (type === 'default' && defaultChatBackgrounds[value]) {
                chatAreaElement.style.backgroundImage = `url('${defaultChatBackgrounds[value].image}')`;
                chatAreaElement.style.backgroundSize = 'var(--chat-background-size)';
                chatAreaElement.style.backgroundPosition = 'var(--chat-background-position)';
                chatAreaElement.style.backgroundRepeat = 'var(--chat-background-repeat)';
                chatAreaElement.style.backgroundAttachment = 'var(--chat-background-attachment)';
                chatAreaElement.style.backgroundColor = 'var(--chat-background-overlay-color)'; // Apply overlay
            } else {
                chatAreaElement.style.backgroundImage = 'none';
                chatAreaElement.style.backgroundColor = 'var(--chat-background-overlay-color)'; // Still apply overlay for consistency
            }
            appSettings.chatBackground = { type, value };
            await putData('appSettings', appSettings); // Save to IndexedDB
        }

        // 新增：本地记录相关函数
        async function saveLocalRecords() {
            await putData('localRecords', localRecords);
        }

        async function populateLocalRecordsModal() {
            localRecordsListContainer.innerHTML = '';
            // Ensure localRecords is up-to-date from DB before populating
            const loadedRecords = await getData('localRecords', 'slots');
            if (loadedRecords) {
                localRecords = { ...localRecords, ...loadedRecords };
            } else {
                // If no records exist, initialize with empty slots
                localRecords = { id: 'slots', slot1: null, slot2: null, slot3: null };
                await putData('localRecords', localRecords);
            }

            for (let i = 1; i <= 3; i++) {
                const slotId = `slot${i}`;
                const slotData = localRecords[slotId];
                const card = document.createElement('div');
                card.className = 'save-slot-card';

                if (slotData) {
                    const latestMessagesText = slotData.previewMessages.map(msg => {
                        if (msg.segmentType === 'emoji-image') {
                            return `[表情: ${PLAYER_EMOJI_MAP[msg.content] || '未知表情'}]`;
                        } else if (msg.segmentType === 'card' && msg.cardData) {
                            return `[卡片: ${msg.cardData.shareTitle} - ${msg.cardData.shareType}]`;
                        } else if (msg.segmentType === 'red-packet' && msg.cardData) {
                            return `[红包: ${msg.cardData.name} ${msg.cardData.amount}￥]`;
                        } else if (msg.segmentType === 'voice' && msg.cardData) {
                            // 优化：同时显示时长和内容摘要
                            return `[语音: ${msg.cardData.duration} - ${msg.cardData.content.substring(0, 10)}...]`;
                        } else if (msg.segmentType === 'image' && msg.cardData) {
                            return `[图片: ${msg.cardData.description.substring(0, 10)}...]`;
                        }
                        // 确保普通文本消息也有一个预览格式
                        return `[文本: ${msg.content.substring(0, 15)}...]`;
                    }).join('\n');
                    const saveTime = new Date(slotData.timestamp).toLocaleString();

                    card.innerHTML = `
                        <h4>
                            <img src="${slotData.friendData.avatar}" alt="${slotData.friendData.name}头像" class="avatar-preview">
                            <span class="slot-name">${slotData.friendData.name} (${slotData.friendData.nickname || '无备注'})</span>
                        </h4>
                        <div class="slot-info">
                            <p class="latest-messages">${latestMessagesText || '暂无聊天记录预览'}</p>
                            <p class="slot-time">保存时间: ${saveTime}</p>
                        </div>
                        <div class="slot-actions">
                            <button class="btn-primary load-slot-btn" data-slot-id="${slotId}">恢复</button>
                            <button class="btn-secondary save-slot-btn" data-slot-id="${slotId}">覆盖保存</button>
                            <button class="btn-secondary delete-slot-btn" data-slot-id="${slotId}">删除</button>
                        </div>
                    `;
                } else {
                    card.classList.add('empty-slot');
                    card.innerHTML = `
                        <h4>空存档位 ${i}</h4>
                        <p>此存档位为空。</p>
                        <div class="slot-actions">
                            <button class="btn-primary save-slot-btn" data-slot-id="${slotId}">保存到此</button>
                        </div>
                    `;
                }
                localRecordsListContainer.appendChild(card);
            }

            localRecordsListContainer.querySelectorAll('.save-slot-btn').forEach(button => {
                button.addEventListener('click', (e) => { // 注意这里不再是 async
                    const slotId = e.target.dataset.slotId;
                    const isOverwrite = localRecords[slotId] !== null;
                    const title = isOverwrite ? '覆盖存档确认' : '保存存档确认';
                    const message = isOverwrite ? `确定要覆盖存档位 ${slotId} 的数据吗？` : `确定要保存数据到存档位 ${slotId} 吗？`;
                    showCustomConfirm(title, message, 
                        () => saveCurrentStateToSlotInternal(slotId), // 确认保存
                        () => {} // 取消不做任何事
                    );
                });
            });

            localRecordsListContainer.querySelectorAll('.load-slot-btn').forEach(button => {
                button.addEventListener('click', (e) => { // 注意这里不再是 async
                    const slotId = e.target.dataset.slotId;
                    showCustomConfirm('恢复存档确认', `确定要恢复存档位 ${slotId} 的数据吗？当前聊天记录将被覆盖。`,
                        () => loadStateFromSlotInternal(slotId), // 确认恢复
                        () => {} // 取消不做任何事
                    );
                });
            });

            localRecordsListContainer.querySelectorAll('.delete-slot-btn').forEach(button => {
                button.addEventListener('click', (e) => { // 注意这里不再是 async
                    const slotId = e.target.dataset.slotId;
                    showCustomConfirm('删除存档确认', `确定要删除存档位 ${slotId} 的数据吗？此操作不可撤销。`,
                        () => deleteSlotInternal(slotId), // 确认删除
                        () => {} // 取消不做任何事
                    );
                });
            });
        }

        // 外部调用的保存函数，触发确认弹窗
        async function saveCurrentStateToSlot(slotId) {
            const isOverwrite = localRecords[slotId] !== null;
            const title = isOverwrite ? '覆盖存档确认' : '保存存档确认';
            const message = isOverwrite ? `确定要覆盖存档位 ${slotId} 的数据吗？` : `确定要保存数据到存档位 ${slotId} 吗？`;
            showCustomConfirm(title, message, 
                () => saveCurrentStateToSlotInternal(slotId), // 确认保存
                () => {} // 取消不做任何事
            );
        }

        // 实际执行保存操作的内部函数
        async function saveCurrentStateToSlotInternal(slotId) {
            const now = Date.now();
            const previewMessages = chatHistoryArray.slice(-3).map(msg => { // 获取最后3条消息用于预览
                // 对于卡片消息，直接存储 cardData 对象
                if (msg.segmentType === 'card') {
                    return {
                        content: msg.content, // stringified JSON
                        type: msg.type,
                        segmentType: msg.segmentType,
                        cardData: msg.cardData // 存储实际的 cardData 对象
                    };
                } else if (msg.segmentType === 'red-packet' || msg.segmentType === 'voice' || msg.segmentType === 'image') {
                    // 对于红包、语音、图片，也存储cardData
                    return {
                        content: msg.content,
                        type: msg.type,
                        segmentType: msg.segmentType,
                        cardData: msg.cardData
                    };
                }
                return { // 对于其他类型，只存储内容和类型
                    content: msg.content,
                    type: msg.type,
                    segmentType: msg.segmentType
                };
            });

            localRecords[slotId] = {
                timestamp: now,
                friendData: JSON.parse(JSON.stringify(friendData)), // 深度复制
                userData: JSON.parse(JSON.stringify(userData)),     // 深度复制
                apiConfig: JSON.parse(JSON.stringify(apiConfig)),   // 深度复制
                appSettings: JSON.parse(JSON.stringify(appSettings)), // 深度复制
                chatHistoryArray: JSON.parse(JSON.stringify(chatHistoryArray)), // 深度复制，其中可能包含 cardData
                currentInnerVoice: currentInnerVoice,
                currentEssay: friendData.currentEssay, // 确保随笔被保存
                momentsFeed: JSON.parse(JSON.stringify(momentsFeed)), // 深度复制所有朋友圈动态
                previewMessages: previewMessages
            };
            await saveLocalRecords();
            await populateLocalRecordsModal(); // 刷新弹窗显示
            showNotification(`存档位 ${slotId} 已保存！`);
            console.log(`Saved state to ${slotId}`, localRecords[slotId]);
        }

        // 外部调用的加载函数，触发确认弹窗
        async function loadStateFromSlot(slotId) {
            const slotData = localRecords[slotId];
            if (!slotData) {
                showNotification(`存档位 ${slotId} 为空，无法恢复。`);
                return;
            }
            showCustomConfirm('恢复存档确认', `确定要恢复存档位 ${slotId} 的数据吗？当前聊天记录将被覆盖。`,
                () => loadStateFromSlotInternal(slotId), // 确认恢复
                () => {} // 取消不做任何事
            );
        }

        // 实际执行加载操作的内部函数
        // 实际执行加载操作的内部函数
        async function loadStateFromSlotInternal(slotId) {
            const slotData = localRecords[slotId];
            if (!slotData) {
                showNotification(`存档位 ${slotId} 为空，无法恢复。`);
                return;
            }

            try {
                // 覆盖全局数据
                userData = JSON.parse(JSON.stringify(slotData.userData));
                friendData = JSON.parse(JSON.stringify(slotData.friendData));
                apiConfig = JSON.parse(JSON.stringify(slotData.apiConfig));
                appSettings = JSON.parse(JSON.stringify(slotData.appSettings));
                chatHistoryArray = JSON.parse(JSON.stringify(slotData.chatHistoryArray));
                currentInnerVoice = slotData.currentInnerVoice;
                friendData.currentEssay = slotData.currentEssay;
                // **修正：从 slotData.momentsFeed 加载到 momentsFeed，并提供备用空数组**
                momentsFeed = JSON.parse(JSON.stringify(slotData.momentsFeed || []));

                // 立即持久化到IndexedDB
                await putData('userData', userData);
                await putData('friendData', friendData);
                await putData('apiConfig', apiConfig);
                await putData('appSettings', appSettings);
                
                await clearStore('chatHistory');
                for (const bubble of chatHistoryArray) {
                    await putData('chatHistory', bubble);
                }

                // **修正：清空并恢复到正确的 momentsData 数据库表**
                await clearStore('momentsData');
                for (const moment of momentsFeed) {
                    await putData('momentsData', moment);
                }

                // 更新UI
                updateFriendNameInHeader();
                updateFriendConfigModalUI();
                updateApiFields();
                autoReplySwitch.checked = appSettings.autoReplyEnabled;
                inputAreaShiftUpSwitch.checked = appSettings.inputAreaShiftedUp;
                applyInputAreaShift(appSettings.inputAreaShiftedUp);
                innerVoiceFontSelect.value = appSettings.innerVoiceFont;
                applyInnerVoiceFont(appSettings.innerVoiceFont);
                essayFontSelect.value = appSettings.essayFont;
                applyEssayFont(appSettings.essayFont);
                emojiDisplayModeSelect.value = appSettings.emojiDisplayMode;
                applyTheme(appSettings.currentTheme);
                applyChatBackground(appSettings.chatBackground.type, appSettings.chatBackground.value);
                document.documentElement.style.setProperty('--input-area-height', `${document.querySelector('.input-area').offsetHeight}px`);
                renderEmojis();
                
                chatArea.innerHTML = '';
                chatHistoryArray.forEach(bubble => {
                    if (bubble.type === 'event') {
                        addEventMessageToDOM(bubble.content, bubble.messageId);
                    } else {
                        addBubbleToDOM({
                            messageId: bubble.messageId,
                            content: bubble.content,
                            type: bubble.type,
                            isRetracted: bubble.isRetracted,
                            isAutoReply: bubble.isAutoReply,
                            timestamp: bubble.timestamp,
                            displayTimeOverride: bubble.displayTimeOverride,
                            segmentType: bubble.segmentType,
                            cardData: bubble.cardData,
                            isOpened: bubble.isOpened
                        });
                    }
                });
                
                userMessageCounter = chatHistoryArray.filter(bubble => bubble.type === 'sent').length;
                scrollToBottom();
                document.getElementById('inner-voice-display').textContent = currentInnerVoice;
                document.getElementById('essay-display').textContent = friendData.currentEssay;
                await updateMomentsDisplay();

                // 恢复番茄钟状态
                if (appSettings.pomodoro.isActive) {
                    pomodoroGoal = appSettings.pomodoro.goal;
                    pomodoroStartTime = appSettings.pomodoro.startTime;
                    pomodoroEndTime = appSettings.pomodoro.endTime;
                    isPomodoroActive = true;
                    const now = Date.now();
                    if (pomodoroEndTime > now) {
                        resumePomodoroTimer();
                        pomodoroBtn.classList.add('active-pomodoro');
                        pomodoroBtn.title = `番茄钟：${pomodoroGoal} (专注中)`;
                    } else {
                        stopPomodoroTimer('completed');
                    }
                } else {
                    if (pomodoroTimer) clearInterval(pomodoroTimer);
                    pomodoroTimer = null;
                    isPomodoroActive = false;
                    pomodoroBtn.classList.remove('active-pomodoro');
                    pomodoroBtn.title = `番茄钟`;
                    pomodoroCountdownDisplay.textContent = '25:00';
                }

                closeModal(localRecordsModal);
                showNotification(`存档位 ${slotId} 已成功恢复！`);
                console.log(`Loaded state from ${slotId}`);

            } catch (error) {
                console.error('恢复存档失败:', error);
                showNotification('恢复存档失败，请检查控制台。');
            }
        }

        // 外部调用的删除函数，触发确认弹窗
        async function deleteSlot(slotId) {
            showCustomConfirm('删除存档确认', `确定要删除存档位 ${slotId} 的数据吗？此操作不可撤销。`,
                () => deleteSlotInternal(slotId), // 确认删除
                () => {} // 取消不做任何事
            );
        }

        // 实际执行删除操作的内部函数
        async function deleteSlotInternal(slotId) {
            localRecords[slotId] = null;
            await saveLocalRecords();
            await populateLocalRecordsModal(); // 刷新弹窗显示
            showNotification(`存档位 ${slotId} 已删除。`);
        }
        
        /**
         * 清除所有IndexedDB数据并重新加载页面
         */
        async function clearAllDataAndReload() {
            try {
                // 如果数据库连接是打开的，先关闭它
                if (db) {
                    db.close();
                    console.log('Database connection closed.');
                }
                
                console.log(`Attempting to delete database: ${DB_NAME}...`);
                const deleteRequest = indexedDB.deleteDatabase(DB_NAME);

                deleteRequest.onsuccess = () => {
                    console.log('Database deleted successfully.');
                    // 显示一个短暂的提示，然后刷新页面
                    showNotification('所有数据已清除，应用即将刷新...');
                    setTimeout(() => {
                        location.reload(true); // 使用 true 强制从服务器重新加载，尝试绕过缓存
                    }, 1500);
                };

                deleteRequest.onerror = (event) => {
                    console.error('Error deleting database:', event.target.error);
                    showNotification('删除数据失败，请手动清除浏览器数据或刷新页面。');
                };

                deleteRequest.onblocked = () => {
                    console.warn('Database deletion blocked. Please close other tabs of this app and try again.');
                    showNotification('数据清除被阻止，请关闭此应用的其他标签页后重试。');
                };

            } catch (error) {
                console.error('An error occurred during data clearing process:', error);
                showNotification('清除数据时发生未知错误。');
            }
        }

        // 初始化应用
        initApp();
    </script>
</body>
</html>